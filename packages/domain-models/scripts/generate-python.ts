#!/usr/bin/env tsx

/**
 * Generate Python Pydantic models from TypeScript interfaces
 * This creates the Python domain models that match our TypeScript definitions
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { SchemaDefinition } from './generate-schema';
import { loadSchemas } from './load-schema';

//--- Hoisted constants and regex helpers -----------------------------
const PY_TYPE_MAP: Record<string, string> = {
  string: 'str',
  number: 'float',
  boolean: 'bool',
  any: 'Any',
  unknown: 'Any',
  null: 'None',
  undefined: 'None',
  object: 'Dict[str, Any]',
  void: 'None',
};
const RE_BRAND   = /&\s*{.*/;                       // “… & { readonly … }”
const RE_IMPORT  = /^import\([^)]+\)\.(.+)$/;     // unwrap import()
const RE_ARRAY   = /^(.*)\[\]$/;                  // T[] syntax
const RE_GENERIC = /^Array<(.+)>$/;                 // Array<T> syntax

export class PythonGenerator {
  private typeCache = new Map<string, string>();
  private schemaMap = new Map<string, SchemaDefinition>();
  private imports  = new Map<string, Set<string>>();

  constructor(private schemas: SchemaDefinition[]) {
    // build custom-type lookup map
    schemas.forEach(s => this.schemaMap.set(s.name, s));
  }

  private addImport(from: string, ...items: string[]) {
    let set = this.imports.get(from);
    if (!set) {
      set = new Set<string>();
      this.imports.set(from, set);
    }
    items.forEach(i => set!.add(i));
  }

  private pyType(ts: string, opt = false): string {
    const key = `${ts}|${opt}`;
    const hit = this.typeCache.get(key);
    if (hit) return hit;

    const cache = (v: string) => (this.typeCache.set(key, v), v);
    const optional = (v: string) => {
      this.addImport('typing', 'Optional');
      return `Optional[${v}]`;
    };

    ts = ts.trim()
           .replace(RE_IMPORT, '$1')
           .replace(RE_BRAND, '')
           .trim();

    // Arrays ----------------------------------------------------------
    const arr = ts.match(RE_ARRAY);
    if (arr) {
      const inner = this.pyType(arr[1]);
      this.addImport('typing', 'List');
      const listType = `List[${inner}]`;
      return cache(opt ? optional(listType) : listType);
    }
    const gen = ts.match(RE_GENERIC);
    if (gen) {
      const innerRaw = gen[1].trim();
      if (innerRaw.startsWith('{')) {
        this.addImport('typing', 'Dict', 'Any', 'List');
        const py = 'List[Dict[str, Any]]';
        return cache(opt ? optional(py) : py);
      }
      const inner = this.pyType(innerRaw);
      this.addImport('typing', 'List');
      const listType = `List[${inner}]`;
      return cache(opt ? optional(listType) : listType);
    }

    // Record ----------------------------------------------------------
    if (ts.startsWith('Record<')) {
      this.addImport('typing', 'Dict', 'Any');
      const py = 'Dict[str, Any]';
      return cache(opt ? optional(py) : py);
    }

    // Union (non-literal) --------------------------------------------
    if (ts.includes('|') && !ts.includes('"')) {
      const branches = ts.split('|').map(x => this.pyType(x.trim()));
      const uniq = [...new Set(branches)];
      // Optional alias
      if (uniq.length === 2 && uniq.includes('None')) {
        const base = uniq.find(x => x !== 'None')!;
        return cache(optional(base));
      }
      this.addImport('typing', 'Union');
      const py = `Union[${uniq.join(', ')}]`;
      return cache(opt ? optional(py) : py);
    }

    // Literal ---------------------------------------------------------
    if (ts.includes('"')) {
      this.addImport('typing', 'Literal');
      const lits = ts.split('|')
        .map(x => x.trim())
        .filter(x => !['undefined', 'null'].includes(x));
      const py = `Literal[${lits.join(', ')}]`;
      return cache(opt ? optional(py) : py);
    }

    // Custom schema ---------------------------------------------------
    if (this.schemaMap.has(ts)) {
      return cache(opt ? optional(ts) : ts);
    }

    // Primitive / fallback -------------------------------------------
    const mapped = PY_TYPE_MAP[ts] ?? ts;
    if (mapped === 'Any') this.addImport('typing', 'Any');
    return cache(opt ? optional(mapped) : mapped);
  }

  public async generateAll(outputDir: string): Promise<void> {
    await fs.mkdir(outputDir, { recursive: true });

    for (const schema of this.schemas) {
      this.imports.clear();
      this.typeCache.clear();

      const lines: string[] = [];
      // file header
      lines.push('# Auto-generated by generate-python.ts; DO NOT EDIT');
      lines.push('from pydantic import BaseModel');
      this.addImport('pydantic', 'BaseModel');

      // build class body
      lines.push('', `class ${schema.name}(BaseModel):`);
      if (!schema.properties || Object.keys(schema.properties).length === 0) {
        lines.push('    pass');
      } else {
        for (const [propName, propInfo] of Object.entries(schema.properties)) {
          const pyT = this.pyType(propInfo.type, propInfo.optional);
          lines.push(`    ${propName}: ${pyT}`);
        }
      }

      // emit imports
      const header = [...this.imports.entries()]
        .filter(([from]) => from !== 'pydantic')
        .map(([from, items]) => `from ${from} import ${[...items].join(', ')}`)
        .join('\n');

      const content = [header, '', ...lines].join('\n');
      const outPath = path.join(outputDir, `${schema.name}.py`);
      await fs.writeFile(outPath, content);
    }
  }
}

//--- CLI Guard -------------------------------------------------------
if (import.meta.url === `file://${process.argv[1]}`) {
  (async () => {
  const schemas = await loadSchemas();
  const gen = new PythonGenerator(schemas);
  const outDir = path.resolve(process.cwd(), 'models');
  await gen.generateAll(outDir);
  console.log(`Generated ${schemas.length} models in ${outDir}`);
  })();
}
