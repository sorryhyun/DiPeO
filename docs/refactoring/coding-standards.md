# DiPeO Coding Standards

## Python Code Conventions

### Naming Conventions
- **Variables/Functions**: `snake_case`
  ```python
  def calculate_total_price(item_list):
      total_amount = 0
      max_iteration = 10
  ```

- **Classes**: `PascalCase`
  ```python
  class DiagramExecutor:
  class NodeValidator:
  ```

- **Constants**: `UPPER_SNAKE_CASE`
  ```python
  MAX_RETRIES = 3
  DEFAULT_TIMEOUT = 30
  API_BASE_URL = "https://api.example.com"
  ```

- **Private members**: Leading underscore
  ```python
  _internal_cache = {}
  def _validate_input():
  ```

- **Enum members**: `UPPER_SNAKE_CASE` 
  ```python
  class Status(Enum):
      PENDING = "pending"
      IN_PROGRESS = "in_progress"
      COMPLETED = "completed"
  ```

### Type Annotations
- All public functions must have type annotations
- Use `Optional[]` for nullable types
- Prefer specific types over `Any`
  ```python
  def process_diagram(
      diagram_id: DiagramID,
      options: Optional[ProcessOptions] = None
  ) -> Result[ExecutionResult, ProcessError]:
  ```

### Imports
- **No wildcard imports** in manually written code
- Explicit imports only:
  ```python
  # Good
  from dipeo.domain.enums import NodeType, Status, HandleDirection
  
  # Bad
  from dipeo.domain.enums import *
  ```
- Exception: Generated code templates may use wildcards for flexibility

### Field Naming in Models
- Python models use `snake_case` fields
- Use Pydantic `Field(alias=...)` for JSON compatibility:
  ```python
  class NodeData(BaseModel):
      max_iteration: int = Field(alias="maxIteration")
      file_path: Optional[str] = Field(alias="filePath", default=None)
  ```

## TypeScript Code Conventions

### Naming Conventions
- **Variables/Functions**: `camelCase`
  ```typescript
  const maxIteration = 10;
  function calculateTotal(itemList: Item[]): number
  ```

- **Types/Interfaces**: `PascalCase`
  ```typescript
  interface NodeData {
    maxIteration: number;
    filePath?: string;
  }
  ```

- **Enums**: `PascalCase` with `PascalCase` members
  ```typescript
  enum NodeType {
    Start = "start",
    Process = "process",
    End = "end"
  }
  ```

### Exports
- Prefer named exports over default exports
- Group related exports:
  ```typescript
  export { NodeType, HandleDirection } from './enums';
  export type { NodeData, ArrowData } from './types';
  ```

## Code Generation

### Template Guidelines
- Templates may use wildcard imports for flexibility
- Generated code should follow the same standards as manual code
- Always regenerate after modifying TypeScript specs:
  ```bash
  cd dipeo/models && pnpm build
  make codegen
  make apply-syntax-only
  make graphql-schema
  ```

### Generated Code Markers
- All generated files must include header:
  ```python
  # __generated__ by DiPeO
  # DO NOT EDIT THIS FILE DIRECTLY
  ```

## Architecture Patterns

### Hexagonal Architecture
- **Domain**: Pure business logic, no external dependencies
- **Application**: Use cases and orchestration
- **Infrastructure**: External adapters and I/O

### Dependency Injection
- Use ports (interfaces) in domain
- Implement adapters in infrastructure
- Wire through DI container:
  ```python
  class DiagramService(BaseService, DiagramPort):
      def __init__(self, storage: DiagramStoragePort):
          self.storage = storage
  ```

### Error Handling
- Use `Result` type for operations that can fail
- Raise specific exceptions for unrecoverable errors
- Log errors with appropriate levels:
  ```python
  try:
      result = await operation()
  except ValidationError as e:
      logger.warning(f"Validation failed: {e}")
      return Result.err(e)
  except Exception as e:
      logger.error(f"Unexpected error: {e}")
      raise
  ```

## Testing

### Test Organization
- Unit tests next to code: `module.py` â†’ `module_test.py`
- Integration tests in `tests/` directory
- Use descriptive test names:
  ```python
  def test_diagram_executor_handles_invalid_node_type():
  def test_snake_case_conversion_preserves_underscores():
  ```

### Test Coverage
- Aim for >80% coverage on business logic
- Focus on behavior, not implementation
- Mock external dependencies

## Documentation

### Docstrings
- Required for public modules, classes, and functions
- Use Google-style docstrings:
  ```python
  def process_node(node: Node, context: ExecutionContext) -> NodeResult:
      """Process a single node in the diagram.
      
      Args:
          node: The node to process
          context: Execution context with state and dependencies
          
      Returns:
          NodeResult containing output or error
          
      Raises:
          ValidationError: If node data is invalid
      """
  ```

### Comments
- Explain "why", not "what"
- Avoid redundant comments
- Use TODO/FIXME sparingly with issue references:
  ```python
  # TODO(#123): Optimize this for large diagrams
  # FIXME: Temporary workaround until TypeScript parser is fixed
  ```

## Git Commit Messages

### Format
```
<type>: <subject>

<body>

<footer>
```

### Types
- `feat`: New feature
- `fix`: Bug fix
- `refactor`: Code restructuring
- `docs`: Documentation only
- `test`: Test additions/changes
- `chore`: Maintenance tasks

### Examples
```
feat: add snake_case conversion to code generation

Automatically converts TypeScript camelCase fields to Python snake_case
with proper Pydantic aliases for JSON serialization compatibility.

Fixes #42
```

## Pre-commit Hooks

### Required Checks
- `mypy`: Type checking
- `ruff`: Linting and formatting
- `pytest`: Run tests
- Import sorting

### Setup
```bash
pre-commit install
pre-commit run --all-files  # Manual run
```

## Performance Guidelines

### Async Best Practices
- Use `asyncio.gather()` for parallel operations
- Avoid blocking I/O in async functions
- Properly handle cleanup in finally blocks

### Memory Management
- Use generators for large datasets
- Clear caches periodically
- Limit queue sizes for backpressure

## Security

### API Keys
- Never log or commit API keys
- Store in environment variables or secure storage
- Rotate keys regularly

### Input Validation
- Validate all external input
- Use Pydantic models for automatic validation
- Sanitize file paths and SQL queries

## Migration Path

### Phase 1 (Current)
- Apply naming conventions to new code
- Fix code generation
- Set up tooling

### Phase 2
- Remove deprecated code
- Consolidate enums
- Fix type safety issues

### Phase 3
- Refactor interfaces
- Simplify architecture
- Complete type annotations
