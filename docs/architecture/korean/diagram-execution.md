
# 다이어그램 실행 아키텍처

## 개요

DiPeO는 노드 사이 엣지(간선)를 따라 토큰이 이동하는 **토큰 기반 실행 모델**을 채택합니다. 이 문서는 핵심 실행 동작과 아키텍처 전반을 정리한 내용입니다.

## 핵심 개념

### 토큰(Tokens)
토큰은 DiPeO에서 데이터 흐름의 기본 단위입니다:
- 각 토큰은 타입이 지정된 데이터와 메타데이터를 담은 `Envelope`(엔벨로프)를 포함합니다
- 토큰은 `(edge, epoch, sequence_number)`로 식별됩니다
- 토큰은 소스 노드의 출력에서 타깃 노드의 입력으로 엣지를 따라 흐릅니다
- 노드는 입력 엣지에 충분한 토큰이 모이면 실행됩니다

### 에폭(Epochs)
에폭은 실행 세대를 추적합니다:
- 각 다이어그램 실행은 epoch 0에서 시작합니다
- 루프 컨트롤러는 반복마다 에폭을 증가시킵니다
- 노드는 에폭별 실행 횟수를 추적합니다(`max_iteration` 강제 적용용)
- 토큰은 에폭 스코프를 가지며, 반복 간 간섭을 방지합니다

### 엔벨로프(Envelopes)
엔벨로프는 노드 간 타입이 있는 통신을 제공합니다:
- 실제 데이터 페이로드(`body`)를 포함합니다
- 메타데이터(실행 시간, 토큰 사용량 등)를 포함합니다
- 여러 표현(텍스트, JSON, 바이너리)을 지원합니다
- `produced_by`와 `trace_id`를 통해 계보(lineage)를 추적합니다

## 조인 정책(Join Policies)

조인 정책은 노드가 실행에 충분한 입력을 갖추었는지 결정합니다:

### ALL (기본)
- 노드는 **모든** 비조건부 입력 엣지에 토큰이 있어야 합니다
- 순차 처리에 가장 흔히 사용됩니다
- 실행 전에 모든 의존성이 충족됨을 보장합니다

### ANY
- 노드는 **하나 이상**의 입력 엣지에 토큰이 있으면 됩니다
- 조건 노드 및 병렬 분기에서 사용됩니다
- 유연한 실행 패턴을 허용합니다

### K_OF_N
- 노드는 **최소 K개**의 입력 엣지에 토큰이 필요합니다
- 부분 합의나 정족수(quorum) 패턴에 유용합니다
- 노드 속성으로 구성합니다

## 조건 노드(Condition Nodes)

조건 노드는 분기 로직을 담당합니다.

### 분기 선택(Branch Selection)
1. 조건이 true/false로 평가됩니다
2. 활성 분기(`condtrue` 또는 `condfalse`)에만 토큰이 발행됩니다
3. 분기 결정은 다운스트림 참조를 위해 컨텍스트에 저장됩니다
4. 선택되지 않은 분기는 토큰을 받지 않습니다(자연스러운 흐름 제어)

#### 스킵 가능한 조건(Skippable Conditions)
- `skippable: true` 속성으로 표시합니다
- 스킵 가능한 조건에서 들어오는 엣지는 다운스트림 노드에 **필수 입력이 아닙니다**
- 실행을 막지 않는 선택적 분기를 허용합니다
- 예: 메인 플로우를 막지 않아야 하는 선택적 검증

**중요한 특수 사례**: 스킵 가능한 조건이 유일한 남은 의존성이 되는 순간(예: START 노드가 실행된 후)에는 교착을 방지하기 위해 필수로 전환되어야 합니다

## START 노드 동작

### 단일 실행
- START 노드는 다이어그램 실행 시작 시 정확히 한 번 실행됩니다
- 이 한 번의 실행 동안에만 토큰을 발행합니다
- 실행 이후, 루프가 있더라도 START 노드는 새로운 토큰을 생산하지 않습니다

### 루프와의 상호작용
한 노드에 START와 루프-백 엣지(예: 조건에서 되돌아오는 엣지)가 모두 연결된 경우:

1. **첫 번째 반복**: START 토큰만으로 노드가 실행될 수 있습니다
2. **이후 반복**: 노드는 루프-백 엣지에서 온 토큰만을 받아야 합니다

**알려진 이슈**: 다음 경우 교착 상태가 발생합니다:
- 한 노드에 START와 스킵 가능한 조건에서 오는 엣지가 모두 있는 경우
- START가 실행된 뒤 스킵 가능한 조건이 유일한 의존성이 됨
- 조건이 아직 실행되지 않아 순환 의존성이 생김

**제안된 해결책**:
- 노드가 START로부터의 토큰을 이미 소비했는지 추적합니다
- 타깃 노드가 최소 한 번 실행된 후에만 START 엣지를 무시합니다
- 스킵 가능한 조건이 유일한 의존성이 되는 순간 필수로 전환합니다

## 루프 제어

### PersonJobNode 반복
- `max_iteration` 속성으로 노드의 실행 횟수를 제한합니다
- `(node_id, epoch)` 쌍별로 카운터를 추적합니다
- 한계에 도달하면 노드는 `MAXITER_REACHED`로 전이합니다
- 다운스트림 노드는 `detect_max_iterations` 조건으로 이를 감지할 수 있습니다

### 루프 흐름
```yaml
# 루프 구조 예시
start -> person_job -> condition -> person_job (loop back)
                    \-> endpoint (exit)
````

1. PersonJobNode는 최대 `max_iteration` 횟수만큼 실행됩니다
2. 조건이 최대치에 도달했는지(`detect_max_iterations`) 확인합니다
3. false일 때: 토큰이 PersonJobNode로 되돌아갑니다
4. true일 때: 토큰이 종료 경로로 전달됩니다
5. 새로운 토큰이 더 이상 도착하지 않으면 루프는 자연스럽게 종료됩니다

## 실행 흐름

### 노드 실행 순서

1. **토큰 도착**: 노드로 향하는 엣지에 토큰이 발행됩니다
2. **준비성 확인**: 스케줄러가 조인 정책을 검사합니다
3. **소비**: 노드는 사용 가능한 모든 입력 토큰을 소비합니다
4. **실행**: 핸들러가 입력을 처리합니다
5. **출력**: 결과를 엔벨로프로 감쌉니다
6. **토큰 발행**: 출력 토큰이 나가는 엣지에 발행됩니다

### 병렬 실행

* 준비된 여러 노드는 동시에 실행될 수 있습니다
* 엔진은 세마포어로 병렬성을 관리합니다
* 기본 최대 동시 실행: 20개 노드
* 각 노드 실행은 서로 독립적입니다

### 핸들러 패턴

```python
class NodeHandler:
    def consume_token_inputs(request, inputs):
        # 들어오는 엣지에서 토큰을 가져옵니다
        return context.consume_inbound(node_id)
    
    def execute_with_envelopes(request, inputs):
        # 입력을 처리하고 Envelope를 반환합니다
        return EnvelopeFactory.create(result)
    
    # 출력은 엔진이 자동으로 토큰으로 발행합니다
```

## 상태 관리

### 노드 상태(UI 전용)

* `PENDING`: 아직 실행되지 않음
* `RUNNING`: 실행 중
* `COMPLETED`: 정상 완료
* `FAILED`: 실행 오류
* `MAXITER_REACHED`: 반복 한계 도달
* `SKIPPED`: 실행되지 않음(조건 분기)

**중요**: 상태는 UI 시각화를 위한 것입니다. 실제 실행은 토큰의 존재에 의해 구동됩니다.

### 실행 컨텍스트의 역할

* **토큰 작업**: 토큰 발행, 소비, 추적
* **상태 전이**: UI용 노드 상태 갱신
* **이벤트 발행**: 진행 상황을 구독자에 알림
* **서비스 접근**: 핸들러에 의존성 제공

## 핵심 원칙

1. **토큰 구동**: 실행은 전적으로 토큰 흐름에 의해 구동됩니다
2. **무상태 노드**: 노드는 실행 간 상태를 유지하지 않습니다
3. **에폭 격리**: 서로 다른 에폭의 토큰은 간섭하지 않습니다
4. **자연스러운 흐름 제어**: 선택적 토큰 발행으로 분기 처리
5. **암시적 동기화**: 조인 정책으로 조율

## 예시 실행 트레이스

### 성공적인 루프 실행

```
Epoch 0:
1. Start 노드 실행 -> PersonJob에 토큰 발행
2. PersonJob (반복 1) -> Condition에 토큰 발행
3. Condition이 false 평가 -> PersonJob으로 토큰 되돌려 발행
4. PersonJob (반복 2) -> Condition에 토큰 발행
5. Condition이 false 평가 -> PersonJob으로 토큰 되돌려 발행
6. PersonJob (반복 3) -> Condition에 토큰 발행
7. Condition이 max_iterations 감지 -> Ask로 토큰 발행
8. Ask 노드 실행 -> Endpoint로 토큰 발행
9. Endpoint가 결과 저장 -> 실행 완료
```

### 문제 시나리오(현재 이슈)

PersonJob에 START와 스킵 가능한 조건에서 들어오는 엣지가 모두 있는 경우:

```
start -> person_job <- condition (skippable, loop-back)
             |
             v
         condition
```

**발생 과정**:

1. START가 실행되어 PersonJob에 토큰을 발행
2. PersonJob이 실행(START 토큰 소비)
3. PersonJob이 Condition으로 토큰 발행
4. Condition이 false 평가, 원래는 PersonJob으로 토큰을 되돌려야 함
5. **교착 상태**: 이제 PersonJob은 Condition에서 온 토큰을 요구함(한 번 실행 후 START는 무시됨)

   * 그러나 Condition 엣지는 초기에는 "스킵 가능"이었음
   * 시스템이 이것을 유일한 의존성이 되자 필수로 전환함
   * 하지만 Condition → PersonJob으로 토큰 발행이 실제로 일어나지 않음

```

## 토큰 기반 아키텍처의 이점

### 단순성
- 하나의 메커니즘(토큰)으로 실행을 구동
- 복잡한 상태 머신이나 상태 추적 불필요
- 루프와 분기를 자연스럽게 처리

### 유연성
- 새로운 조인 정책을 쉽게 추가
- 조건 노드로 자연스러운 분기 구현
- 특별한 처리 없이도 루프 동작

### 성능
- 토큰이 있으면 병렬 실행
- 전역 락이나 동기화 불필요
- 준비된 노드의 효율적 탐지

### 디버깅
- 토큰 흐름 추적 가능
- 명확한 인과 체인
- 에폭 추적으로 반복 이력 확인

## 향후 개선

### 즉시 우선순위
- **START/스킵 조건 교착 수정**: START 실행 후 스킵 가능한 조건이 필수로 바뀌지만 토큰이 제대로 발행되지 않는 문제 해결
- **조건 토큰 발행 검증**: 조건 노드가 선택된 분기(condtrue/condfalse)로 토큰을 정확히 발행하도록 보장

### 계획됨
- 자동 정리를 위한 토큰 TTL
- 실행 순서를 위한 토큰 우선순위
- 윈도우 토큰을 사용하는 스트림 처리
- 엣지 수준 처리를 위한 토큰 변환기

### 검토 중
- 디버깅을 위한 토큰 리플레이
- 내결함성을 위한 토큰 영속화
- 확장을 위한 분산 토큰 전달
- 토큰 기반 백프레셔 제어
