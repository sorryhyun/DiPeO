# Diagram-to-Python Export

DiPeO diagrams can be exported to standalone Python scripts that run without the DiPeO runtime.

## Overview

The export feature converts DiPeO diagrams into self-contained Python scripts focusing on:
- ✅ **LLM calls** (person_job nodes) → Direct API calls using OpenAI/Anthropic SDKs
- ✅ **DB read/write** (db nodes) → File I/O operations
- ✅ **Code execution** (code_job nodes) → Inline Python code
- ✅ **Control flow** (condition, start, endpoint) → Native Python control structures
- ✅ **Sub-diagrams** (sub_diagram nodes) → Separate Python modules or inline functions

**Not included**: DB state management, monitor logic, or advanced runtime features.

## Usage

### CLI Command

```bash
dipeo export <diagram> <output.py> [--light|--native|--readable]
```

### Examples

```bash
# Export a light format diagram
dipeo export examples/simple_diagrams/simple_iter_code.light.yaml output.py --light

# Run the exported script
python output.py
```

## Supported Node Types

### Start Node
Generates a print statement indicating execution start.

```python
# Start
print("Starting execution...")
```

### Code Job Node
Executes inline Python code directly.

```python
# Code Job
a = 1
result = f"Value: {a}"
```

### Person Job Node (LLM Calls)
Generates API calls to OpenAI or Anthropic.

**OpenAI/GPT:**
```python
from openai import AsyncOpenAI

openai_client = AsyncOpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

response = await openai_client.chat.completions.create(
    model="gpt-4",
    messages=[{"role": "user", "content": prompt}]
)
output = response.choices[0].message.content
```

**Anthropic/Claude:**
```python
from anthropic import AsyncAnthropic

anthropic_client = AsyncAnthropic(api_key=os.environ.get("ANTHROPIC_API_KEY"))

response = await anthropic_client.messages.create(
    model="claude-3-5-sonnet-20241022",
    max_tokens=1024,
    messages=[{"role": "user", "content": prompt}]
)
output = response.content[0].text
```

### Condition Node
Translates to Python if/else or while loops.

```python
# Condition
if a > 10:
    # condtrue path
    pass
else:
    # condfalse path
    pass
```

### DB Node (File Operations)
Uses Python's file I/O.

**Read:**
```python
from pathlib import Path

content = Path("data.txt").read_text()
```

**Write:**
```python
db_path = Path("output.txt")
db_path.parent.mkdir(parents=True, exist_ok=True)
db_path.write_text(str(content))
```

### Endpoint Node
Saves final results to a file.

```python
# Endpoint
output_path = Path("files/results/output.txt")
output_path.parent.mkdir(parents=True, exist_ok=True)
output_path.write_text(str(result))
print(f"✅ Saved output to {output_path}")
```

### Sub-Diagram Node
Executes other diagrams as reusable components.

**Named Diagram (separate module):**
```python
# Import sub-diagram as module
from codegen_node_ui import main as run_codegen_node_ui

# Map inputs for sub-diagram
sub_inputs = {
    'spec_path': node_specification,
    'output_dir': output_directory,
}

# Execute sub-diagram
sub_diagram_output = await run_codegen_node_ui(**sub_inputs)

# Map outputs
processed_spec = sub_diagram_output.get('processed_spec')
```

**Batch Mode:**
```python
# Batch mode: processing multiple items
batch_results = []
for item in inputs.get('items', []):
    # Map inputs for sub-diagram
    sub_inputs = {
        'data': item,
    }

    sub_diagram_output = await run_processor(**sub_inputs)
    batch_results.append(sub_diagram_output)

print(f'Batch processing complete: {len(batch_results)} items')
```

**Note**: When using named sub-diagrams, you must export each sub-diagram separately:

```bash
# Export the main diagram
dipeo export main_diagram.light.yaml main.py --light

# Export each sub-diagram
dipeo export codegen/node_ui.light.yaml codegen_node_ui.py --light

# Ensure sub-diagram modules are in the same directory or PYTHONPATH
```

## Complete Example

**Input** (`simple_iter_code.light.yaml`):
```yaml
version: light
nodes:
- label: Start
  type: start
- label: Code Job~1
  type: code_job
  props:
    code: a=1
- label: Code Job
  type: code_job
  props:
    code: |
      a+=1
      result = f"Iteration with a={a-1}"
- label: Condition
  type: condition
  props:
    condition_type: custom
    expression: a > 10
- label: Endpoint
  type: endpoint
  props:
    save_to_file: true
    file_path: files/results/output.txt
connections:
- from: Start
  to: Code Job~1
- from: Code Job~1
  to: Code Job
- from: Code Job
  to: Condition
- from: Condition_condtrue
  to: Endpoint
- from: Condition_condfalse
  to: Code Job
```

**Output** (`output.py`):
```python
#!/usr/bin/env python3
"""
Generated by DiPeO Diagram-to-Python Exporter
"""

import asyncio
from pathlib import Path


async def main():
    """Main execution function."""

    # Start
    print("Starting execution...")

    # Code Job~1
    a=1

    # Loop structure
    while True:
        # Code Job
        a+=1
        result = f"Iteration with a={a-1}"

        # Condition
        if a > 10:
            break

    # Endpoint
    output_path = Path("files/results/output.txt")
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(str(result))
    print(f"✅ Saved output to {output_path}")

    print("✅ Execution complete")


if __name__ == "__main__":
    asyncio.run(main())
```

## Environment Variables

For diagrams with person_job nodes, set the appropriate API keys:

```bash
# OpenAI
export OPENAI_API_KEY="your-api-key"

# Anthropic
export ANTHROPIC_API_KEY="your-api-key"

# Run exported script
python output.py
```

## Dependencies

Exported scripts require:
- Python 3.10+
- `asyncio` (built-in)
- `pathlib` (built-in)
- `openai` package (for OpenAI/GPT nodes)
- `anthropic` package (for Anthropic/Claude nodes)

Install dependencies:
```bash
pip install openai anthropic
```

## Limitations

- Complex control flow may require manual adjustment
- Inline sub-diagrams (diagram_data) require manual conversion to functions
- Named sub-diagrams must be exported separately before the main diagram
- Some advanced node types may generate TODO comments

## Future Enhancements

- Automatic recursive export of sub-diagrams
- Full inline sub-diagram support with auto-generated functions
- More sophisticated control flow detection
- Error handling and retry logic
