# Dog-fooding in DiPeO: Using DiPeO to Build DiPeO

## Overview

"Dog-fooding" (eating your own dog food) is the practice of using your own products internally. In DiPeO, we take this concept to heart by using DiPeO's visual workflow system to automate and improve DiPeO's own development processes. This document explores how DiPeO leverages its own capabilities for code generation and other development workflows.

## Why Dog-food?

1. **Validation**: If DiPeO can't handle its own development workflows, how can we expect others to use it for theirs?
2. **Continuous Improvement**: Using DiPeO daily reveals pain points and opportunities for enhancement
3. **Real-world Testing**: Our development workflows serve as complex, real-world test cases
4. **Documentation by Example**: These workflows demonstrate advanced DiPeO patterns

## Code Generation: The Ultimate Dog-fooding Example

### The Challenge

Adding a new node type to DiPeO traditionally requires:
- Creating TypeScript interfaces in `dipeo/models/src/nodes/`
- Writing Python models in `dipeo/core/static/nodes/`
- Defining GraphQL schemas
- Building React components
- Creating field configurations
- Registering the node in multiple places
- Writing handler implementations

This process is error-prone, tedious, and requires updating 10+ files across the codebase.

### The DiPeO Solution

We built a DiPeO diagram (`files/diagrams/codegen/main.light.yaml`) that automates this entire process:

```yaml
# Simplified view of the code generation workflow
Start → Load Node Spec → Validate → Parse → Generate Files → Verify → Report
```

Here's how it works:

#### 1. Node Specification

New nodes are defined in simple JSON files:

```json
{
  "nodeType": "hook",
  "displayName": "Hook",
  "category": "control",
  "icon": "🪝",
  "fields": [
    {
      "name": "hook_type",
      "type": "enum",
      "values": ["shell", "http", "python", "file"],
      "required": true
    }
  ]
}
```

#### 2. The Code Generation Diagram

The main workflow (`codegen/main.light.yaml`) demonstrates advanced DiPeO patterns:

- **File Operations**: Uses `db` nodes to read specifications and templates
- **Validation**: `json_schema_validator` ensures specifications are valid
- **Code Jobs**: Python functions parse specs and prepare data
- **Template Jobs**: Handlebars templates generate TypeScript, Python, GraphQL, and React code
- **AI Verification**: Person jobs review generated code for quality and security
- **Parallel Processing**: Multiple generation tasks run simultaneously
- **Error Handling**: Condition nodes handle validation failures

#### 3. Key Components

**Parse Spec Data** (Code Job):
```python
def parse_spec_data(inputs: Dict[str, Any]) -> Dict[str, Any]:
    """Parse the spec data and prepare context for templates."""
    spec = inputs.get('raw_data', {})
    
    # Convert to template-friendly format
    return {
        'spec': spec,
        'nodeType': spec['nodeType'],
        'camelCase': to_camel_case(spec['nodeType']),
        'fields': spec.get('fields', []),
        # ... more transformations
    }
```

**Generate TypeScript Model** (Template Job):
```handlebars
// Generated from specification: {{nodeType}}
export interface {{pascalCase nodeType}}NodeData extends BaseNodeData {
  {{#each fields}}
  {{name}}{{#unless required}}?{{/unless}}: {{tsType type}};
  {{/each}}
}
```

**AI Code Verification** (Person Job):
```yaml
- label: Verify Generated Code
  type: person_job
  props:
    person: CodeReviewer
    default_prompt: |
      Review the generated {{code_type}} file for:
      1. Syntax errors
      2. Security vulnerabilities  
      3. Naming conventions
      4. Completeness
      
      Provide PASS/FAIL verdict with specific issues.
```

### Benefits Realized

1. **Time Savings**: Node generation reduced from ~2 hours to ~5 minutes
2. **Consistency**: All generated code follows the same patterns
3. **Quality**: AI verification catches issues before they reach the codebase
4. **Documentation**: The workflow itself documents the process

## Other Dog-fooding Examples

### 1. Documentation Generation

We use DiPeO to generate its own documentation:

```yaml
# Simplified documentation workflow
Read Source Files → Extract Comments → 
Generate Markdown → AI Review → Publish
```

### 2. Release Automation

Our release process is a DiPeO diagram:

```yaml
# Release workflow
Check Tests → Build → Generate Changelog → 
Create Release → Notify Team
```

### 3. Code Migration

When updating APIs or patterns, we use DiPeO:

```yaml
# Migration workflow
Find Old Pattern → Generate AST → 
Transform Code → Verify → Apply Changes
```

## Advanced Dog-fooding Patterns

### 1. Self-Modifying Workflows

The code generation workflow can generate new node types that enhance the workflow itself:

```python
# A hook node generated by the workflow could be used 
# to trigger the workflow automatically
- label: File Watcher Hook
  type: hook  # This node type was generated by DiPeO!
  props:
    hook_type: file
    watch_path: files/specifications/nodes/
    on_change: trigger_codegen
```

### 2. Recursive Generation

DiPeO can generate DiPeO diagrams:

```yaml
# Diagram that generates other diagrams
Analyze Requirements → Design Workflow → 
Generate Diagram YAML → Validate → Deploy
```

### 3. Meta-Programming

Using code jobs to generate code jobs:

```python
def generate_handler(inputs):
    """Generate a node handler that generates other handlers"""
    node_type = inputs['node_type']
    
    handler_code = f"""
def handle_{node_type}(inputs):
    # This handler was generated by DiPeO
    # and can itself generate more handlers
    return generate_next_handler(inputs)
"""
    return {"generated_code": handler_code}
```

## Best Practices for Dog-fooding

### 1. Start Simple

Begin with straightforward automation:
- File format conversions
- Report generation
- Basic code scaffolding

### 2. Iterate Based on Pain

When you find yourself doing something repeatedly, ask:
- Can this be a DiPeO diagram?
- What nodes would I need?
- Is this worth automating?

### 3. Build Reusable Components

Create template diagrams for common patterns:
- Code generation pipelines
- Validation workflows
- Documentation builders

### 4. Leverage AI Wisely

Use AI persons for:
- Code review and quality checks
- Documentation improvement
- Pattern recognition
- Creative problem solving

### 5. Monitor and Measure

Track metrics from your dog-fooding:
- Time saved
- Errors prevented
- Consistency improvements
- Developer satisfaction

## Case Study: The Code Generation Evolution

### Version 1: Manual Templates

Initially, we used simple template substitution:

```yaml
- label: Generate Code
  type: code_job
  props:
    code: |
      template = open('template.txt').read()
      return template.replace('{{TYPE}}', node_type)
```

### Version 2: Smart Templates

We evolved to use Handlebars with helpers:

```yaml
- label: Generate Code
  type: template_job
  props:
    template_path: templates/model.hbs
    engine: handlebars
    helpers:
      - pascalCase
      - camelCase
      - tsType
```

### Version 3: AI-Enhanced Generation

Now we combine templates with AI verification:

```yaml
# Template generates initial code
Generate Code → 
# AI reviews and suggests improvements
AI Code Review → 
# Condition checks if changes needed
Need Changes? → 
# Loop back or proceed
[Yes: Regenerate] [No: Finalize]
```

### Version 4: Self-Improving System

The latest version learns from past generations:

```yaml
# System tracks what worked well
Generate → Review → Store Feedback →
# Future generations use this feedback
Load Best Practices → Generate Better Code
```

## Implementation Guide

### Setting Up Your First Dog-fooding Workflow

1. **Identify a Repetitive Task**
   ```yaml
   # Example: Generating API client code from OpenAPI specs
   - What files do I create manually?
   - What patterns do I follow?
   - What mistakes do I make?
   ```

2. **Design the Workflow**
   ```yaml
   nodes:
   - label: Load OpenAPI Spec
     type: db
     props:
       source_details: api/openapi.yaml
   
   - label: Parse Spec
     type: code_job
     props:
       code: |
         import yaml
         spec = yaml.safe_load(openapi_spec)
         return extract_endpoints(spec)
   
   - label: Generate Client
     type: template_job
     props:
       template_path: templates/api_client.hbs
   ```

3. **Add Intelligence**
   ```yaml
   - label: Optimize Generated Code
     type: person_job
     props:
       person: CodeOptimizer
       default_prompt: |
         Review this generated API client.
         Suggest performance optimizations.
         Ensure it follows our coding standards.
   ```

4. **Create Feedback Loops**
   ```yaml
   - label: Test Generated Code
     type: code_job
     props:
       code: |
         # Run tests on generated code
         # Feed results back to improve templates
   ```

## Challenges and Solutions

### Challenge 1: Complexity Management

**Problem**: Dog-fooding workflows can become overly complex

**Solution**: 
- Break into sub-diagrams
- Use clear naming conventions
- Document each step's purpose
- Regular refactoring

### Challenge 2: Version Control

**Problem**: Generated code needs to be tracked but not edited

**Solution**:
```yaml
- label: Add Generation Header
  type: code_job
  props:
    code: |
      header = """
      # GENERATED FILE - DO NOT EDIT
      # Generated by: diagrams/codegen/main.yaml
      # Generated at: {timestamp}
      # To modify: edit the source specification
      """
      return header + generated_code
```

### Challenge 3: Debugging Generated Code

**Problem**: Hard to debug code that generates code

**Solution**: Use intermediate outputs and logging
```yaml
- label: Debug Generation
  type: code_job
  props:
    code: |
      # Save intermediate states
      save_debug("step1_parsed_spec.json", parsed_spec)
      save_debug("step2_template_data.json", template_data)
      save_debug("step3_generated_code.ts", generated_code)
```

## Future Directions

### 1. AI-Driven Workflow Generation

Using AI to suggest dog-fooding opportunities:

```yaml
- label: Analyze Development Patterns
  type: person_job
  props:
    person: WorkflowDesigner
    default_prompt: |
      Analyze our git history for repetitive tasks.
      Suggest DiPeO workflows to automate them.
      Prioritize by potential time savings.
```

### 2. Cross-Project Dog-fooding

Sharing dog-fooding workflows between projects:

```yaml
# Central registry of reusable workflows
- Code quality checks
- Documentation generation
- Deployment pipelines
- Testing automation
```

### 3. Metrics and Analytics

Building dashboards to track dog-fooding effectiveness:

```yaml
- Time saved per workflow
- Error reduction rates
- Developer adoption metrics
- Workflow execution patterns
```

## Conclusion

Dog-fooding in DiPeO isn't just about using our own tool—it's about pushing the boundaries of what visual programming can achieve. By using DiPeO to build DiPeO, we:

1. **Validate** that our tool handles complex, real-world workflows
2. **Discover** new patterns and best practices
3. **Improve** both the tool and our development process
4. **Demonstrate** the power of visual workflow automation

The code generation workflow alone has saved hundreds of hours and prevented countless errors. More importantly, it's shown us that DiPeO can handle sophisticated metaprogramming tasks that were traditionally the domain of specialized build tools.

As you build your own DiPeO workflows, consider how they might be used to improve your development process. The best DiPeO diagrams are often the ones that make DiPeO itself better.

### Getting Started with Dog-fooding

1. **Start Small**: Automate one repetitive task
2. **Iterate Often**: Improve the workflow as you use it
3. **Share Patterns**: Document what works
4. **Think Meta**: Can your workflow improve itself?

Remember: If you're building tools with DiPeO, you should be building DiPeO with DiPeO.