type ApiKey {
  maskedKey: String!
  id: String!
  label: String!
  service: LLMService!
}

"""Unique identifier for an API key"""
scalar ApiKeyID

type ApiKeyResult {
  success: Boolean!
  apiKey: ApiKey
  message: String
  error: String
}

type Arrow {
  data: JSONScalar
  id: String!
  source: String!
  target: String!
}

"""Unique identifier for an arrow"""
scalar ArrowID

input CreateApiKeyInput {
  label: String!
  service: LLMService!
  key: String!
}

input CreateArrowInput {
  source: String!
  target: String!
  label: String = null
}

input CreateDiagramInput {
  name: String!
  description: String = null
  author: String = null
  tags: [String!] = []
}

input CreateHandleInput {
  nodeId: String!
  label: String!
  direction: HandleDirection!
  dataType: DataType! = ANY
  position: Vec2Input = null
  maxConnections: Int = null
}

input CreateNodeInput {
  type: NodeType!
  position: Vec2Input!
  label: String!

  """Node-specific properties"""
  properties: JSONScalar = {}
}

input CreatePersonInput {
  label: String!
  service: LLMService!
  model: String!
  apiKeyId: String!
  systemPrompt: String = null
  forgettingMode: ForgettingMode! = NONE
  temperature: Float = null
  maxTokens: Int = null
  topP: Float = null
}

enum DataType {
  ANY
  STRING
  NUMBER
  BOOLEAN
  OBJECT
  ARRAY
}

"""Date with time (isoformat)"""
scalar DateTime

type DeleteResult {
  success: Boolean!
  deletedId: String
  message: String
  error: String
}

type Diagram {
  nodeCount: Int!
  arrowCount: Int!
  personCount: Int!
  estimatedCost: Float
  nodes: [Node!]!
  handles: [Handle!]!
  arrows: [Arrow!]!
  persons: [Person!]!
  apiKeys: [ApiKey!]!
  metadata: DiagramMetadata
}

input DiagramFilterInput {
  nameContains: String = null
  author: String = null
  tags: [String!] = null
  createdAfter: DateTime = null
  createdBefore: DateTime = null
  modifiedAfter: DateTime = null
}

"""Unique identifier for a diagram"""
scalar DiagramID

type DiagramMetadata {
  id: String
  name: String
  description: String
  version: String!
  created: DateTime!
  modified: DateTime!
  author: String
  tags: [String!]
}

type DiagramResult {
  success: Boolean!
  diagram: Diagram
  message: String
  error: String
}

type DiagramUploadResult {
  success: Boolean!
  message: String!
  diagramId: String
  diagramName: String
  nodeCount: Int
}

enum EventType {
  EXECUTION_STARTED
  NODE_STARTED
  NODE_PROGRESS
  NODE_COMPLETED
  NODE_FAILED
  NODE_SKIPPED
  NODE_PAUSED
  EXECUTION_COMPLETED
  EXECUTION_FAILED
  EXECUTION_ABORTED
  INTERACTIVE_PROMPT
  INTERACTIVE_RESPONSE
}

input ExecuteDiagramInput {
  diagramId: String!
  variables: JSONScalar = null
  debugMode: Boolean! = false

  """Execution timeout in seconds"""
  timeoutSeconds: Int = null

  """Maximum iterations for execution"""
  maxIterations: Int = null
}

input ExecutionControlInput {
  executionId: String!
  action: String!
  nodeId: String = null
}

type ExecutionEvent {
  data: JSONScalar
  formattedMessage: String!
  executionId: String!
  sequence: Int!
  eventType: String!
  nodeId: String
  timestamp: DateTime!
}

input ExecutionFilterInput {
  diagramId: String = null
  status: ExecutionStatus = null
  startedAfter: DateTime = null
  startedBefore: DateTime = null
  activeOnly: Boolean! = false
}

"""Unique identifier for an execution"""
scalar ExecutionID

type ExecutionResult {
  success: Boolean!
  execution: ExecutionState
  executionId: ExecutionID
  message: String
  error: String
}

type ExecutionState {
  nodeOutputs: JSONScalar
  variables: JSONScalar
  durationSeconds: Float
  isActive: Boolean!
  id: String!
  status: ExecutionStatus!
  diagramId: String
  startedAt: DateTime!
  endedAt: DateTime
  runningNodes: [String!]!
  completedNodes: [String!]!
  skippedNodes: [String!]!
  pausedNodes: [String!]!
  failedNodes: [String!]!
  tokenUsage: TokenUsage
  error: String
}

enum ExecutionStatus {
  STARTED
  RUNNING
  PAUSED
  COMPLETED
  FAILED
  ABORTED
}

input FileUploadInput {
  filename: String!
  contentBase64: String!
  contentType: String = null
}

type FileUploadResult {
  success: Boolean!
  path: String
  sizeBytes: Int
  contentType: String
  message: String
  error: String
}

enum ForgettingMode {
  NO_FORGET
  NONE
  ON_EVERY_TURN
  UPON_REQUEST
}

type Handle {
  id: String!
  nodeId: String!
  label: String!
  direction: HandleDirection!
  dataType: DataType!
  position: String
}

enum HandleDirection {
  INPUT
  OUTPUT
}

"""Unique identifier for a handle (format: nodeId:handleName)"""
scalar HandleID

type HandleResult {
  success: Boolean!
  handle: Handle
  message: String
  error: String
}

input ImportYamlInput {
  content: String!
  filename: String = null
}

type InteractivePrompt {
  executionId: ExecutionID!
  nodeId: NodeID!
  prompt: String!
  timeoutSeconds: Int
  timestamp: DateTime!
}

input InteractiveResponseInput {
  executionId: String!
  nodeId: String!
  response: String!
}

"""Arbitrary JSON-serializable data"""
scalar JSONScalar

enum LLMService {
  OPENAI
  ANTHROPIC
  GOOGLE
  GROK
  BEDROCK
  VERTEX
  DEEPSEEK
}

type Mutation {
  createDiagram(input: CreateDiagramInput!): DiagramResult!
  deleteDiagram(id: DiagramID!): DeleteResult!
  saveDiagram(diagramId: DiagramID!, format: String = null): DiagramResult!
  convertDiagram(diagramId: DiagramID!, targetFormat: String!): DiagramResult!
  importYamlDiagram(input: ImportYamlInput!): DiagramResult!
  createNode(diagramId: DiagramID!, input: CreateNodeInput!): NodeResult!
  updateNode(input: UpdateNodeInput!): NodeResult!
  deleteNode(id: NodeID!): DeleteResult!
  createArrow(diagramId: DiagramID!, input: CreateArrowInput!): DiagramResult!
  deleteArrow(id: ArrowID!): DeleteResult!
  createPerson(diagramId: DiagramID!, input: CreatePersonInput!): PersonResult!
  updatePerson(input: UpdatePersonInput!): PersonResult!
  deletePerson(id: PersonID!): DeleteResult!
  initializeModel(personId: PersonID!): PersonResult!
  createApiKey(input: CreateApiKeyInput!): ApiKeyResult!
  testApiKey(id: ApiKeyID!): TestApiKeyResult!
  deleteApiKey(id: ApiKeyID!): DeleteResult!
  executeDiagram(input: ExecuteDiagramInput!): ExecutionResult!
  controlExecution(input: ExecutionControlInput!): ExecutionResult!
  submitInteractiveResponse(input: InteractiveResponseInput!): ExecutionResult!
  createHandle(input: CreateHandleInput!): HandleResult!
  deleteHandle(id: HandleID!): DeleteResult!
  clearConversations: DeleteResult!
  uploadFile(input: FileUploadInput!): FileUploadResult!
  uploadDiagram(file: Upload!): DiagramUploadResult!
  uploadMultipleFiles(files: [Upload!]!, category: String! = "general"): [FileUploadResult!]!
}

type Node {
  data: JSONScalar
  displayName: String!
  handles: [Handle!]!
  id: String!
  type: NodeType!
  position: Vec2!
}

type NodeExecution {
  executionId: ExecutionID!
  nodeId: NodeID!
  nodeType: NodeType!
  status: String!
  progress: String
  output: JSONScalar
  error: String
  tokensUsed: Int
  timestamp: DateTime!
}

"""Unique identifier for a node"""
scalar NodeID

type NodeResult {
  success: Boolean!
  node: Node
  message: String
  error: String
}

enum NodeType {
  START
  PERSON_JOB
  CONDITION
  JOB
  ENDPOINT
  DB
  USER_RESPONSE
  NOTION
  PERSON_BATCH_JOB
}

type Person {
  maskedApiKey: String
  id: String!
  label: String!
  service: LLMService!
  model: String!
  apiKeyId: String!
  systemPrompt: String
  forgettingMode: ForgettingMode!
  type: String!
}

"""Unique identifier for a person (LLM agent)"""
scalar PersonID

type PersonResult {
  success: Boolean!
  person: Person
  message: String
  error: String
}

type Query {
  diagram(id: DiagramID!): Diagram
  diagrams(filter: DiagramFilterInput = null, limit: Int! = 100, offset: Int! = 0): [Diagram!]!
  execution(id: ExecutionID!): ExecutionState
  executions(filter: ExecutionFilterInput = null, limit: Int! = 100, offset: Int! = 0): [ExecutionState!]!
  executionEvents(executionId: ExecutionID!, sinceSequence: Int = null, limit: Int! = 1000): [ExecutionEvent!]!
  person(id: PersonID!): Person
  persons(limit: Int! = 100): [Person!]!
  apiKey(id: ApiKeyID!): ApiKey
  apiKeys(service: String = null): [ApiKey!]!
  availableModels(service: String!, apiKeyId: ApiKeyID!): [String!]!
  systemInfo: JSONScalar!
  executionCapabilities: JSONScalar!
  health: JSONScalar!
  conversations(personId: PersonID = null, executionId: ExecutionID = null, search: String = null, showForgotten: Boolean! = false, limit: Int! = 100, offset: Int! = 0, since: DateTime = null): JSONScalar!
}

type Subscription {
  executionUpdates(executionId: ExecutionID!): ExecutionState!
  executionEvents(executionId: ExecutionID!, eventTypes: [EventType!] = null): ExecutionEvent!
  nodeUpdates(executionId: ExecutionID!, nodeTypes: [NodeType!] = null): NodeExecution!
  diagramChanges(diagramId: DiagramID!): Diagram!
  interactivePrompts(executionId: ExecutionID!): InteractivePrompt!
}

type TestApiKeyResult {
  success: Boolean!
  valid: Boolean!
  availableModels: [String!]
  error: String
}

type TokenUsage {
  input: Int!
  output: Int!
  cached: Int
  total: Int!
}

input UpdateNodeInput {
  id: String!
  position: Vec2Input = null
  label: String = null
  properties: JSONScalar = null
}

input UpdatePersonInput {
  id: String!
  label: String = null
  model: String = null
  apiKeyId: String = null
  systemPrompt: String = null
  forgettingMode: ForgettingMode = null
  temperature: Float = null
  maxTokens: Int = null
  topP: Float = null
}

scalar Upload

type Vec2 {
  x: Float!
  y: Float!
}

input Vec2Input {
  x: Float!
  y: Float!
}
