{
  "architecture": {
    "overview": "A modular React + TypeScript single-page application with clear separation between core kernel (contracts, events, DI), foundational app wiring (entry, app, routes, providers), services (API, auth), shared UI components, hooks, and feature pages. The app uses React Router for navigation, React Query for server state, a small DI/event system for cross-cutting concerns, and a context-based Auth provider for session management.",
    "patterns": [
      "Layered Architecture: core (contracts/events/utils) -> services -> providers -> hooks -> components -> pages",
      "Provider Pattern: React Query and Auth are provided at top-level App",
      "Container/Presentational: pages (containers) use hooks/services; shared components are presentational",
      "Dependency Injection / Service Locator: lightweight DI container in core/di.ts to register/test mocks",
      "Event Bus: core/events.ts for cross-cutting pub/sub",
      "Single Responsibility: each file has one responsibility (one component or service)"
    ],
    "data_flow": "Data flows from UI (components/pages) -> hooks -> services -> API. React Query caches server state and provides stale-while-revalidate behavior. AuthProvider exposes user/session via React Context; useAuth hook reads session and triggers authService. services/api.ts centralizes HTTP calls and config.ts provides base URLs and feature flags. core/events.ts notifies cross-cutting changes (e.g., logout). DI container can provide alternate implementations for testing.",
    "folder_structure": "src/\n  app/\n    App.tsx                # Root app wiring, providers + Router\n    config.ts              # Materialized runtime config (app baseURL, env flags)\n    routes.tsx             # Route definitions (route objects used by App)\n  core/\n    contracts.ts           # Domain types and API contracts\n    events.ts              # Lightweight event bus\n    hooks.ts               # Hook registry (extension point)\n    di.ts                  # Minimal DI container / service registry\n    utils.ts               # Small shared utilities (formatters, guards)\n  providers/\n    ReactQueryProvider.tsx # Wrapper to configure QueryClient and error handling\n    AuthProvider.tsx       # Auth context and session management provider\n  services/\n    api.ts                 # HTTP client wrapper (fetch/axios) using config\n    authService.ts         # Auth API calls and token handling\n  lib/\n    storage.ts             # Local/session storage wrapper used by authService\n  hooks/\n    useAuth.ts             # Hook to access auth context and actions\n    useFetch.ts            # Wrapper hook around react-query for typed fetches\n  shared/\n    components/\n      Button.tsx\n      Input.tsx\n      Layout.tsx\n  routes/\n    AuthRoute.tsx          # Protected-route wrapper using useAuth\n  features/\n    home/\n      HomePage.tsx\n    dashboard/\n      DashboardPage.tsx\n      components/\n        MetricCard.tsx\n  pages/\n    NotFound.tsx\n  main.tsx                 # Application entry (mount React)\n  index.css                # Global styles (Tailwind entry / base styles)\n\nNotes:\n- All imports should reference files under src/. Config/build tooling files are provided separately.\n- React Query + React Router are central; adjust providers if you choose another state solution.",
    "tech_stack": [
      "React 18+ with functional components and hooks",
      "TypeScript (strict mode recommended)",
      "React Router v6+ for routing",
      "React Query (TanStack Query) for server state / caching",
      "Fetch or Axios (centralized in services/api.ts)",
      "Tailwind CSS for styling (index.css entry)",
      "Optional small DI/event system implemented in core/"
    ]
  },
  "kernel_specs": {
    "overview": "The core kernel provides the single source of truth for domain types, runtime configuration, cross-cutting eventing, extension hooks, dependency injection tokens and small utilities. All application sections (providers, services, hooks, pages, components) should import types and singletons from these files. The kernel is minimal but type-safe, enabling decoupled communication (EventBus), extensibility (HookRegistry), and testable service swapping (DI container)."
  },
  "sections": [
    {
      "id": "app-config",
      "file_path": "src/app/config.ts",
      "description": "Materialized runtime configuration (apiBaseUrl, env, feature flags). Exposes a typed config object read by services and providers.",
      "dependencies": [
        "src/core/contracts.ts"
      ],
      "exports": [
        "default AppConfig object",
        "getConfig helper"
      ],
      "priority": 1,
      "purpose": "Materialized runtime configuration (apiBaseUrl, env, feature flags). Exposes a typed config object read by services and providers; computes effective flags and optionally provides mock data when development_mode.enable_mock_data is enabled.",
      "content": "/* src/app/config.ts\n\nMaterialized runtime configuration.\n- Keep the runtime values deterministic and serializable.\n- Provide computed helpers (isDevelopment, shouldUseMockData).\n- If development_mode.enable_mock_data is true, export a MOCK_USER to make local development easier.\n\nUsage: import config, { isFeatureEnabled } from '@/app/config'\n*/\n\nimport { AppConfig, User, Role } from '@/core/contracts';\n\n// NOTE: These values are intentionally baked in for development/demo runs.\n// In a real build you'd replace these using environment interpolation (process.env or injected JSON).\n\nconst rawConfig: AppConfig = {\n  env: (process.env.NODE_ENV as AppConfig['env']) || 'development',\n  apiBaseUrl: process.env.REACT_APP_API_BASE_URL || 'https://api.example.com',\n  socketUrl: process.env.REACT_APP_SOCKET_URL || 'wss://ws.example.com',\n  featureFlags: {\n    appointments: true,\n    telehealth: false,\n    labs: true,\n    prescriptions: true,\n    experimental_new_ui: false\n  },\n  development_mode: {\n    enable_mock_data: (process.env.REACT_APP_ENABLE_MOCK === 'true') || true\n  },\n  appName: 'Health Portal',\n  version: process.env.REACT_APP_VERSION || '0.0.0-dev'\n};\n\nexport default rawConfig;\n\nexport function getConfig(): AppConfig {\n  return rawConfig;\n}\n\nexport const isDevelopment = rawConfig.env === 'development';\nexport const shouldUseMockData = !!rawConfig.development_mode?.enable_mock_data;\n\nexport function isFeatureEnabled(featureName: string): boolean {\n  return !!rawConfig.featureFlags[featureName];\n}\n\n// Provide lightweight in-memory mock user for local development when enabled.\nexport const MOCK_USER: User | null = shouldUseMockData\n  ? {\n      id: 'mock-user-1',\n      email: 'jane.doe@example.com',\n      fullName: 'Jane Doe',\n      role: 'doctor',\n      specialty: 'General Medicine',\n      createdAt: new Date().toISOString(),\n      avatarUrl: undefined\n    }\n  : null;\n\n// Export a narrow helper for tests / startup code\nexport function getMockUser(): User | null {\n  return MOCK_USER;\n}\n"
    },
    {
      "id": "core-contracts",
      "file_path": "src/core/contracts.ts",
      "description": "Domain types, API request/response interfaces, and shared TypeScript contracts used across the app (User, AuthToken, ApiResponse<T>, AppConfig shape). Central single source of truth for types.",
      "dependencies": [],
      "exports": [
        "types: User, AuthToken, ApiResponse<T>, LoginRequest, AppConfig"
      ],
      "priority": 1,
      "purpose": "Domain types and shared TypeScript contracts used across the app (healthcare models, API result shapes, UI helper types, auth types and app config shapes). Central single source of truth for all domain typing.",
      "content": "/* src/core/contracts.ts\n\nThis file centralizes domain types used throughout the app. Keep types strict and descriptive. Use discriminated unions for role-specific users and maintain stable API shapes.\n\nUsage: import { User, ApiResult } from '@/core/contracts'\n*/\n\n// Basic role enumeration\nexport type Role = 'admin' | 'doctor' | 'nurse' | 'patient' | 'guest';\n\n// Generic small ID type\nexport type ID = string;\n\n// Authentication related\nexport interface AuthToken {\n  accessToken: string;\n  refreshToken?: string;\n  expiresAt?: string; // ISO timestamp\n}\n\nexport interface LoginRequest {\n  email: string;\n  password: string;\n  remember?: boolean;\n}\n\n// User base and role-specific user models\nexport interface UserBase {\n  id: ID;\n  email: string;\n  fullName: string;\n  role: Role;\n  avatarUrl?: string;\n  createdAt: string; // ISO\n  updatedAt?: string; // ISO\n}\n\nexport interface Patient extends UserBase {\n  role: 'patient';\n  dateOfBirth?: string; // ISO\n  medicalRecordId?: ID;\n  primaryDoctorId?: ID | null;\n}\n\nexport interface Doctor extends UserBase {\n  role: 'doctor';\n  specialty?: string;\n  licenseNumber?: string;\n}\n\nexport interface Nurse extends UserBase {\n  role: 'nurse';\n  department?: string;\n}\n\nexport type User = Patient | Doctor | Nurse | (UserBase & { role: 'admin' | 'guest' });\n\n// Healthcare domain models\nexport interface Appointment {\n  id: ID;\n  patientId: ID;\n  doctorId: ID;\n  scheduledAt: string; // ISO\n  durationMins?: number;\n  location?: string;\n  status: 'scheduled' | 'cancelled' | 'completed' | 'no_show';\n  notes?: string;\n}\n\nexport interface MedicalRecord {\n  id: ID;\n  patientId: ID;\n  summary?: string;\n  allergies?: string[];\n  conditions?: string[];\n  medications?: Prescription[];\n  lastUpdated: string; // ISO\n}\n\nexport interface Prescription {\n  id: ID;\n  medication: string;\n  dose?: string;\n  frequency?: string;\n  prescribedById?: ID;\n  issuedAt?: string; // ISO\n  notes?: string;\n}\n\nexport interface LabResult {\n  id: ID;\n  patientId: ID;\n  testName: string;\n  resultValue: string;\n  unit?: string;\n  normalRange?: string;\n  collectedAt?: string; // ISO\n  reportedAt?: string; // ISO\n}\n\n// API response shapes used by services/api.ts\nexport interface ApiError {\n  code?: string | number;\n  message: string;\n  details?: Record<string, unknown> | string;\n}\n\nexport interface ApiResult<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: ApiError;\n  meta?: Record<string, unknown>;\n}\n\nexport interface PaginatedResponse<T> {\n  items: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n}\n\n// WebSocket events (if app uses sockets)\nexport type WebSocketEventType =\n  | 'appointment.updated'\n  | 'labresult.added'\n  | 'prescription.updated'\n  | 'user.notification'\n  | 'system.heartbeat';\n\nexport interface WebSocketEvent<T = any> {\n  id: string;\n  type: WebSocketEventType;\n  payload: T;\n  timestamp: string; // ISO\n}\n\nexport interface WebSocketEventMap {\n  'appointment.updated': WebSocketEvent<Appointment>;\n  'labresult.added': WebSocketEvent<LabResult>;\n  'prescription.updated': WebSocketEvent<Prescription>;\n  'user.notification': WebSocketEvent<{ title: string; body?: string }>;\n  'system.heartbeat': WebSocketEvent<null>;\n}\n\n// UI helper types\nexport type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\nexport interface FormState<V = Record<string, unknown>> {\n  values: V;\n  errors: Partial<Record<keyof V, string>>;\n  touched: Partial<Record<keyof V, boolean>>;\n  isSubmitting: boolean;\n}\n\n// App configuration shape (mirrors src/app/config.ts runtime object)\nexport interface AppConfig {\n  env: 'development' | 'staging' | 'production';\n  apiBaseUrl: string;\n  socketUrl?: string;\n  featureFlags: Record<string, boolean>;\n  development_mode: {\n    enable_mock_data: boolean;\n  };\n  appName: string;\n  version?: string;\n}\n\n// Example named exports collected above are exported by default via 'export' usage.\n"
    },
    {
      "id": "core-di",
      "file_path": "src/core/di.ts",
      "description": "Minimal dependency injection / service registry to register and resolve service implementations (used for testing or swapping implementations at startup).",
      "dependencies": [
        "src/core/contracts.ts"
      ],
      "exports": [
        "registerService, resolveService, ServiceToken type"
      ],
      "priority": 1,
      "purpose": "Minimal dependency injection / service registry that allows registering and resolving typed services. Useful for swapping implementations during tests or bootstrapping alternative implementations on startup.\n\nProvided tokens: ApiClientToken, AuthServiceToken, StorageServiceToken, WebSocketServiceToken",
      "content": "/* src/core/di.ts\n\nSimple, type-safe DI container using tokens (unique symbols). Register concrete implementations keyed by a token and resolve them later.\n\nPattern:\n  const token = createToken<MyService>('MyService')\n  container.register(token, new MyServiceImpl())\n  const svc = container.resolve(token)\n\nThis keeps runtime overhead low while enabling test swapping.\n*/\n\nexport type ServiceToken<T> = { readonly __token: unique symbol; readonly name?: string } & (symbol | string);\n\nexport function createToken<T>(name?: string): ServiceToken<T> {\n  const sym = Symbol(name || 'service');\n  // cast to ServiceToken<T>\n  return sym as unknown as ServiceToken<T>;\n}\n\nexport class Container {\n  private registry = new Map<ServiceToken<any>, any>();\n\n  register<T>(token: ServiceToken<T>, impl: T): void {\n    if (this.registry.has(token)) {\n      // allow idempotent re-registration in tests, but warn\n      // eslint-disable-next-line no-console\n      console.warn(`[DI] overriding registration for token: ${(token as any).toString?.() ?? String(token)}`);\n    }\n    this.registry.set(token, impl);\n  }\n\n  resolve<T>(token: ServiceToken<T>): T {\n    const impl = this.registry.get(token);\n    if (impl === undefined) {\n      throw new Error(`[DI] No registration found for token: ${(token as any).toString?.() ?? String(token)}`);\n    }\n    return impl as T;\n  }\n\n  resolveOptional<T>(token: ServiceToken<T>): T | undefined {\n    return this.registry.get(token) as T | undefined;\n  }\n\n  has(token: ServiceToken<any>): boolean {\n    return this.registry.has(token);\n  }\n\n  clear(): void {\n    this.registry.clear();\n  }\n}\n\n// Default global container (useful for app-wide registrations)\nexport const container = new Container();\n\n// Common tokens used across the app\nexport const ApiClientToken = createToken<any>('ApiClient');\nexport const AuthServiceToken = createToken<any>('AuthService');\nexport const StorageServiceToken = createToken<any>('StorageService');\nexport const WebSocketServiceToken = createToken<any>('WebSocketService');\n\n// Convenience wrappers\nexport function registerService<T>(token: ServiceToken<T>, impl: T): void {\n  container.register(token, impl);\n}\n\nexport function resolveService<T>(token: ServiceToken<T>): T {\n  return container.resolve(token);\n}\n\nexport function resolveOptional<T>(token: ServiceToken<T>): T | undefined {\n  return container.resolveOptional(token);\n}\n"
    },
    {
      "id": "core-events",
      "file_path": "src/core/events.ts",
      "description": "A lightweight event bus/pub-sub used for cross-cutting notifications (e.g., global logout, theme change). Provides typed emit/subscribe/unsubscribe helpers.",
      "dependencies": [],
      "exports": [
        "EventBus instance",
        "on, off, emit helpers"
      ],
      "priority": 1,
      "purpose": "A lightweight typed EventBus for cross-cutting pub/sub. Used by providers, services and features to react to global changes (login/logout, route changes, notifications).",
      "content": "/* src/core/events.ts\n\nTyped EventBus implementation.\n- Supports synchronous and asynchronous handlers (handlers may return Promise).\n- Strongly typed event map ensures payloads are correct.\n- Exports a singleton `eventBus` to be used across the app.\n\nUsage:\n  import { eventBus } from '@/core/events'\n  eventBus.on('auth.login', payload => {...})\n  eventBus.emit('auth.logout')\n*/\n\nimport { User, Appointment, WebSocketEvent } from '@/core/contracts';\n\n// Define core event keys and payloads\nexport interface CoreEventMap {\n  'auth.login': { user: User };\n  'auth.logout': { reason?: string };\n  'profile.updated': { user: User };\n  'appointment.changed': { appointment: Appointment };\n  'route.change': { pathname: string; params?: Record<string, string> };\n  'notification': { title: string; body?: string; level?: 'info' | 'warn' | 'error' };\n  'ws.event': { event: WebSocketEvent };\n}\n\nexport type CoreEventKey = keyof CoreEventMap;\n\ntype Handler<E extends CoreEventKey> = (payload: CoreEventMap[E]) => void | Promise<void>;\n\nexport class EventBus {\n  private handlers: Map<string, Set<Function>> = new Map();\n\n  on<E extends CoreEventKey>(event: E, handler: Handler<E>): () => void {\n    const existing = this.handlers.get(event as string) || new Set<Function>();\n    existing.add(handler);\n    this.handlers.set(event as string, existing);\n\n    // return unsubscribe\n    return () => this.off(event, handler as any);\n  }\n\n  off<E extends CoreEventKey>(event: E, handler?: Handler<E>): void {\n    const set = this.handlers.get(event as string);\n    if (!set) return;\n    if (!handler) {\n      set.clear();\n      return;\n    }\n    set.delete(handler as Function);\n    if (set.size === 0) this.handlers.delete(event as string);\n  }\n\n  async emit<E extends CoreEventKey>(event: E, payload: CoreEventMap[E]): Promise<void> {\n    const set = this.handlers.get(event as string);\n    if (!set) return;\n\n    // Call handlers in registration order (iteration order of Set)\n    const promises: Promise<void>[] = [];\n    for (const fn of Array.from(set.values())) {\n      try {\n        const result = (fn as Handler<E>)(payload);\n        if (result && typeof (result as Promise<void>).then === 'function') {\n          promises.push(result as Promise<void>);\n        }\n      } catch (err) {\n        // swallow errors but log; do not rethrow to keep bus robust\n        // eslint-disable-next-line no-console\n        console.error('[EventBus] handler error for event', event, err);\n      }\n    }\n    if (promises.length > 0) {\n      await Promise.all(promises).catch(err => {\n        // eslint-disable-next-line no-console\n        console.error('[EventBus] async handler error', err);\n      });\n    }\n  }\n\n  once<E extends CoreEventKey>(event: E, handler: Handler<E>): () => void {\n    const remover = this.on(event, async (payload) => {\n      try {\n        await handler(payload as CoreEventMap[E]);\n      } finally {\n        remover();\n      }\n    });\n    return remover;\n  }\n}\n\n// Singleton instance used across the app\nexport const eventBus = new EventBus();\n\n// Convenience top-level helpers\nexport const on = <E extends CoreEventKey>(event: E, handler: Handler<E>) => eventBus.on(event, handler);\nexport const off = <E extends CoreEventKey>(event: E, handler?: Handler<E>) => eventBus.off(event, handler);\nexport const emit = async <E extends CoreEventKey>(event: E, payload: CoreEventMap[E]) => eventBus.emit(event, payload);\n"
    },
    {
      "id": "core-hooks-registry",
      "file_path": "src/core/hooks.ts",
      "description": "Registry for extension hooks (plugin points). Allows registering lifecycle or extension callbacks. Small API used by providers or features to register behaviors.",
      "dependencies": [],
      "exports": [
        "registerHook, runHook functions",
        "Hook types"
      ],
      "priority": 1,
      "purpose": "Hook registry for extension points. Provides a typed, simple API to register extension callbacks and run them. Used by services and providers to offer extension points for plugins or features.\n\nStandard hooks implemented: beforeApiRequest, afterApiResponse, onLogin, onLogout, onRouteChange",
      "content": "/* src/core/hooks.ts\n\nThe HookRegistry enables lightweight plugin-style extension points. Hooks are simple and may be synchronous or return a Promise.\n\n- registerHook returns an unregister function\n- runHook executes all listeners and returns aggregated results\n\nUsage:\n  import { registerHook, runHook } from '@/core/hooks'\n  registerHook('beforeApiRequest', ctx => { ctx.headers['x-trace-id']=... })\n  await runHook('beforeApiRequest', { url, method, headers })\n*/\n\nimport { ApiResult, User } from '@/core/contracts';\n\nexport type HookPoint =\n  | 'beforeApiRequest'\n  | 'afterApiResponse'\n  | 'onLogin'\n  | 'onLogout'\n  | 'onRouteChange';\n\n// Contexts per hook. Keep contexts minimal and stable.\nexport interface BeforeApiRequestContext {\n  url: string;\n  method: string;\n  headers: Record<string, string>;\n  body?: unknown;\n  // handlers may attach metadata\n  meta?: Record<string, unknown>;\n}\n\nexport interface AfterApiResponseContext<T = any> {\n  url: string;\n  method: string;\n  response: ApiResult<T>;\n  meta?: Record<string, unknown>;\n}\n\nexport interface OnLoginContext {\n  user: User;\n}\n\nexport interface OnLogoutContext {\n  reason?: string;\n}\n\nexport interface OnRouteChangeContext {\n  pathname: string;\n  params?: Record<string, string>;\n}\n\nexport type HookContextMap = {\n  beforeApiRequest: BeforeApiRequestContext;\n  afterApiResponse: AfterApiResponseContext;\n  onLogin: OnLoginContext;\n  onLogout: OnLogoutContext;\n  onRouteChange: OnRouteChangeContext;\n};\n\nexport type HookCallback<K extends HookPoint> = (ctx: HookContextMap[K]) => void | Promise<void>;\n\nexport class HookRegistry {\n  private store: Map<HookPoint, Set<Function>> = new Map();\n\n  register<K extends HookPoint>(hook: K, fn: HookCallback<K>): () => void {\n    const set = this.store.get(hook) || new Set<Function>();\n    set.add(fn);\n    this.store.set(hook, set);\n    return () => this.unregister(hook, fn as Function);\n  }\n\n  unregister(hook: HookPoint, fn?: Function): void {\n    const set = this.store.get(hook);\n    if (!set) return;\n    if (!fn) {\n      set.clear();\n      return;\n    }\n    set.delete(fn);\n    if (set.size === 0) this.store.delete(hook);\n  }\n\n  async run<K extends HookPoint>(hook: K, ctx: HookContextMap[K]): Promise<void> {\n    const set = this.store.get(hook);\n    if (!set || set.size === 0) return;\n    // Execute in registration order\n    const promises: Promise<void>[] = [];\n    for (const fn of Array.from(set.values())) {\n      try {\n        const result = (fn as HookCallback<K>)(ctx);\n        if (result && typeof (result as Promise<void>).then === 'function') {\n          promises.push(result as Promise<void>);\n        }\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('[HookRegistry] hook handler error', hook, err);\n      }\n    }\n    if (promises.length) {\n      await Promise.all(promises).catch(err => {\n        // eslint-disable-next-line no-console\n        console.error('[HookRegistry] async hook error', err);\n      });\n    }\n  }\n}\n\n// Singleton registry\nexport const hooks = new HookRegistry();\n\n// Convenience helpers\nexport function registerHook<K extends HookPoint>(hook: K, fn: HookCallback<K>): () => void {\n  return hooks.register(hook, fn as any);\n}\n\nexport function runHook<K extends HookPoint>(hook: K, ctx: HookContextMap[K]): Promise<void> {\n  return hooks.run(hook, ctx as any);\n}\n"
    },
    {
      "id": "core-utils",
      "file_path": "src/core/utils.ts",
      "description": "General small utilities used across the app (formatDate, noop, safeJsonParse, buildUrl).",
      "dependencies": [],
      "exports": [
        "formatDate, buildUrl, safeJsonParse, noop"
      ],
      "priority": 1,
      "purpose": "Small utilities used across the app: formatDate, buildUrl, safeJsonParse, noop and light validation helpers. Keep functions pure and small.\n\nExported utilities are intentionally generic and zero-dependency.",
      "content": "/* src/core/utils.ts\n\nGeneral utilities used across services and components.\n*/\n\nexport function noop(..._args: any[]): void {\n  // no operation - useful default callback\n}\n\nexport function isDefined<T>(v: T | null | undefined): v is T {\n  return v !== null && v !== undefined;\n}\n\nexport function safeJsonParse<T = any>(input: string | null | undefined, fallback?: T): T | undefined {\n  if (input == null) return fallback;\n  try {\n    return JSON.parse(input) as T;\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.warn('[safeJsonParse] failed to parse', err);\n    return fallback;\n  }\n}\n\nexport function safeJsonStringify(obj: unknown): string | undefined {\n  try {\n    return JSON.stringify(obj);\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.warn('[safeJsonStringify] failed to stringify', err);\n    return undefined;\n  }\n}\n\nexport function formatDate(iso?: string | Date, opts?: Intl.DateTimeFormatOptions): string {\n  if (!iso) return '';\n  const d = typeof iso === 'string' ? new Date(iso) : iso;\n  try {\n    return new Intl.DateTimeFormat(undefined, opts || { year: 'numeric', month: 'short', day: 'numeric' }).format(d);\n  } catch (err) {\n    // fallback\n    return d.toLocaleString();\n  }\n}\n\nexport function buildUrl(base: string, path?: string, query?: Record<string, string | number | undefined | null>): string {\n  const url = new URL(path ? path.replace(/^\\/+/, '') : '', base.endsWith('/') ? base : base + '/');\n  if (query) {\n    Object.entries(query).forEach(([k, v]) => {\n      if (v === undefined || v === null) return;\n      url.searchParams.set(k, String(v));\n    });\n  }\n  return url.toString();\n}\n"
    },
    {
      "id": "app-root",
      "file_path": "src/app/App.tsx",
      "description": "Root React component: composes providers (ReactQueryProvider, AuthProvider) and renders Router using routes.tsx. Global error boundary can be added here.",
      "dependencies": [
        "src/app/routes.tsx",
        "src/providers/ReactQueryProvider.tsx",
        "src/providers/AuthProvider.tsx"
      ],
      "exports": [
        "App component (default export)"
      ],
      "priority": 2
    },
    {
      "id": "app-routes",
      "file_path": "src/app/routes.tsx",
      "description": "Central routes definition used by App. Declares route tree and uses AuthRoute for protected routes. Exports a Routes component or an array of route objects.",
      "dependencies": [
        "src/features/home/HomePage.tsx",
        "src/features/dashboard/DashboardPage.tsx",
        "src/pages/NotFound.tsx",
        "src/routes/AuthRoute.tsx"
      ],
      "exports": [
        "AppRoutes component (React Router v6 <Routes>)"
      ],
      "priority": 2
    },
    {
      "id": "auth-provider",
      "file_path": "src/providers/AuthProvider.tsx",
      "description": "Auth context provider handling session state, token storage, and refresh logic. Uses storage.ts and authService. Emits events to core/events on login/logout.",
      "dependencies": [
        "src/core/events.ts",
        "src/lib/storage.ts",
        "src/services/authService.ts",
        "src/core/contracts.ts"
      ],
      "exports": [
        "AuthProvider component",
        "AuthContext (typed) \u2014 available to useAuth hook"
      ],
      "priority": 2
    },
    {
      "id": "hook-use-auth",
      "file_path": "src/hooks/useAuth.ts",
      "description": "Custom hook that exposes auth context (user, token, login, logout) for components. Relies on AuthProvider context and authService for actions.",
      "dependencies": [
        "src/providers/AuthProvider.tsx",
        "src/services/authService.ts",
        "src/core/contracts.ts"
      ],
      "exports": [
        "useAuth hook"
      ],
      "priority": 2
    },
    {
      "id": "hook-use-fetch",
      "file_path": "src/hooks/useFetch.ts",
      "description": "Typed wrapper around React Query's useQuery/useMutation to standardize fetch patterns (key building, error handling). Used by pages and components to fetch server data.",
      "dependencies": [
        "src/services/api.ts",
        "src/providers/ReactQueryProvider.tsx"
      ],
      "exports": [
        "useFetchQuery, useFetchMutation hooks"
      ],
      "priority": 2
    },
    {
      "id": "index-css",
      "file_path": "src/index.css",
      "description": "Global CSS entry point (Tailwind base, custom utilities and element resets). Imported by main.tsx.",
      "dependencies": [],
      "exports": [
        "CSS (side-effect import)"
      ],
      "priority": 2
    },
    {
      "id": "lib-storage",
      "file_path": "src/lib/storage.ts",
      "description": "Wrapper around localStorage/sessionStorage with safe JSON handling and a consistent key prefix. Used by AuthProvider and services.",
      "dependencies": [],
      "exports": [
        "getItem, setItem, removeItem helpers",
        "STORAGE_KEYS constant"
      ],
      "priority": 2
    },
    {
      "id": "main-entry",
      "file_path": "src/main.tsx",
      "description": "Application entry \u2014 mounts the React tree. Wraps App with any non-React providers (but main providers live in App). Imports global styles.",
      "dependencies": [
        "src/app/App.tsx",
        "src/index.css"
      ],
      "exports": [
        "React DOM mount (default run file, no named exports)"
      ],
      "priority": 2
    },
    {
      "id": "react-query-provider",
      "file_path": "src/providers/ReactQueryProvider.tsx",
      "description": "Configures and provides a React Query QueryClient to the app. Sets global default behaviors (retry, staleTime) and an error handling layer.",
      "dependencies": [
        "src/app/config.ts"
      ],
      "exports": [
        "ReactQueryProvider component (wraps children)"
      ],
      "priority": 2
    },
    {
      "id": "services-api",
      "file_path": "src/services/api.ts",
      "description": "Centralized HTTP client wrapper exposing typed request helpers (get/post/put/delete). Applies base URL from app config and attaches auth tokens (if present). Normalizes ApiResponse<T> using core/contracts.",
      "dependencies": [
        "src/app/config.ts",
        "src/core/contracts.ts",
        "src/core/utils.ts",
        "src/lib/storage.ts"
      ],
      "exports": [
        "apiClient (get/post/put/delete) functions",
        "setAuthToken helper"
      ],
      "priority": 2
    },
    {
      "id": "services-auth",
      "file_path": "src/services/authService.ts",
      "description": "Auth-related API calls: login, logout, refresh token, getProfile. Uses services/api.ts to call server and lib/storage for persistence.",
      "dependencies": [
        "src/services/api.ts",
        "src/lib/storage.ts",
        "src/core/contracts.ts",
        "src/core/events.ts"
      ],
      "exports": [
        "login, logout, refreshToken, fetchProfile functions"
      ],
      "priority": 2
    },
    {
      "id": "feature-dashboard-metric-card",
      "file_path": "src/features/dashboard/components/MetricCard.tsx",
      "description": "Small presentational card used on the dashboard to surface a metric (title, value, delta).",
      "dependencies": [
        "src/shared/components/Button.tsx"
      ],
      "exports": [
        "MetricCard component"
      ],
      "priority": 3
    },
    {
      "id": "feature-dashboard-page",
      "file_path": "src/features/dashboard/DashboardPage.tsx",
      "description": "Protected dashboard page that displays multiple MetricCard components and fetches authenticated data using useFetch and useAuth for context.",
      "dependencies": [
        "src/shared/components/Layout.tsx",
        "src/features/dashboard/components/MetricCard.tsx",
        "src/hooks/useFetch.ts",
        "src/hooks/useAuth.ts"
      ],
      "exports": [
        "DashboardPage component"
      ],
      "priority": 3
    },
    {
      "id": "feature-home-page",
      "file_path": "src/features/home/HomePage.tsx",
      "description": "Public landing/home page. Demonstrates useFetch hook for public data fetch and links to dashboard. Uses shared Layout.",
      "dependencies": [
        "src/shared/components/Layout.tsx",
        "src/hooks/useFetch.ts",
        "src/shared/components/Button.tsx"
      ],
      "exports": [
        "HomePage component"
      ],
      "priority": 3
    },
    {
      "id": "page-not-found",
      "file_path": "src/pages/NotFound.tsx",
      "description": "404 page displayed for unmatched routes. Uses shared Layout and a CTA back to home.",
      "dependencies": [
        "src/shared/components/Layout.tsx",
        "src/shared/components/Button.tsx"
      ],
      "exports": [
        "NotFound page component"
      ],
      "priority": 3
    },
    {
      "id": "routes-auth-route",
      "file_path": "src/routes/AuthRoute.tsx",
      "description": "Route wrapper to secure pages. If user is unauthenticated, redirects to login/home; otherwise renders the child route/component.",
      "dependencies": [
        "src/hooks/useAuth.ts",
        "src/app/routes.tsx"
      ],
      "exports": [
        "AuthRoute component"
      ],
      "priority": 3
    },
    {
      "id": "shared-button",
      "file_path": "src/shared/components/Button.tsx",
      "description": "Small, accessible button component with variants and size props. Used across forms and pages.",
      "dependencies": [],
      "exports": [
        "Button component (default export)",
        "ButtonProps type"
      ],
      "priority": 3
    },
    {
      "id": "shared-input",
      "file_path": "src/shared/components/Input.tsx",
      "description": "Accessible input component wrapping native input with label support and error states. Used by forms in the app.",
      "dependencies": [],
      "exports": [
        "Input component (default export)",
        "InputProps type"
      ],
      "priority": 3
    },
    {
      "id": "shared-layout",
      "file_path": "src/shared/components/Layout.tsx",
      "description": "Application layout component: header (with login state), main content container, and footer. Consumed by pages to provide consistent structure.",
      "dependencies": [
        "src/shared/components/Button.tsx",
        "src/hooks/useAuth.ts"
      ],
      "exports": [
        "Layout component (default export)"
      ],
      "priority": 3
    }
  ],
  "file_paths": [
    "src/app/config.ts",
    "src/core/contracts.ts",
    "src/core/di.ts",
    "src/core/events.ts",
    "src/core/hooks.ts",
    "src/core/utils.ts",
    "src/app/App.tsx",
    "src/app/routes.tsx",
    "src/providers/AuthProvider.tsx",
    "src/hooks/useAuth.ts",
    "src/hooks/useFetch.ts",
    "src/index.css",
    "src/lib/storage.ts",
    "src/main.tsx",
    "src/providers/ReactQueryProvider.tsx",
    "src/services/api.ts",
    "src/services/authService.ts",
    "src/features/dashboard/components/MetricCard.tsx",
    "src/features/dashboard/DashboardPage.tsx",
    "src/features/home/HomePage.tsx",
    "src/pages/NotFound.tsx",
    "src/routes/AuthRoute.tsx",
    "src/shared/components/Button.tsx",
    "src/shared/components/Input.tsx",
    "src/shared/components/Layout.tsx"
  ],
  "descriptions": [
    "Materialized runtime configuration (apiBaseUrl, env, feature flags). Exposes a typed config object read by services and providers.",
    "Domain types, API request/response interfaces, and shared TypeScript contracts used across the app (User, AuthToken, ApiResponse<T>, AppConfig shape). Central single source of truth for types.",
    "Minimal dependency injection / service registry to register and resolve service implementations (used for testing or swapping implementations at startup).",
    "A lightweight event bus/pub-sub used for cross-cutting notifications (e.g., global logout, theme change). Provides typed emit/subscribe/unsubscribe helpers.",
    "Registry for extension hooks (plugin points). Allows registering lifecycle or extension callbacks. Small API used by providers or features to register behaviors.",
    "General small utilities used across the app (formatDate, noop, safeJsonParse, buildUrl).",
    "Root React component: composes providers (ReactQueryProvider, AuthProvider) and renders Router using routes.tsx. Global error boundary can be added here.",
    "Central routes definition used by App. Declares route tree and uses AuthRoute for protected routes. Exports a Routes component or an array of route objects.",
    "Auth context provider handling session state, token storage, and refresh logic. Uses storage.ts and authService. Emits events to core/events on login/logout.",
    "Custom hook that exposes auth context (user, token, login, logout) for components. Relies on AuthProvider context and authService for actions.",
    "Typed wrapper around React Query's useQuery/useMutation to standardize fetch patterns (key building, error handling). Used by pages and components to fetch server data.",
    "Global CSS entry point (Tailwind base, custom utilities and element resets). Imported by main.tsx.",
    "Wrapper around localStorage/sessionStorage with safe JSON handling and a consistent key prefix. Used by AuthProvider and services.",
    "Application entry \u2014 mounts the React tree. Wraps App with any non-React providers (but main providers live in App). Imports global styles.",
    "Configures and provides a React Query QueryClient to the app. Sets global default behaviors (retry, staleTime) and an error handling layer.",
    "Centralized HTTP client wrapper exposing typed request helpers (get/post/put/delete). Applies base URL from app config and attaches auth tokens (if present). Normalizes ApiResponse<T> using core/contracts.",
    "Auth-related API calls: login, logout, refresh token, getProfile. Uses services/api.ts to call server and lib/storage for persistence.",
    "Small presentational card used on the dashboard to surface a metric (title, value, delta).",
    "Protected dashboard page that displays multiple MetricCard components and fetches authenticated data using useFetch and useAuth for context.",
    "Public landing/home page. Demonstrates useFetch hook for public data fetch and links to dashboard. Uses shared Layout.",
    "404 page displayed for unmatched routes. Uses shared Layout and a CTA back to home.",
    "Route wrapper to secure pages. If user is unauthenticated, redirects to login/home; otherwise renders the child route/component.",
    "Small, accessible button component with variants and size props. Used across forms and pages.",
    "Accessible input component wrapping native input with label support and error states. Used by forms in the app.",
    "Application layout component: header (with login state), main content container, and footer. Consumed by pages to provide consistent structure."
  ],
  "total_files": 25
}