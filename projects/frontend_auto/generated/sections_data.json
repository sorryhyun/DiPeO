{
  "architecture": {
    "overview": "Single-page React 18+ application in TypeScript. Core kernel defines domain contracts, lightweight DI/events/hooks utilities and app config. Foundational layers provide the app entry, global providers (routing, query/cache, auth) and HTTP services. Shared components and hooks are small, focused, and reused across pages. Routes map to feature pages (Home, Auth/Login, Dashboard, NotFound).",
    "patterns": [
      "Domain-first core kernel (contracts, events, utils)",
      "Provider composition (QueryClient, Router, Auth) at the app root",
      "Container/Presentational separation: pages (containers) import small presentational components",
      "Feature folders for domain features (auth, dashboard)",
      "Hook-based abstraction for data fetching and state (useFetch, useAuth, useForm)",
      "Single responsibility services for API interactions (apiClient, authService, userService)",
      "Type-safe contracts via central core/contracts.ts"
    ],
    "data_flow": "UI -> hooks -> services -> apiClient -> HTTP. Responses are cached/managed by QueryProvider where appropriate. AuthProvider holds auth state and exposes it via context + useAuth. Events (core/events.ts) provide cross-cutting pub/sub (e.g., for global notifications). DI utilities in core/di.ts allow swapping implementations for tests or extension points. Pages trigger service calls via hooks which map results back into components.",
    "folder_structure": "src/\n  app/\n    config.ts\n  core/\n    contracts.ts\n    events.ts\n    hooks.ts\n    di.ts\n    utils.ts\n  main.tsx\n  styles/\n    global.css\n  providers/\n    AuthProvider.tsx\n    QueryProvider.tsx\n    RouterProvider.tsx\n  services/\n    apiClient.ts\n    authService.ts\n    userService.ts\n  hooks/\n    useAuth.ts\n    useFetch.ts\n    useForm.ts\n  components/\n    shared/\n      Button.tsx\n      Input.tsx\n    layout/\n      Header.tsx\n      Footer.tsx\n      Container.tsx\n      Layout.tsx\n  routes/\n    AppRouter.tsx\n  features/\n    auth/\n      LoginForm.tsx\n      LoginPage.tsx\n    dashboard/\n      MetricCard.tsx\n      DashboardPage.tsx\n  pages/\n    HomePage.tsx\n    NotFoundPage.tsx",
    "tech_stack": [
      "React 18+ (function components + hooks)",
      "TypeScript (central contracts in core/contracts.ts)",
      "React Router (routing)",
      "React Query (QueryProvider) or equivalent for caching/fetching",
      "Fetch / axios wrapper via services/apiClient.ts",
      "Context API for AuthProvider",
      "Lightweight DI/event utils in core/di.ts and core/events.ts",
      "CSS (global.css) - Tailwind or custom available via base configs"
    ]
  },
  "kernel_specs": {
    "overview": "The core kernel provides the single source of truth for types, configuration, utilities, events, hooks and a minimal dependency injection container. These files are intentionally small, focused and typed so every feature and provider in the app imports contracts and utilities from `src/core/*` and the runtime configuration from `src/app/config.ts`. Events and hooks enable decoupled cross-cutting communication; DI tokens let services be swapped in tests or replaced by alternate implementations; utilities encapsulate common safe operations used everywhere."
  },
  "sections": [
    {
      "id": "app-config",
      "file_path": "src/app/config.ts",
      "description": "Materialized runtime configuration (API base URL, environment flags, feature toggles). Typed against core/contracts AppConfig.",
      "dependencies": [
        "src/core/contracts.ts"
      ],
      "exports": [
        "defaultConfig",
        "getConfig"
      ],
      "priority": 1,
      "purpose": "Materialized runtime configuration (API base URL, environment flags, feature toggles). Typed against core/contracts AppConfig.",
      "content": "This file materializes JSON-like configuration into a typed runtime object. It includes computed flags, a feature toggle map and (optionally) mock data used in development. The config shape is intentionally conservative and serializable.\n\nKey shapes and fields (implement in TypeScript):\n\n- AppConfig type (re-affirm from contracts when needed):\n  - env: 'development' | 'staging' | 'production'\n  - apiBaseUrl: string\n  - wsBaseUrl?: string\n  - features: string[]\n  - analytics?: { enabled: boolean }\n  - development_mode?: { enable_mock_data?: boolean }\n  - defaultPageSize?: number\n\n- Exported runtime object defaultConfig: typed constant with values suitable for a typical dev environment. Example:\n  - env: process.env.NODE_ENV === 'production' ? 'production' : 'development'\n  - apiBaseUrl: derived from process.env.API_BASE_URL || 'http://localhost:4000/api'\n  - wsBaseUrl: process.env.WS_BASE_URL || 'ws://localhost:4000/realtime'\n  - features: [ 'dashboard', 'auth', 'notifications', 'lab-results' ]\n  - analytics: { enabled: false }\n  - development_mode: { enable_mock_data: true }\n  - defaultPageSize: 20\n\n- Computed helpers:\n  - isDevelopment: boolean (env === 'development')\n  - shouldUseMockData: boolean (isDevelopment && development_mode.enable_mock_data)\n  - featureSet: Record<string, boolean> to quickly check toggles\n\n- Mock user data (only exposed when shouldUseMockData is true). Example structure: mockUser: User\n  - Provide one representative user for each role: patient, doctor, nurse. Export `mockUser` that consumers can import if they explicitly opt into dev-mode mocks.\n  - Example patient mock: { id: 'mock-patient-1', role: 'patient', email: 'patient@example.test', fullName: 'Dev Patient', medicalRecordNumber: 'MRN-0001' }\n\n- Exposed functions:\n  - getConfig(): returns a read-only copy of the computed config (Object.freeze)\n  - isFeatureEnabled(featureName: string): boolean\n\nExample usage\n- In services: import { getConfig } from '@/app/config'; const cfg = getConfig(); fetch(cfg.apiBaseUrl + '/users');\n- In components: import { isFeatureEnabled } from '@/app/config'; if (isFeatureEnabled('dashboard')) { /* render */ }\n- In dev-only code, import { mockUser, shouldUseMockData } and guard usage by shouldUseMockData.\n\nIntegration points\n- apiClient reads apiBaseUrl and wsBaseUrl from the config.\n- QueryProvider can read defaultPageSize to set default cache sizes.\n- AuthProvider can seed its initial state with mockUser if shouldUseMockData is true.\n\nNotes\n- Keep all environment sensitive values read at module initialization time to avoid surprises in SSR.\n- Avoid embedding secrets in the repo; read them from environment variables."
    },
    {
      "id": "core-contracts",
      "file_path": "src/core/contracts.ts",
      "description": "TypeScript domain types, API request/response contracts, shared enums and interfaces used across services, components and hooks.",
      "dependencies": [],
      "exports": [
        "AppConfig",
        "User",
        "AuthTokens",
        "ApiResponse<T>",
        "LoginPayload"
      ],
      "priority": 1,
      "purpose": "TypeScript domain types, API request/response contracts, shared enums and interfaces used across services, components and hooks.",
      "content": "This is the canonical file for all domain and cross-cutting types used by the app. Keep it stable and extend carefully.\n\nKey types and interfaces to define (implement in TypeScript):\n\n- Enums\n  - Role: 'patient' | 'doctor' | 'nurse' | 'admin'\n  - Gender: 'male' | 'female' | 'other' | 'unknown'\n  - AppointmentStatus: 'scheduled' | 'completed' | 'cancelled' | 'no_show'\n  - LabResultType: 'blood' | 'imaging' | 'pathology' | 'other'\n\n- User models\n  - interface User { id: string; role: Role; email: string; fullName: string; avatarUrl?: string; metadata?: Record<string, any> }\n  - interface Patient extends User { medicalRecordNumber: string; dob?: string; gender?: Gender }\n  - interface Doctor extends User { specialty?: string; licenseNumber?: string }\n  - interface Nurse extends User { ward?: string }\n\n- Healthcare domain models\n  - interface Appointment { id: string; patientId: string; clinicianId?: string; start: string; end?: string; status: AppointmentStatus; location?: string; notes?: string }\n  - interface MedicalRecord { id: string; patientId: string; createdAt: string; summary?: string; diagnoses?: string[]; entries?: Array<{ id: string; type: string; data: any; createdAt: string }>; }\n  - interface Prescription { id: string; patientId: string; prescriberId: string; drug: string; dosage: string; instructions?: string; issuedAt: string; expiresAt?: string }\n  - interface LabResult { id: string; patientId: string; type: LabResultType; result: string | Record<string, any>; collectedAt: string; reportedAt?: string }\n\n- Auth and API models\n  - interface AuthTokens { accessToken: string; refreshToken?: string; expiresAt?: string }\n  - interface LoginPayload { username: string; password: string; remember?: boolean }\n  - type ApiResult<T> = { ok: true; data: T } | { ok: false; error: ApiError }\n  - interface ApiError { code?: string; status?: number; message: string; details?: any }\n  - interface PaginatedResponse<T> { items: T[]; page: number; pageSize: number; total: number }\n\n- WebSocket / Realtime types\n  - type WebSocketEvent = { type: string; payload?: any; timestamp?: string }\n  - Common event names may include: 'patient:update', 'appointment:created', 'notification:push'\n\n- UI helper types\n  - type LoadingState = 'idle' | 'loading' | 'success' | 'error'\n  - interface FormState<TValues = Record<string, any>> { values: TValues; errors?: Partial<Record<keyof TValues, string>>; touched?: Partial<Record<keyof TValues, boolean>> }\n\n- Service interface contracts (for DI tokens)\n  - interface ApiClient { get<T>(path: string, opts?: RequestInit): Promise<ApiResult<T>>; post<T>(path: string, body?: any, opts?: RequestInit): Promise<ApiResult<T>>; put<T>(path: string, body?: any, opts?: RequestInit): Promise<ApiResult<T>>; delete<T>(path: string, opts?: RequestInit): Promise<ApiResult<T>>; baseUrl: string }\n  - interface StorageService { get<T>(key: string): T | null; set<T>(key: string, value: T): void; remove(key: string): void }\n  - interface AuthService { login(payload: LoginPayload): Promise<ApiResult<{ user: User; tokens: AuthTokens }>>; logout(): Promise<void>; refreshToken(refreshToken: string): Promise<ApiResult<AuthTokens>> }\n\n- Router helper type\n  - interface RouteInfo { path: string; params?: Record<string, string>; query?: URLSearchParams }\n\nPatterns and conventions\n- Keep models small and composable. Prefer IDs rather than nested objects for service boundaries.\n- All API calls should return ApiResult<T> to normalize error handling.\n- Exported interfaces are used by DI tokens in core/di.ts and runtime services.\n\nExample usage\n- In a feature: import { User, ApiResult } from '@/core/contracts';\n- Service signature: const getCurrentUser = async (): Promise<ApiResult<User>> => { /* uses apiClient */ };\n\nIntegration points\n- app/config.ts reads the AppConfig type (exported here) and may include lists of roles/features.\n- core/di.ts uses ApiClient/AuthService/StorageService interfaces to type tokens.\n- core/events.ts and core/hooks.ts reference User, RouteInfo and WebSocketEvent types.\n\nNotes\n- If you need to add more fine-grained domain types (e.g., allergies, immunizations) add them here so all features remain type-safe."
    },
    {
      "id": "core-di",
      "file_path": "src/core/di.ts",
      "description": "Minimal dependency-injection utilities to bind and resolve implementations (useful in tests or swapping implementations).",
      "dependencies": [
        "src/core/contracts.ts",
        "src/core/utils.ts"
      ],
      "exports": [
        "Container",
        "bind",
        "resolve"
      ],
      "priority": 1,
      "purpose": "Minimal dependency-injection utilities to bind and resolve implementations (useful in tests or swapping implementations).",
      "content": "A small, type-safe DI container for application-level services. Designed to be used at bootstrap to register concrete implementations and in tests to swap them. Prefer composition over deep DI; this container is intentionally minimal.\n\nCore concepts and types:\n- Token<T>: a unique symbol typed with the target interface. Use createToken<T>('name') to create tokens.\n- Registration options: { lifecycle: 'singleton' | 'transient' }\n- Container API: register(token, provider, options?), resolve(token)\n\nType declarations and implementations:\n- export function createToken<T = any>(desc?: string): { id: symbol; toString(): string; } & { __type?: T }\n  - This function returns a token object that carries the generic type for compile-time safety.\n\n- class Container {\n    register<T>(token: ReturnType<typeof createToken>, provider: { useValue?: T; useFactory?: (c: Container) => T }, opts?: { lifecycle?: 'singleton' | 'transient' }): void\n    resolve<T>(token: ReturnType<typeof createToken>): T\n    has(token): boolean\n    clear(): void // remove all bindings (useful in tests)\n  }\n\n- Lifetime semantics:\n  - singleton: provider factory is called once and the value cached\n  - transient: factory is called every time resolve is called\n\nPredefined tokens (TOKENS) to export (create tokens using createToken):\n- ApiClientToken: Token<ApiClient>\n- AuthServiceToken: Token<AuthService>\n- StorageServiceToken: Token<StorageService>\n- WebSocketServiceToken: Token<{ connect(): void; disconnect(): void }>\n\nConvenience module-level container and helpers\n- Export a default global container instance: export const container = new Container()\n- Export top-level helpers:\n  - bind(token, provider, opts) => container.register(...)\n  - resolve(token) => container.resolve(...)\n\nExample registration (bootstrap):\n- import { container, createToken, bind, TOKENS } from '@/core/di'\n- container.register(TOKENS.ApiClientToken, { useFactory: () => createApiClient(cfg.apiBaseUrl) }, { lifecycle: 'singleton' })\n- container.register(TOKENS.StorageServiceToken, { useValue: new LocalStorageService() })\n\nExample usage in a service/file:\n- const apiClient = resolve(TOKENS.ApiClientToken) as ApiClient\n- type-safety: const s = resolve<typeof TOKENS.AuthServiceToken>(TOKENS.AuthServiceToken) // resolve returns typed value when token is typed\n\nIntegration points\n- App bootstrap (main.tsx) registers implementations for tokens.\n- Services may import tokens and call resolve(TOKENS.*) instead of importing concretions. This makes tests easier: test harness can register mocks into a fresh container and call components/services with those values.\n\nNotes and best practices\n- Keep DI usage shallow. Prefer passing dependencies via constructor/props for local composition and use container for truly cross-cutting global services (http client, auth, websocket).\n- Use the container mainly at the app root and tests. Avoid global side-effectful registration in random modules to keep tests predictable."
    },
    {
      "id": "core-events",
      "file_path": "src/core/events.ts",
      "description": "Lightweight event bus/pub-sub used for cross-cutting events (notifications, global error events), built on top of core/utils if needed.",
      "dependencies": [
        "src/core/utils.ts"
      ],
      "exports": [
        "EventBus",
        "subscribe",
        "publish",
        "unsubscribe"
      ],
      "priority": 1,
      "purpose": "Lightweight event bus/pub-sub used for cross-cutting events (notifications, global error events), built on top of core/utils if needed.",
      "content": "Event bus design and behavior:\n\n- Provide a small, well-typed pub/sub implementation.\n- Support synchronous handlers and asynchronous handlers (handlers can return void or Promise<void>).\n- Support once() subscriptions and the ability to unsubscribe by token/handler.\n- Safe: exceptions thrown in one handler should not prevent other handlers from running; collect exceptions and optionally rethrow or log.\n\nType definitions to include:\n- interface EventMap {\n    'notification': { message: string; level?: 'info' | 'warning' | 'error' };\n    'auth:login': { userId: string; user?: import('@/core/contracts').User };\n    'auth:logout': { userId?: string };\n    'api:error': { error: import('@/core/contracts').ApiError; url?: string };\n    'route:change': { from?: string; to: string };\n    // Additional keys allowed via index signature: [key: string]: any\n  }\n\n- type EventHandler<T> = (payload: T) => void | Promise<void>\n\nEventBus class contract:\n- class EventBus<EM extends Record<string, any> = EventMap> {\n    on<K extends keyof EM>(event: K, handler: EventHandler<EM[K]>): () => void // returns unsubscribe\n    once<K extends keyof EM>(event: K, handler: EventHandler<EM[K]>): () => void\n    off<K extends keyof EM>(event: K, handler?: EventHandler<EM[K]>): void\n    emit<K extends keyof EM>(event: K, payload: EM[K]): Promise<void> // returns a promise that resolves when all handlers complete; collects errors and logs\n  }\n\nExports and runtime singleton:\n- export const eventBus = new EventBus<EventMap>()\n- export helpers: subscribe = eventBus.on.bind(eventBus) ; unsubscribe = eventBus.off.bind(eventBus); publish = eventBus.emit.bind(eventBus)\n\nBehavioral details:\n- When .emit is called, call handlers in registration order.\n- If a handler throws or rejects, catch and forward to a global error handler: by default debugLog('EventBus', error), and then continue executing other handlers.\n- Return a Promise that resolves after all handlers have settled. If any handlers threw, the Promise resolves but the errors are accessible by logging. Optionally, provide an option to rethrow aggregated error (not defaulted to true).\n\nExamples\n- import { publish, subscribe } from '@/core/events'\n  const unsub = subscribe('notification', async (payload) => { showToast(payload.message) })\n  await publish('auth:login', { userId: 'u-1' })\n  unsub()\n\nIntegration points\n- App-level components (e.g., global Notifications component) subscribe to 'notification' events.\n- AuthProvider emits 'auth:login' and 'auth:logout' events using publish.\n- apiClient publishes 'api:error' when a network error occurs.\n\nNotes\n- Keep this module dependency-free except for core/utils.debugLog to avoid cycles. Use lightweight types only and keep runtime behavior deterministic."
    },
    {
      "id": "core-hooks-registry",
      "file_path": "src/core/hooks.ts",
      "description": "Hook registry and extension points for plugins/extensions; small helpers to register lifecycle hooks and access global hook slots.",
      "dependencies": [
        "src/core/events.ts",
        "src/core/contracts.ts"
      ],
      "exports": [
        "registerHook",
        "invokeHook",
        "useRegisteredHook"
      ],
      "priority": 1,
      "purpose": "Hook registry and extension points for plugins/extensions; small helpers to register lifecycle hooks and access global hook slots.",
      "content": "A thin extension/hook system to allow features and providers to register callbacks for key lifecycle events. Designed for application-level extension points rather than component-level hooks.\n\nHook points to support (well-typed):\n- 'beforeApiRequest' : invoked before an API request is sent. Payload: { path: string; init?: RequestInit; context?: any }.\n- 'afterApiResponse' : invoked after a response is received. Payload: { path: string; response?: Response; result?: import('@/core/contracts').ApiResult<any>; context?: any }.\n- 'onLogin' : invoked after a successful login. Payload: { user: import('@/core/contracts').User; tokens?: import('@/core/contracts').AuthTokens }.\n- 'onLogout' : invoked when the user logs out. Payload: { userId?: string }.\n- 'onRouteChange' : invoked when the route changes. Payload: import('@/core/contracts').RouteInfo.\n\nType declarations and registry API:\n- type HookPoint = 'beforeApiRequest' | 'afterApiResponse' | 'onLogin' | 'onLogout' | 'onRouteChange'\n\n- interface HookContext<P = any> { payload: P; meta?: Record<string, any> }\n\n- class HookRegistry {\n    register<P = any>(point: HookPoint, handler: (ctx: HookContext<P>) => void | Promise<void>): () => void // returns an unregister function\n    invoke<P = any>(point: HookPoint, payload: P, meta?: Record<string, any>): Promise<void>\n    list(point?: HookPoint): Array<Function>\n  }\n\n- Provide a module-level singleton registry: export const hooks = new HookRegistry()\n- Provide convenience functions: registerHook(point, handler) => hooks.register(...); invokeHook(point, payload, meta) => hooks.invoke(...)\n- Provide a small React helper useRegisteredHook(point, handler, deps?) which registers the handler on mount and unregisters on unmount. (Import React in the file to type this helper.)\n\nExecution semantics:\n- Handlers run in registration order. If an async handler rejects, log via debugLog and continue executing other handlers.\n- Handlers may mutate ctx.payload but should avoid doing so in typical usage. If you need immutable payloads, clone before invoking.\n- Hooks are global and live for the app lifetime; use unregister return to remove.\n\nExamples\n- Logging before requests:\n  registerHook('beforeApiRequest', ({ payload }) => { console.debug('Outgoing request', payload.path) })\n\n- Post-process all API responses:\n  registerHook('afterApiResponse', async ({ payload }) => { if (!payload.result?.ok) publish('api:error', { error: payload.result?.error, url: payload.path }) })\n\n- Use inside a React provider to register route change hooks:\n  useRegisteredHook('onRouteChange', ({ payload }) => { analytics.page(payload.to) })\n\nIntegration points\n- apiClient should call invokeHook('beforeApiRequest', { path, init }) before issuing the network call and invokeHook('afterApiResponse', { path, response, result }) afterwards.\n- AuthProvider calls invokeHook('onLogin', { user, tokens }) and invokeHook('onLogout', { userId }).\n- RouterProvider calls invokeHook('onRouteChange', routeInfo) when location changes.\n\nNotes\n- Keep hooks minimal and fast. They are intended for small cross-cutting responsibilities: logging, metrics, minor side-effects. Avoid heavy blocking work in hooks that can delay user flows."
    },
    {
      "id": "core-utils",
      "file_path": "src/core/utils.ts",
      "description": "Common utilities used across the app (safeParseJson, sleep, formatDate, small helpers used by services/hooks/events).",
      "dependencies": [],
      "exports": [
        "safeParseJson",
        "sleep",
        "formatDate"
      ],
      "priority": 1,
      "purpose": "Common utilities used across the app (safeParseJson, sleep, formatDate, small helpers used by services/hooks/events).",
      "content": "A small collection of deterministic, side-effect-free helpers. Keep these functions lightweight and well-typed.\n\nFunctions and signatures to implement (TypeScript):\n\n- safeParseJson<T = any>(input: string | null | undefined, fallback?: T): T | undefined\n  - Attempt JSON.parse; on error return fallback or undefined. Should be generic to allow typing returned value.\n  - Example: const obj = safeParseJson<MyType>(raw, {} as MyType)\n\n- sleep(ms: number): Promise<void>\n  - Promise-based delay used in tests or simulated latencies\n\n- formatDate(isoString: string | Date, opts?: { locale?: string; dateOnly?: boolean; timeOnly?: boolean; }): string\n  - Return a short human-friendly date/time using Intl.DateTimeFormat. Fall back to toISOString on invalid input.\n\n- isoNow(): string\n  - Returns new Date().toISOString() (single source of truth for timestamps)\n\n- debugLog(namespace: string, ...args: any[]): void\n  - Conditional logging only when NODE_ENV !== 'production'. Prefix log lines with namespace and timestamp.\n\n- assertNever(x: never, message?: string): never\n  - Helper for exhaustive checks in switch statements.\n\nExample usage\n- const parsed = safeParseJson<User>(localStorage.getItem('user'))\n- await sleep(250)\n- const s = formatDate(user.dob, { dateOnly: true })\n\nIntegration points\n- core/events.ts may use isoNow for event timestamps and debugLog when handlers throw.\n- core/di.ts and apiClient use debugLog for diagnostics in non-production.\n\nQuality notes\n- All helpers should be purely functional and have deterministic outputs for same inputs (except debugLog which interacts with console)."
    },
    {
      "id": "api-client",
      "file_path": "src/services/apiClient.ts",
      "description": "HTTP client wrapper (fetch or axios) with base URL, error handling, JSON parsing and optional auth token injection. Central place for API calls.",
      "dependencies": [
        "src/app/config.ts",
        "src/core/contracts.ts",
        "src/core/utils.ts"
      ],
      "exports": [
        "apiClient",
        "httpGet",
        "httpPost",
        "httpPut",
        "httpDelete"
      ],
      "priority": 2
    },
    {
      "id": "app-root",
      "file_path": "src/App.tsx",
      "description": "Root app component that composes global providers (Query, Auth, Router) and renders the router. Keeps global shell minimal.",
      "dependencies": [
        "src/providers/QueryProvider.tsx",
        "src/providers/AuthProvider.tsx",
        "src/providers/RouterProvider.tsx",
        "src/routes/AppRouter.tsx",
        "src/styles/global.css"
      ],
      "exports": [
        "App"
      ],
      "priority": 2
    },
    {
      "id": "auth-provider",
      "file_path": "src/providers/AuthProvider.tsx",
      "description": "Authentication context provider: stores authenticated user and tokens, exposes login/logout helpers. Uses authService to perform auth operations.",
      "dependencies": [
        "src/core/contracts.ts",
        "src/services/authService.ts",
        "src/core/hooks.ts"
      ],
      "exports": [
        "AuthProvider",
        "AuthContext",
        "AuthProviderProps"
      ],
      "priority": 2
    },
    {
      "id": "auth-service",
      "file_path": "src/services/authService.ts",
      "description": "Service exposing authentication API functions (login, logout, refreshToken). Uses apiClient and returns typed results per contracts.",
      "dependencies": [
        "src/services/apiClient.ts",
        "src/core/contracts.ts"
      ],
      "exports": [
        "login",
        "logout",
        "refreshToken"
      ],
      "priority": 2
    },
    {
      "id": "global-styles",
      "file_path": "src/styles/global.css",
      "description": "Global CSS entry (base styles, resets, utility classes). Imported by main and App for app-wide styles.",
      "dependencies": [],
      "exports": [
        "global styles (side-effect import)"
      ],
      "priority": 2
    },
    {
      "id": "main-entry",
      "file_path": "src/main.tsx",
      "description": "Application entry. Creates React root and mounts App. Imports global styles and performs minimal bootstrap.",
      "dependencies": [
        "src/App.tsx",
        "src/styles/global.css"
      ],
      "exports": [
        "default"
      ],
      "priority": 2
    },
    {
      "id": "query-provider",
      "file_path": "src/providers/QueryProvider.tsx",
      "description": "Provides React Query (or similar) client to the app. Reads app config where necessary to configure cache defaults.",
      "dependencies": [
        "src/app/config.ts"
      ],
      "exports": [
        "QueryProvider",
        "useQueryClient"
      ],
      "priority": 2
    },
    {
      "id": "router-provider",
      "file_path": "src/providers/RouterProvider.tsx",
      "description": "Thin wrapper that provides router context (BrowserRouter) and any router-level configuration. Used to centralize router-related logic.",
      "dependencies": [],
      "exports": [
        "RouterProvider"
      ],
      "priority": 2
    },
    {
      "id": "use-auth-hook",
      "file_path": "src/hooks/useAuth.ts",
      "description": "Convenience hook that exposes auth context values and actions (login/logout/isAuthenticated). Wraps AuthProvider context and core hooks if needed.",
      "dependencies": [
        "src/providers/AuthProvider.tsx",
        "src/core/hooks.ts"
      ],
      "exports": [
        "useAuth"
      ],
      "priority": 2
    },
    {
      "id": "use-fetch-hook",
      "file_path": "src/hooks/useFetch.ts",
      "description": "Lightweight data fetching hook built on top of apiClient (and optionally React Query). Provides loading, error and data shape for small components.",
      "dependencies": [
        "src/services/apiClient.ts",
        "src/core/utils.ts"
      ],
      "exports": [
        "useFetch"
      ],
      "priority": 2
    },
    {
      "id": "use-form-hook",
      "file_path": "src/hooks/useForm.ts",
      "description": "Small form state helper (values, onChange, validation hooks) used by simple forms (login). Not a replacement for full form libraries but useful for small forms.",
      "dependencies": [
        "src/core/utils.ts"
      ],
      "exports": [
        "useForm"
      ],
      "priority": 2
    },
    {
      "id": "user-service",
      "file_path": "src/services/userService.ts",
      "description": "Service for user-related endpoints (get current user, fetch metrics). Uses apiClient and core contracts.",
      "dependencies": [
        "src/services/apiClient.ts",
        "src/core/contracts.ts"
      ],
      "exports": [
        "getCurrentUser",
        "getDashboardMetrics"
      ],
      "priority": 2
    },
    {
      "id": "app-router",
      "file_path": "src/routes/AppRouter.tsx",
      "description": "Route definitions that map URL paths to pages/features (Home, Login, Dashboard, 404). Uses react-router components and lazy loading where applicable.",
      "dependencies": [
        "src/pages/HomePage.tsx",
        "src/features/auth/LoginPage.tsx",
        "src/features/dashboard/DashboardPage.tsx",
        "src/pages/NotFoundPage.tsx"
      ],
      "exports": [
        "AppRouter"
      ],
      "priority": 3
    },
    {
      "id": "auth-login-form",
      "file_path": "src/features/auth/LoginForm.tsx",
      "description": "Login form component that uses useForm for state, Input and Button components, and calls authService.login. Calls useAuth to persist tokens.",
      "dependencies": [
        "src/components/shared/Input.tsx",
        "src/components/shared/Button.tsx",
        "src/hooks/useForm.ts",
        "src/services/authService.ts",
        "src/hooks/useAuth.ts"
      ],
      "exports": [
        "LoginForm"
      ],
      "priority": 3
    },
    {
      "id": "auth-login-page",
      "file_path": "src/features/auth/LoginPage.tsx",
      "description": "Login page (container) which renders LoginForm inside the app Layout. Handles redirect after login.",
      "dependencies": [
        "src/components/layout/Layout.tsx",
        "src/features/auth/LoginForm.tsx"
      ],
      "exports": [
        "LoginPage"
      ],
      "priority": 3
    },
    {
      "id": "dashboard-metric-card",
      "file_path": "src/features/dashboard/MetricCard.tsx",
      "description": "Small presentational card that displays a single metric (label, value, delta). Used by DashboardPage.",
      "dependencies": [
        "src/core/contracts.ts",
        "src/core/utils.ts"
      ],
      "exports": [
        "MetricCard"
      ],
      "priority": 3
    },
    {
      "id": "dashboard-page",
      "file_path": "src/features/dashboard/DashboardPage.tsx",
      "description": "Dashboard page that fetches metrics via userService/useFetch and renders MetricCard components.",
      "dependencies": [
        "src/components/layout/Layout.tsx",
        "src/features/dashboard/MetricCard.tsx",
        "src/hooks/useFetch.ts",
        "src/services/userService.ts"
      ],
      "exports": [
        "DashboardPage"
      ],
      "priority": 3
    },
    {
      "id": "home-page",
      "file_path": "src/pages/HomePage.tsx",
      "description": "Public landing page demonstrating the application shell and links to Login/Dashboard. Uses Layout.",
      "dependencies": [
        "src/components/layout/Layout.tsx"
      ],
      "exports": [
        "HomePage"
      ],
      "priority": 3
    },
    {
      "id": "layout-container",
      "file_path": "src/components/layout/Container.tsx",
      "description": "Small presentational wrapper to constrain content width and provide consistent padding.",
      "dependencies": [],
      "exports": [
        "Container"
      ],
      "priority": 3
    },
    {
      "id": "layout-footer",
      "file_path": "src/components/layout/Footer.tsx",
      "description": "Footer component containing copyright and small links.",
      "dependencies": [],
      "exports": [
        "Footer"
      ],
      "priority": 3
    },
    {
      "id": "layout-header",
      "file_path": "src/components/layout/Header.tsx",
      "description": "Application header: brand, navigation links and auth controls (login/logout). Consumes useAuth to display stateful controls.",
      "dependencies": [
        "src/hooks/useAuth.ts",
        "src/components/shared/Button.tsx"
      ],
      "exports": [
        "Header"
      ],
      "priority": 3
    },
    {
      "id": "layout-root",
      "file_path": "src/components/layout/Layout.tsx",
      "description": "Top-level layout composed of Header, Container and Footer. Used by pages to provide consistent shell.",
      "dependencies": [
        "src/components/layout/Header.tsx",
        "src/components/layout/Footer.tsx",
        "src/components/layout/Container.tsx"
      ],
      "exports": [
        "Layout"
      ],
      "priority": 3
    },
    {
      "id": "not-found-page",
      "file_path": "src/pages/NotFoundPage.tsx",
      "description": "Simple 404 page rendered for unmatched routes. Uses Layout.",
      "dependencies": [
        "src/components/layout/Layout.tsx"
      ],
      "exports": [
        "NotFoundPage"
      ],
      "priority": 3
    },
    {
      "id": "shared-button",
      "file_path": "src/components/shared/Button.tsx",
      "description": "Accessible button component used throughout the app. Provides variants and forwards native button props.",
      "dependencies": [
        "src/core/contracts.ts"
      ],
      "exports": [
        "Button"
      ],
      "priority": 3
    },
    {
      "id": "shared-input",
      "file_path": "src/components/shared/Input.tsx",
      "description": "Reusable input component with label, error display, and value binding. Used by forms across features.",
      "dependencies": [
        "src/core/contracts.ts",
        "src/hooks/useForm.ts"
      ],
      "exports": [
        "Input"
      ],
      "priority": 3
    }
  ],
  "file_paths": [
    "src/app/config.ts",
    "src/core/contracts.ts",
    "src/core/di.ts",
    "src/core/events.ts",
    "src/core/hooks.ts",
    "src/core/utils.ts",
    "src/services/apiClient.ts",
    "src/App.tsx",
    "src/providers/AuthProvider.tsx",
    "src/services/authService.ts",
    "src/styles/global.css",
    "src/main.tsx",
    "src/providers/QueryProvider.tsx",
    "src/providers/RouterProvider.tsx",
    "src/hooks/useAuth.ts",
    "src/hooks/useFetch.ts",
    "src/hooks/useForm.ts",
    "src/services/userService.ts",
    "src/routes/AppRouter.tsx",
    "src/features/auth/LoginForm.tsx",
    "src/features/auth/LoginPage.tsx",
    "src/features/dashboard/MetricCard.tsx",
    "src/features/dashboard/DashboardPage.tsx",
    "src/pages/HomePage.tsx",
    "src/components/layout/Container.tsx",
    "src/components/layout/Footer.tsx",
    "src/components/layout/Header.tsx",
    "src/components/layout/Layout.tsx",
    "src/pages/NotFoundPage.tsx",
    "src/components/shared/Button.tsx",
    "src/components/shared/Input.tsx"
  ],
  "descriptions": [
    "Materialized runtime configuration (API base URL, environment flags, feature toggles). Typed against core/contracts AppConfig.",
    "TypeScript domain types, API request/response contracts, shared enums and interfaces used across services, components and hooks.",
    "Minimal dependency-injection utilities to bind and resolve implementations (useful in tests or swapping implementations).",
    "Lightweight event bus/pub-sub used for cross-cutting events (notifications, global error events), built on top of core/utils if needed.",
    "Hook registry and extension points for plugins/extensions; small helpers to register lifecycle hooks and access global hook slots.",
    "Common utilities used across the app (safeParseJson, sleep, formatDate, small helpers used by services/hooks/events).",
    "HTTP client wrapper (fetch or axios) with base URL, error handling, JSON parsing and optional auth token injection. Central place for API calls.",
    "Root app component that composes global providers (Query, Auth, Router) and renders the router. Keeps global shell minimal.",
    "Authentication context provider: stores authenticated user and tokens, exposes login/logout helpers. Uses authService to perform auth operations.",
    "Service exposing authentication API functions (login, logout, refreshToken). Uses apiClient and returns typed results per contracts.",
    "Global CSS entry (base styles, resets, utility classes). Imported by main and App for app-wide styles.",
    "Application entry. Creates React root and mounts App. Imports global styles and performs minimal bootstrap.",
    "Provides React Query (or similar) client to the app. Reads app config where necessary to configure cache defaults.",
    "Thin wrapper that provides router context (BrowserRouter) and any router-level configuration. Used to centralize router-related logic.",
    "Convenience hook that exposes auth context values and actions (login/logout/isAuthenticated). Wraps AuthProvider context and core hooks if needed.",
    "Lightweight data fetching hook built on top of apiClient (and optionally React Query). Provides loading, error and data shape for small components.",
    "Small form state helper (values, onChange, validation hooks) used by simple forms (login). Not a replacement for full form libraries but useful for small forms.",
    "Service for user-related endpoints (get current user, fetch metrics). Uses apiClient and core contracts.",
    "Route definitions that map URL paths to pages/features (Home, Login, Dashboard, 404). Uses react-router components and lazy loading where applicable.",
    "Login form component that uses useForm for state, Input and Button components, and calls authService.login. Calls useAuth to persist tokens.",
    "Login page (container) which renders LoginForm inside the app Layout. Handles redirect after login.",
    "Small presentational card that displays a single metric (label, value, delta). Used by DashboardPage.",
    "Dashboard page that fetches metrics via userService/useFetch and renders MetricCard components.",
    "Public landing page demonstrating the application shell and links to Login/Dashboard. Uses Layout.",
    "Small presentational wrapper to constrain content width and provide consistent padding.",
    "Footer component containing copyright and small links.",
    "Application header: brand, navigation links and auth controls (login/logout). Consumes useAuth to display stateful controls.",
    "Top-level layout composed of Header, Container and Footer. Used by pages to provide consistent shell.",
    "Simple 404 page rendered for unmatched routes. Uses Layout.",
    "Accessible button component used throughout the app. Provides variants and forwards native button props.",
    "Reusable input component with label, error display, and value binding. Used by forms across features."
  ],
  "total_files": 31
}