{
  "architecture": {
    "overview": "This is a modular React 18 + TypeScript single-page application. Core domain contracts, configuration and small kernel utilities live under src/core and src/app. Foundational providers and services (auth, api, theme) provide runtime capabilities and are composed by a RootProvider. Reusable UI primitives live under src/shared, domain features under src/features, pages under src/pages, and routing is handled by src/routes. The app is bootstrapped at src/main.tsx which mounts App wrapped with the RootProvider.",
    "patterns": [
      "Domain-first: core/contracts define types and API contracts used across app",
      "Provider composition: RootProvider composes AuthProvider, ApiProvider, ThemeProvider",
      "Separation of concerns: services (data), providers (context), hooks (logic), components (UI), pages (routes)",
      "Presentational/Container split: shared presentational components are pure; pages and feature containers orchestrate data/services",
      "Dependency Injection (lightweight): src/core/di.ts provides simple container for override in tests/features",
      "Event Bus: src/core/events.ts for decoupled cross-cutting events (e.g. auth changes, toast events)"
    ],
    "data_flow": "UI components call hooks (src/hooks/*) which call services (src/services/*) that use apiClient (src/services/apiClient.ts) to call remote APIs. Services return typed results based on src/core/contracts.ts. Providers (AuthProvider, ApiProvider) supply context/state to hooks and components. App-level config comes from src/app/config.ts. Caching, background refresh and request deduplication should be implemented in hooks/service layer (useFetch). Events (src/core/events.ts) broadcast cross-cutting updates (e.g., auth changes), and DI (src/core/di.ts) allows swapping implementations in tests or alternate environments.",
    "folder_structure": "src/\n  app/\n    config.ts\n  core/\n    contracts.ts\n    events.ts\n    hooks.ts\n    di.ts\n    utils.ts\n  providers/\n    RootProvider.tsx\n    AuthProvider.tsx\n    ApiProvider.tsx\n    ThemeProvider.tsx\n  contexts/\n    AuthContext.tsx\n  services/\n    apiClient.ts\n    authService.ts\n    userService.ts\n  hooks/\n    useAuth.ts\n    useFetch.ts\n    useIsMounted.ts\n  shared/\n    components/\n      Button.tsx\n      Input.tsx\n      Header.tsx\n      Footer.tsx\n      Layout.tsx\n      LoadingSpinner.tsx\n      ErrorBoundary.tsx\n  features/\n    dashboard/\n      MetricCard.tsx\n    users/\n      UserList.tsx\n  pages/\n    HomePage.tsx\n    DashboardPage.tsx\n    UsersPage.tsx\n    NotFoundPage.tsx\n  routes/\n    AppRoutes.tsx\n  App.tsx\n  main.tsx\n  styles/\n    global.css",
    "tech_stack": [
      "React 18+ (functional components, hooks)",
      "TypeScript (strict) for typesafe contracts",
      "Vite for bundling (pre-provided)",
      "React Router v6 for routing",
      "Context API + lightweight DI for providers",
      "Fetch-based apiClient with typed responses",
      "CSS (global.css) or Tailwind (config provided externally) \u2014 choose based on project needs"
    ]
  },
  "kernel_specs": {
    "overview": "The Core Kernel provides single-source-of-truth TypeScript contracts, runtime config, a lightweight event bus, extensible hook registry, DI tokens/container, and common utilities. These foundational files live in src/core and src/app and are referenced across providers, services, hooks and components. They are intentionally small, strictly typed and framework-agnostic so feature code can depend on stable contracts and swap implementations in tests or alternative environments."
  },
  "sections": [
    {
      "id": "app-config",
      "file_path": "src/app/config.ts",
      "description": "Materialized runtime configuration (APP_CONFIG) such as apiBaseUrl, feature flags and environment info.",
      "dependencies": [],
      "exports": [
        "APP_CONFIG"
      ],
      "priority": 1,
      "purpose": "Materialized runtime configuration exported as a typed APP_CONFIG object. Provides computed flags, feature toggles, environment info and optional mock data when development mock mode is enabled.",
      "content": "This file produces a fully typed runtime configuration object named APP_CONFIG. It's safe to import anywhere in the app. It should be small, serializable and contain computed convenience flags.\n\nDefine types and structure:\n- export type Environment = 'development' | 'staging' | 'production';\n- export interface FeatureFlags { users?: boolean; appointments?: boolean; telehealth?: boolean; billing?: boolean; labs?: boolean; [key: string]: boolean | undefined; }\n- export interface DevelopmentModeConfig { enableMockData?: boolean; mockSeed?: number | string; enableVerboseLogging?: boolean; }\n- export interface AppConfig { appName: string; environment: Environment; apiBaseUrl: string; websocketUrl?: string; version?: string; buildNumber?: string | number; defaultPerPage: number; features: FeatureFlags; development_mode?: DevelopmentModeConfig; storageKeyPrefix?: string; }\n\nMaterialization and computed flags (to include in APP_CONFIG at runtime):\n- isDevelopment: boolean (environment === 'development')\n- isStaging: boolean\n- isProduction: boolean\n- shouldUseMockData: boolean (isDevelopment && development_mode?.enableMockData === true) or based on localStorage override - explain pattern below\n\nProvide a concrete default configuration object and runtime overrides:\n- APP_CONFIG should be exported as a const with type AppConfig & { isDevelopment:boolean; isStaging:boolean; isProduction:boolean; shouldUseMockData:boolean; hasFeature: (name:string)=>boolean }.\n- Allow override via window.__APP_CONFIG__ if present to support runtime injection by server or test harnesses.\n\nMock data provisioning (when development_mode.enableMockData === true):\n- Provide small in-file mock data structures used by services when the mock flag is active. This file includes only static mock fixtures such as a few users (Patient/Doctor/Nurse) and sample appointments/lab results.\n- Exported mock data should be readonly and minimal; e.g. readonly MOCK_USERS: ReadonlyArray<User> and MOCK_APPOINTMENTS.\n- The mock fixtures are guarded behind APP_CONFIG.shouldUseMockData so services must check APP_CONFIG.shouldUseMockData before using them. This keeps services deterministic.\n\nExample default APP_CONFIG (concrete recommended values):\n- appName: 'HealthPortal'\n- environment: window.__APP_CONFIG__?.environment ?? (import.meta.env && import.meta.env.MODE ? (import.meta.env.MODE as Environment) : 'development')\n- apiBaseUrl: window.__APP_CONFIG__?.apiBaseUrl ?? import.meta.env.VITE_API_BASE_URL ?? 'https://api.health-portal.local'\n- websocketUrl: window.__APP_CONFIG__?.websocketUrl ?? (new URL('/ws', apiBaseUrl)).toString()\n- version: process.env.APP_VERSION ?? '0.0.1'\n- defaultPerPage: 20\n- features: { users: true, appointments: true, telehealth: false, billing: false, labs: true }\n- development_mode: { enableMockData: true, enableVerboseLogging: true }\n- storageKeyPrefix: 'hp:'\n\nExample mock fixtures (only present if enableMockData true):\n- MOCK_USERS: array of 3 users: an admin/doctor/patient entry with realistic fields (id, name, email, role, createdAt)\n- MOCK_APPOINTMENTS: 2 appointments referencing MOCK_USERS ids\n- MOCK_LAB_RESULTS: 1 lab result for the patient\n\nRecommended usage examples:\n- import { APP_CONFIG, MOCK_USERS } from '@/app/config';\n- if (APP_CONFIG.shouldUseMockData) { userService.useMock(MOCK_USERS); }\n- console.log(APP_CONFIG.hasFeature('telehealth'))\n\nPatterns and conventions:\n- Keep config serializable and avoid functions except small helpers like hasFeature.\n- Guard production-only secrets out of this file; this file should consume env vars injected by the bundler or runtime.\n- When reading APP_CONFIG in services/providers, prefer properties and avoid reading global window.__APP_CONFIG__ directly elsewhere.\n\nIntegration points:\n- services/apiClient.ts will read APP_CONFIG.apiBaseUrl and APP_CONFIG.defaultPerPage\n- providers/ApiProvider may use APP_CONFIG.websocketUrl to configure real-time connectors\n- tests and storybooks can override window.__APP_CONFIG__ before importing APP_CONFIG to inject test values"
    },
    {
      "id": "contexts-auth-context",
      "file_path": "src/contexts/AuthContext.tsx",
      "description": "React Context for authentication state (current user, tokens, helpers). Consumed by useAuth and AuthProvider.",
      "dependencies": [
        "src/core/contracts.ts"
      ],
      "exports": [
        "AuthContext",
        "AuthContextProviderProps"
      ],
      "priority": 1
    },
    {
      "id": "core-contracts",
      "file_path": "src/core/contracts.ts",
      "description": "Application domain types and API contracts (User, AuthTokens, ApiResponse, paging types) used across services, hooks and components.",
      "dependencies": [],
      "exports": [
        "User",
        "AuthTokens",
        "ApiResponse<T>",
        "Pagination"
      ],
      "priority": 1,
      "purpose": "Domain types and API contracts for the whole application: users/roles, healthcare models (appointments, medical records, prescriptions, lab results), API response shapes, websocket events and small UI state helpers. This is the canonical type surface used by services and components.",
      "content": "This file defines the entire type-level contract used across services, components and providers. Key conventions: - Use discriminated unions where appropriate (e.g., Role, User.kind) - Keep DTOs lean and map server fields to client-friendly names - Mark optional fields explicitly and prefer Readonly where values should not be mutated by consumer code - Provide small helper utility type aliases like Id = string | number\n\nTypes and interfaces to provide (full list and rationale):\n\n1) Core primitives and aliases\n- type Id = string | number\n- type ISODateString = string // RFC3339/ISO8601 date/time string\n\n2) Roles and user types\n- export type Role = 'admin' | 'doctor' | 'nurse' | 'patient' | 'receptionist' | 'billing';\n- export interface UserBase { id: Id; firstName: string; lastName: string; email: string; createdAt: ISODateString; updatedAt?: ISODateString; role: Role; avatarUrl?: string; }\n- export interface Patient extends UserBase { role: 'patient'; dateOfBirth?: ISODateString; patientNumber?: string; primaryDoctorId?: Id; }\n- export interface Doctor extends UserBase { role: 'doctor'; specialty?: string[]; licenseNumber?: string; }\n- export interface Nurse extends UserBase { role: 'nurse'; certifications?: string[]; }\n- export type User = Patient | Doctor | Nurse | (UserBase & { role: Exclude<Role, 'patient' | 'doctor' | 'nurse'> });\n\nRationale: keep Patient/Doctor/Nurse expanded so UI can narrow by role.\n\n3) Auth related\n- export interface AuthTokens { accessToken: string; refreshToken?: string; expiresAt?: number; } // expiresAt = epoch ms optional\n\n4) API response shapes\n- export interface ApiError { code: string; message: string; status?: number; details?: Record<string, unknown>; }\n- export interface ApiResult<T> { success: boolean; data?: T; error?: ApiError; meta?: any; }\n\n5) Pagination helpers\n- export interface Pagination { page: number; perPage: number; total?: number; totalPages?: number; }\n- export interface PaginatedResponse<T> { items: T[]; pagination: Pagination; }\n\n6) Healthcare domain models\n- export interface Appointment { id: Id; patientId: Id; doctorId: Id; startAt: ISODateString; endAt?: ISODateString; status: 'scheduled' | 'checked_in' | 'in_progress' | 'completed' | 'cancelled'; reason?: string; location?: string; createdAt: ISODateString; updatedAt?: ISODateString; }\n\n- export interface MedicalRecord { id: Id; patientId: Id; createdById: Id; createdAt: ISODateString; type: 'visit_note' | 'allergy' | 'problem' | 'immunization' | 'other'; summary?: string; details?: string; attachments?: Array<{ url: string; filename?: string }>; }\n\n- export interface Prescription { id: Id; patientId: Id; prescribedById: Id; medication: string; dosage: string; frequency?: string; startDate?: ISODateString; endDate?: ISODateString; instructions?: string; refillsRemaining?: number; createdAt: ISODateString; }\n\n- export interface LabResult { id: Id; patientId: Id; orderedById: Id; testName: string; resultValue?: string; unit?: string; normalRange?: string; takenAt?: ISODateString; reportedAt?: ISODateString; attachments?: Array<{ url: string; filename?: string }>; }\n\nRationale: keep domain models normalized and small; services may map server DTOs to these shapes.\n\n7) WebSocket / realtime events (if websockets enabled)\n- export type WebsocketEventType = 'appointment.updated' | 'patient.updated' | 'labresult.available' | 'prescription.issued' | 'notification';\n- export interface WebsocketEvent<T = any> { type: WebsocketEventType; payload: T; receivedAt: ISODateString; correlationId?: string; }\n- export interface WebsocketEventMap { 'appointment.updated': Appointment; 'patient.updated': Patient; 'labresult.available': LabResult; 'prescription.issued': Prescription; 'notification': { title: string; body: string; level?: 'info' | 'warning' | 'error' }; }\n\n8) UI helpers\n- export type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n- export interface FormState<T = Record<string, any>> { values: T; errors?: Partial<Record<keyof T, string>>; touched?: Partial<Record<keyof T, boolean>>; isSubmitting?: boolean; }\n\n9) Utility types\n- export type Nullable<T> = T | null | undefined;\n- export type DeepReadonly<T> = { readonly [K in keyof T]: DeepReadonly<T[K]> };\n\nPatterns and conventions to follow:\n- All IDs are Id alias for flexibility between numeric/string backends.\n- Services should return ApiResult<T> or throw for network-level errors. Use ApiError for normalized errors.\n- For paginated endpoints, return PaginatedResponse<T> wrapped with ApiResult<PaginatedResponse<T>>.\n- Narrow by role in UI via guard helpers (e.g., isDoctor(user): user is Doctor).\n\nExample usage snippets:\n- import { User, ApiResult, PaginatedResponse } from '@/core/contracts';\n- async function fetchUsers(): Promise<ApiResult<PaginatedResponse<User>>> { /* ... */ }\n\nIntegration points with kernel files:\n- services/apiClient.ts should reference ApiResult and ApiError types here to ensure typed responses.\n- events.ts WebsocketEventMap should reuse WebsocketEventMap here to type real-time payloads.\n- providers/AuthProvider and contexts/AuthContext will use User and AuthTokens defined here."
    },
    {
      "id": "core-di",
      "file_path": "src/core/di.ts",
      "description": "Lightweight dependency injection container for swapping implementations (used by services/providers/tests).",
      "dependencies": [],
      "exports": [
        "container",
        "provide",
        "resolve"
      ],
      "priority": 1,
      "purpose": "A minimal, type-safe dependency injection (service locator) used to register and resolve runtime implementations for common services (ApiClient, AuthService, StorageService, WebSocketService). It supports overriding implementations for tests or feature-level composition.",
      "content": "Design goals:\n- Lightweight and typed: tokens carry type information for resolution\n- Allow late binding and safe overrides in tests\n- Prevent accidental re-provide in production unless explicitly allowed\n\nAPI and types to implement:\n1) Token<T>\n- export interface Token<T> { readonly key: symbol; readonly name?: string; }\n- export function createToken<T>(name?: string): Token<T> // returns a unique token\n\n2) Core tokens to export (examples):\n- export const API_CLIENT = createToken<{ request: <T>(input: RequestInfo, init?: RequestInit)=>Promise<T> }>('API_CLIENT');\n- export const AUTH_SERVICE = createToken<{ login: (u:string,p:string)=>Promise<any>; logout:()=>Promise<void>; getCurrentUser: ()=>Promise<import('@/core/contracts').User | null> }>('AUTH_SERVICE');\n- export const STORAGE_SERVICE = createToken<{ get: (k:string)=>Promise<any>; set: (k:string,v:any)=>Promise<void>; remove: (k:string)=>Promise<void> }>('STORAGE_SERVICE');\n- export const WEBSOCKET_SERVICE = createToken<{ connect: ()=>Promise<void>; disconnect: ()=>Promise<void>; send: (topic:string,payload:any)=>void }>('WEBSOCKET_SERVICE');\n\n3) Container class signature\n- class Container {\n    provide<T>(token: Token<T>, implementation: T, options?: { override?: boolean }): void;\n    resolve<T>(token: Token<T>): T; // throws if not registered\n    has(token: Token<any>): boolean;\n    clear(): void; // clear all registrations (useful for tests)\n  }\n\n4) Top-level exports and convenience helpers\n- export const container = new Container();\n- export function provide<T>(token: Token<T>, impl: T, options?: { override?: boolean }) { container.provide(token, impl, options); }\n- export function resolve<T>(token: Token<T>) { return container.resolve(token); }\n\nBehavioral details and safety:\n- provide should throw if token already registered unless options.override === true. This prevents accidental double-registration in production. Tests can call container.clear() or override explicitly.\n- resolve throws a descriptive error when token not registered; provide helpful message listing token.name.\n- container should be a module-level singleton to keep consistent registrations app-wide.\n- Avoid storing heavy closures or DOM nodes in the container; use it for services only.\n\nUsage examples:\n- import { provide, resolve, API_CLIENT } from '@/core/di';\n- provide(API_CLIENT, { request: apiClient.request.bind(apiClient) });\n- const api = resolve(API_CLIENT);\n- await api.request('/users');\n\nIntegration points:\n- RootProvider should register concrete implementations for API_CLIENT, AUTH_SERVICE, STORAGE_SERVICE and WEBSOCKET_SERVICE during app bootstrap. Providers/services may also register wrappers that decorate underlying implementations.\n- Tests can call container.clear() in afterEach to avoid cross-test pollution and register mock implementations via provide(..., { override: true }).\n\nNotes on Type Safety:\n- createToken<T>() returns a token typed to T; provide/resolve are typed and enforce compile-time guarantees.\n- Use Token names for helpful debugging only; do not rely on names for resolution."
    },
    {
      "id": "core-events",
      "file_path": "src/core/events.ts",
      "description": "Small event bus (pub/sub) for cross-cutting events (auth changed, notifications). Lightweight, typed events.",
      "dependencies": [],
      "exports": [
        "events",
        "EventEmitter"
      ],
      "priority": 1,
      "purpose": "Typed, minimal EventBus used for decoupled cross-cutting communication (auth changes, toast notifications, realtime updates). Supports synchronous and asynchronous handlers, once handlers, and safe emission that collects handler results and errors into a standard shape.",
      "content": "File responsibilities: - Provide a small class EventEmitter<E> parameterized by a typed event map E (mapping event names to payload types). - Provide utility types EventHandler<E,K> and OnceEventHandler. - Export a singleton instance named events typed with a DomainEvents map used by the app.\n\nDesign requirements and API:\n1) Typed event map\n- export interface DomainEvents { 'auth.login': { userId: string }; 'auth.logout': { userId?: string }; 'toast.show': { id?: string; title?: string; message: string; level?: 'info' | 'success' | 'warning' | 'error'; timeout?: number }; 'appointment.updated': import('@/core/contracts').Appointment; 'ws.raw': { topic: string; payload: any }; 'error.report': { error: Error | string; context?: any }; }\n\n2) EventEmitter class signature and methods\n- export class EventEmitter<E extends Record<string, any>> {\n    on<K extends keyof E>(eventName: K, handler: (payload: E[K]) => void | Promise<void>): () => void; // returns unsubscribe\n    once<K extends keyof E>(eventName: K, handler: (payload: E[K]) => void | Promise<void>): () => void;\n    off<K extends keyof E>(eventName: K, handler: (payload: E[K]) => void | Promise<void>): void;\n    emit<K extends keyof E>(eventName: K, payload: E[K]): Promise<Array<{ handlerResult?: any; error?: any }>>; // collects results/errors\n  }\n\nBehavioral details:\n- Handlers can be sync or async. emit should await each handler and return an array of result objects capturing success/error per handler so callers may inspect failures.\n- Emission order: handlers are called in registration order.\n- once handlers are removed after first successful invocation (still removed even if handler throws).\n- on returns an unsubscribe function for convenience, which calls off under the hood.\n- off removes a single handler reference; removing an unregistered handler is a no-op.\n- Protect against handler errors so one failing handler doesn't block others. All handler exceptions are captured and returned.\n\nSingleton export and usage:\n- export const events = new EventEmitter<DomainEvents>();\n\nExamples:\n- import { events } from '@/core/events';\n- const unsub = events.on('toast.show', ({ message }) => console.log('TOAST', message));\n- await events.emit('auth.login', { userId: '123' });\n- events.once('appointment.updated', appointment => { /* handle once */ });\n\nIntegration points:\n- providers/AuthProvider emits 'auth.login' and 'auth.logout' events when user signs in/out.\n- shared ErrorBoundary emits 'error.report' when capturing render errors.\n- services that handle websocket messages route parsed events to events.emit('ws.raw', {...}) and to specific typed events like 'appointment.updated'.\n\nPerformance and memory notes:\n- Keep handler lists small and avoid holding closures with long-lived memory. In large apps, consider scoped emitters per feature; this global emitter is intended for cross-cutting lightweight signals.\n\nTesting tips:\n- Tests can subscribe to events and await emitted results. Remember to unsubscribe after each test to avoid leakage."
    },
    {
      "id": "core-hooks-registry",
      "file_path": "src/core/hooks.ts",
      "description": "Hook registry / extension points definition. Provides types and small registry to register extension hooks from features.",
      "dependencies": [],
      "exports": [
        "HookRegistry",
        "registerHook",
        "runHook"
      ],
      "priority": 1,
      "purpose": "A small hook registry / extension-point system for features to register callbacks at strategic points. Hooks are synchronous or asynchronous and support ordering and short-circuiting when needed.",
      "content": "This file provides a tiny extensibility mechanism: named HookPoints that features can register handlers for. The registry should be lightweight and safe for both browser runtime registration (when a feature module mounts) and server-side tests.\n\nDefinitions and API:\n1) HookPoint union\n- export type HookPoint = 'beforeApiRequest' | 'afterApiResponse' | 'onLogin' | 'onLogout' | 'onRouteChange' | 'onErrorReported';\n\n2) HookContext\n- export interface HookContext { id?: string; source?: string; timestamp: string; meta?: Record<string, any>; }\n- For beforeApiRequest/afterApiResponse include request/response shape types in meta e.g., meta.request, meta.response\n\n3) Hook handler signature\n- Handlers can be sync or async and receive a payload dependent on the hook point and a shared HookContext. Example generic signature:\n  type HookHandler<P = any> = (payload: P, ctx: HookContext) => Promise<any> | any;\n\n4) HookRegistry class\n- class HookRegistry {\n    register<P = any>(point: HookPoint, handler: HookHandler<P>, options?: { id?: string; priority?: number }): () => void; // returns unregister\n    run<P = any>(point: HookPoint, payload?: P, ctx?: Partial<HookContext>): Promise<Array<{ handlerId?: string; result?: any; error?: any }>>;\n    clear(point?: HookPoint): void; // clear handlers for a point or all\n  }\n\nBehavioral details:\n- Handlers can be registered with a numeric priority (default 0). Lower priority numbers run earlier. This allows features to insert pre/post handlers predictably.\n- run executes handlers in priority order ascending and collects results into an array. run awaits each handler; if a handler throws, the error is captured and the remaining handlers still run (unless an option to short-circuit is added in future).\n- register returns an unregister function to remove the handler. Each handler may optionally have an id (string) used for bookkeeping.\n- Handler identity: equality is by function reference and optional id; registry must track both.\n\nStandard hooks and payload shapes (recommended):\n- beforeApiRequest: payload { url: string; method: string; headers?: Record<string,string>; body?: any; signal?: AbortSignal } - used to add headers/metrics/tracing; handlers may mutate payload in-place or return a transformed payload\n- afterApiResponse: payload { url: string; method: string; status: number; response: any; elapsedMs?: number } - used to implement telemetry, analytics, or post-processing\n- onLogin: payload { userId: string; tokens?: import('@/core/contracts').AuthTokens }\n- onLogout: payload { userId?: string }\n- onRouteChange: payload { from?: string; to: string }\n- onErrorReported: payload { error: any; context?: any }\n\nExported helpers:\n- export const globalHookRegistry = new HookRegistry();\n- export function registerHook(...) { return globalHookRegistry.register(...); }\n- export function runHook(...) { return globalHookRegistry.run(...); }\n\nExample usage:\n- import { registerHook, runHook } from '@/core/hooks';\n- const unregister = registerHook('beforeApiRequest', (payload, ctx) => { payload.headers = payload.headers ?? {}; payload.headers['x-request-source'] = 'dashboard'; }, { priority: -10 });\n- await runHook('onLogin', { userId: 'u1' });\n\nIntegration points:\n- services/apiClient.ts should call runHook('beforeApiRequest', { ... }) before sending and runHook('afterApiResponse', { ... }) after receiving a response. That allows features to inject headers, trace, instrument and modify responses.\n- providers/AuthProvider should runHook('onLogin', ...) and 'onLogout' appropriately so other features can react.\n- RootProvider or route layer can call runHook('onRouteChange', { from, to }) on navigation events.\n\nPatterns and conventions:\n- Keep hook handlers idempotent and side-effect minimal; use priority ordering for coordination.\n- Prefer to mutate payload in-place for performance but document when a handler returns a new payload (consistent contract) \u2014 registry should accept either mutation or returned value but runHook should always pass final payload to next handler.\n- In order to future-proof, design run to accept options like { shortCircuitOnTruthy?: boolean } though not required initially."
    },
    {
      "id": "core-utils",
      "file_path": "src/core/utils.ts",
      "description": "Shared utility helpers (e.g., fetchWithTimeout, safeJsonParse, formatDate) used by services and components.",
      "dependencies": [],
      "exports": [
        "fetchWithTimeout",
        "safeJsonParse",
        "formatDate"
      ],
      "priority": 1,
      "purpose": "Common lightweight utility helpers used across services and components: fetchWithTimeout, safeJsonParse, formatDate, relativeTime helpers, and a small debug logger that respects APP_CONFIG development flags.",
      "content": "This file exposes deterministic, well-typed helpers with no side effects. Keep implementations small and dependency-free.\n\nFunctions to implement and expected behavior:\n\n1) fetchWithTimeout\n- Signature: export async function fetchWithTimeout(input: RequestInfo, init?: RequestInit & { timeoutMs?: number }, defaultTimeout?: number): Promise<Response>\n- Behavior: Uses AbortController to abort fetch after provided timeoutMs or defaultTimeout. If aborted, throws an Error with name 'AbortError' and message 'Request timed out'. The returned promise rejects with original fetch error or timeout error.\n- Good for services/apiClient to cancel slow requests.\n\n2) safeJsonParse\n- Signature: export function safeJsonParse<T = any>(input: string | null | undefined): T | null\n- Behavior: Returns parsed object or null on parse errors. Do not throw. Useful for reading localStorage or server-sent strings.\n\n3) formatDate and formatDateTime\n- Signature: export function formatDate(isoString: string, options?: Intl.DateTimeFormatOptions): string\n- Signature: export function formatDateTime(isoString: string, options?: Intl.DateTimeFormatOptions): string\n- Behavior: Use Intl.DateTimeFormat with sensible defaults, fallback gracefully when isoString is invalid.\n\n4) relativeTime\n- Signature: export function relativeTime(isoString: string): string\n- Behavior: Return human-friendly relative time like '5m ago', '2d ago', 'in 3h'. Use simple thresholds (seconds/minutes/hours/days) \u2014 no external libs.\n\n5) debugLog\n- Signature: export const debugLog: (...args: any[]) => void\n- Behavior: Logs to console only if APP_CONFIG.isDevelopment or development_mode.enableVerboseLogging is true. Ensure it's a no-op in production by checking config. Accepts an optional tag as first arg if string.\n\nExample implementations and usage:\n- import { fetchWithTimeout } from '@/core/utils';\n- const res = await fetchWithTimeout('/health', { timeoutMs: 5000 });\n- import { safeJsonParse } from '@/core/utils';\n- const obj = safeJsonParse(localStorage.getItem('hp:user'));\n\nIntegration points and patterns:\n- services/apiClient.ts uses fetchWithTimeout and debugLog to perform requests and log when verbose mode enabled.\n- Providers and hooks can use formatDate/relativeTime for consistent UI presentation.\n\nPerformance and reliability notes:\n- All functions must be synchronous or return a Promise when needed; avoid heavy CPU work.\n- Keep code small and well documented; these utilities are shared widely so avoid changing semantics once in production."
    },
    {
      "id": "hooks-use-auth",
      "file_path": "src/hooks/useAuth.ts",
      "description": "Hook to access auth context (current user, login, logout, refresh) with conveniences for components.",
      "dependencies": [
        "src/contexts/AuthContext.tsx",
        "src/services/authService.ts",
        "src/core/events.ts"
      ],
      "exports": [
        "useAuth"
      ],
      "priority": 1
    },
    {
      "id": "hooks-use-fetch",
      "file_path": "src/hooks/useFetch.ts",
      "description": "Reusable data-fetching hook with loading/error handling, cancellation via AbortController, optional caching and revalidation. Wraps apiClient.",
      "dependencies": [
        "src/services/apiClient.ts",
        "src/hooks/useIsMounted.ts",
        "src/core/contracts.ts"
      ],
      "exports": [
        "useFetch"
      ],
      "priority": 1
    },
    {
      "id": "hooks-use-is-mounted",
      "file_path": "src/hooks/useIsMounted.ts",
      "description": "Small hook to track mounted state to avoid setState after unmount (used by useFetch).",
      "dependencies": [],
      "exports": [
        "useIsMounted"
      ],
      "priority": 1
    },
    {
      "id": "main-entry",
      "file_path": "src/main.tsx",
      "description": "Application entry point. Renders <RootProvider><App/></RootProvider> into the DOM and imports global styles.",
      "dependencies": [
        "src/App.tsx",
        "src/providers/RootProvider.tsx",
        "src/styles/global.css"
      ],
      "exports": [
        "bootstrap (entry)"
      ],
      "priority": 1
    },
    {
      "id": "providers-api-provider",
      "file_path": "src/providers/ApiProvider.tsx",
      "description": "Optional provider that configures apiClient runtime aspects (e.g., base URL override, interceptors) and supplies helpers via context if needed.",
      "dependencies": [
        "src/services/apiClient.ts",
        "src/app/config.ts"
      ],
      "exports": [
        "ApiProvider"
      ],
      "priority": 1
    },
    {
      "id": "providers-auth-provider",
      "file_path": "src/providers/AuthProvider.tsx",
      "description": "Provider that manages auth lifecycle in the app (load stored tokens, login/logout flows) and exposes context values via AuthContext.",
      "dependencies": [
        "src/contexts/AuthContext.tsx",
        "src/services/authService.ts",
        "src/core/events.ts",
        "src/core/contracts.ts"
      ],
      "exports": [
        "AuthProvider"
      ],
      "priority": 1
    },
    {
      "id": "providers-root-provider",
      "file_path": "src/providers/RootProvider.tsx",
      "description": "Composes AuthProvider, ApiProvider, ThemeProvider and any other global providers. Wraps the app in a single place.",
      "dependencies": [
        "src/providers/AuthProvider.tsx",
        "src/providers/ApiProvider.tsx",
        "src/providers/ThemeProvider.tsx",
        "src/core/hooks.ts"
      ],
      "exports": [
        "RootProvider"
      ],
      "priority": 1
    },
    {
      "id": "providers-theme-provider",
      "file_path": "src/providers/ThemeProvider.tsx",
      "description": "Lightweight theme provider exposing current theme and toggling. Can integrate with CSS variables or Tailwind config.",
      "dependencies": [],
      "exports": [
        "ThemeProvider",
        "useTheme"
      ],
      "priority": 1
    },
    {
      "id": "services-api-client",
      "file_path": "src/services/apiClient.ts",
      "description": "Typed API client wrapper around fetch; central place for baseUrl, request/response handling, auth token injection, and error normalization.",
      "dependencies": [
        "src/app/config.ts",
        "src/core/utils.ts",
        "src/core/contracts.ts"
      ],
      "exports": [
        "apiClient",
        "request"
      ],
      "priority": 1
    },
    {
      "id": "services-auth-service",
      "file_path": "src/services/authService.ts",
      "description": "Auth service handling login/logout/token refresh and mapping to AuthTokens/User. Uses apiClient.",
      "dependencies": [
        "src/services/apiClient.ts",
        "src/core/contracts.ts",
        "src/core/events.ts"
      ],
      "exports": [
        "authService"
      ],
      "priority": 1
    },
    {
      "id": "services-user-service",
      "file_path": "src/services/userService.ts",
      "description": "User-related API calls: fetch list of users, get user by id. Returns typed domain models.",
      "dependencies": [
        "src/services/apiClient.ts",
        "src/core/contracts.ts"
      ],
      "exports": [
        "userService"
      ],
      "priority": 1
    },
    {
      "id": "styles-global",
      "file_path": "src/styles/global.css",
      "description": "Global CSS entry (base resets, utility classes). Imported by src/main.tsx.",
      "dependencies": [],
      "exports": [
        "global styles"
      ],
      "priority": 1
    },
    {
      "id": "app-root",
      "file_path": "src/App.tsx",
      "description": "Top-level App component composing ErrorBoundary, AppRoutes and global UI chrome if needed.",
      "dependencies": [
        "src/routes/AppRoutes.tsx",
        "src/shared/components/ErrorBoundary.tsx"
      ],
      "exports": [
        "App"
      ],
      "priority": 2
    },
    {
      "id": "features-metric-card",
      "file_path": "src/features/dashboard/MetricCard.tsx",
      "description": "Small presentational card for metric display used on the Dashboard page.",
      "dependencies": [
        "src/core/contracts.ts"
      ],
      "exports": [
        "MetricCard"
      ],
      "priority": 2
    },
    {
      "id": "features-user-list",
      "file_path": "src/features/users/UserList.tsx",
      "description": "UserList container component that fetches users via userService/useFetch and renders a list with Loading and Error states.",
      "dependencies": [
        "src/services/userService.ts",
        "src/hooks/useFetch.ts",
        "src/shared/components/LoadingSpinner.tsx",
        "src/core/contracts.ts"
      ],
      "exports": [
        "UserList"
      ],
      "priority": 2
    },
    {
      "id": "routes-app-routes",
      "file_path": "src/routes/AppRoutes.tsx",
      "description": "Route definitions for the SPA using React Router. Maps paths to page components and handles NotFound.",
      "dependencies": [
        "src/pages/HomePage.tsx",
        "src/pages/DashboardPage.tsx",
        "src/pages/UsersPage.tsx",
        "src/pages/NotFoundPage.tsx"
      ],
      "exports": [
        "AppRoutes"
      ],
      "priority": 2
    },
    {
      "id": "shared-button",
      "file_path": "src/shared/components/Button.tsx",
      "description": "Accessible Button component (variants, sizes). A presentational primitive used across pages and features.",
      "dependencies": [],
      "exports": [
        "Button"
      ],
      "priority": 2
    },
    {
      "id": "shared-error-boundary",
      "file_path": "src/shared/components/ErrorBoundary.tsx",
      "description": "React Error Boundary to capture render errors at subtree boundaries and optionally report via events.",
      "dependencies": [
        "src/core/events.ts"
      ],
      "exports": [
        "ErrorBoundary"
      ],
      "priority": 2
    },
    {
      "id": "shared-footer",
      "file_path": "src/shared/components/Footer.tsx",
      "description": "Footer component used by Layout for consistent bottom area.",
      "dependencies": [],
      "exports": [
        "Footer"
      ],
      "priority": 2
    },
    {
      "id": "shared-header",
      "file_path": "src/shared/components/Header.tsx",
      "description": "Top navigation header that reads auth state (useAuth) and shows user/menu actions.",
      "dependencies": [
        "src/hooks/useAuth.ts",
        "src/shared/components/Button.tsx"
      ],
      "exports": [
        "Header"
      ],
      "priority": 2
    },
    {
      "id": "shared-input",
      "file_path": "src/shared/components/Input.tsx",
      "description": "Accessible Input component wrapper with label/validation styling.",
      "dependencies": [],
      "exports": [
        "Input"
      ],
      "priority": 2
    },
    {
      "id": "shared-layout",
      "file_path": "src/shared/components/Layout.tsx",
      "description": "Application layout coordinating Header, main content area and Footer. Used by pages.",
      "dependencies": [
        "src/shared/components/Header.tsx",
        "src/shared/components/Footer.tsx"
      ],
      "exports": [
        "Layout"
      ],
      "priority": 2
    },
    {
      "id": "shared-loading-spinner",
      "file_path": "src/shared/components/LoadingSpinner.tsx",
      "description": "Small loading spinner component used by lists and async states.",
      "dependencies": [],
      "exports": [
        "LoadingSpinner"
      ],
      "priority": 2
    },
    {
      "id": "pages-dashboard",
      "file_path": "src/pages/DashboardPage.tsx",
      "description": "Dashboard page showing key metrics and summaries (composes MetricCard).",
      "dependencies": [
        "src/shared/components/Layout.tsx",
        "src/features/dashboard/MetricCard.tsx"
      ],
      "exports": [
        "DashboardPage"
      ],
      "priority": 3
    },
    {
      "id": "pages-home",
      "file_path": "src/pages/HomePage.tsx",
      "description": "Landing/home page. Uses Layout and shows basic welcome content.",
      "dependencies": [
        "src/shared/components/Layout.tsx",
        "src/shared/components/Button.tsx"
      ],
      "exports": [
        "HomePage"
      ],
      "priority": 3
    },
    {
      "id": "pages-not-found",
      "file_path": "src/pages/NotFoundPage.tsx",
      "description": "404 Not Found page shown for unknown routes.",
      "dependencies": [
        "src/shared/components/Layout.tsx"
      ],
      "exports": [
        "NotFoundPage"
      ],
      "priority": 3
    },
    {
      "id": "pages-users",
      "file_path": "src/pages/UsersPage.tsx",
      "description": "Users management page. Composes UserList and provides page-level controls.",
      "dependencies": [
        "src/shared/components/Layout.tsx",
        "src/features/users/UserList.tsx"
      ],
      "exports": [
        "UsersPage"
      ],
      "priority": 3
    }
  ],
  "file_paths": [
    "src/app/config.ts",
    "src/contexts/AuthContext.tsx",
    "src/core/contracts.ts",
    "src/core/di.ts",
    "src/core/events.ts",
    "src/core/hooks.ts",
    "src/core/utils.ts",
    "src/hooks/useAuth.ts",
    "src/hooks/useFetch.ts",
    "src/hooks/useIsMounted.ts",
    "src/main.tsx",
    "src/providers/ApiProvider.tsx",
    "src/providers/AuthProvider.tsx",
    "src/providers/RootProvider.tsx",
    "src/providers/ThemeProvider.tsx",
    "src/services/apiClient.ts",
    "src/services/authService.ts",
    "src/services/userService.ts",
    "src/styles/global.css",
    "src/App.tsx",
    "src/features/dashboard/MetricCard.tsx",
    "src/features/users/UserList.tsx",
    "src/routes/AppRoutes.tsx",
    "src/shared/components/Button.tsx",
    "src/shared/components/ErrorBoundary.tsx",
    "src/shared/components/Footer.tsx",
    "src/shared/components/Header.tsx",
    "src/shared/components/Input.tsx",
    "src/shared/components/Layout.tsx",
    "src/shared/components/LoadingSpinner.tsx",
    "src/pages/DashboardPage.tsx",
    "src/pages/HomePage.tsx",
    "src/pages/NotFoundPage.tsx",
    "src/pages/UsersPage.tsx"
  ],
  "descriptions": [
    "Materialized runtime configuration (APP_CONFIG) such as apiBaseUrl, feature flags and environment info.",
    "React Context for authentication state (current user, tokens, helpers). Consumed by useAuth and AuthProvider.",
    "Application domain types and API contracts (User, AuthTokens, ApiResponse, paging types) used across services, hooks and components.",
    "Lightweight dependency injection container for swapping implementations (used by services/providers/tests).",
    "Small event bus (pub/sub) for cross-cutting events (auth changed, notifications). Lightweight, typed events.",
    "Hook registry / extension points definition. Provides types and small registry to register extension hooks from features.",
    "Shared utility helpers (e.g., fetchWithTimeout, safeJsonParse, formatDate) used by services and components.",
    "Hook to access auth context (current user, login, logout, refresh) with conveniences for components.",
    "Reusable data-fetching hook with loading/error handling, cancellation via AbortController, optional caching and revalidation. Wraps apiClient.",
    "Small hook to track mounted state to avoid setState after unmount (used by useFetch).",
    "Application entry point. Renders <RootProvider><App/></RootProvider> into the DOM and imports global styles.",
    "Optional provider that configures apiClient runtime aspects (e.g., base URL override, interceptors) and supplies helpers via context if needed.",
    "Provider that manages auth lifecycle in the app (load stored tokens, login/logout flows) and exposes context values via AuthContext.",
    "Composes AuthProvider, ApiProvider, ThemeProvider and any other global providers. Wraps the app in a single place.",
    "Lightweight theme provider exposing current theme and toggling. Can integrate with CSS variables or Tailwind config.",
    "Typed API client wrapper around fetch; central place for baseUrl, request/response handling, auth token injection, and error normalization.",
    "Auth service handling login/logout/token refresh and mapping to AuthTokens/User. Uses apiClient.",
    "User-related API calls: fetch list of users, get user by id. Returns typed domain models.",
    "Global CSS entry (base resets, utility classes). Imported by src/main.tsx.",
    "Top-level App component composing ErrorBoundary, AppRoutes and global UI chrome if needed.",
    "Small presentational card for metric display used on the Dashboard page.",
    "UserList container component that fetches users via userService/useFetch and renders a list with Loading and Error states.",
    "Route definitions for the SPA using React Router. Maps paths to page components and handles NotFound.",
    "Accessible Button component (variants, sizes). A presentational primitive used across pages and features.",
    "React Error Boundary to capture render errors at subtree boundaries and optionally report via events.",
    "Footer component used by Layout for consistent bottom area.",
    "Top navigation header that reads auth state (useAuth) and shows user/menu actions.",
    "Accessible Input component wrapper with label/validation styling.",
    "Application layout coordinating Header, main content area and Footer. Used by pages.",
    "Small loading spinner component used by lists and async states.",
    "Dashboard page showing key metrics and summaries (composes MetricCard).",
    "Landing/home page. Uses Layout and shows basic welcome content.",
    "404 Not Found page shown for unknown routes.",
    "Users management page. Composes UserList and provides page-level controls."
  ],
  "total_files": 34
}