{'architecture': {'overview': 'Single-page React 18+ TypeScript application organized into a small core kernel (domain contracts, app config, event/hooks/DI utilities), foundational providers and services (API client, auth, data services, React Query provider), shared UI primitives and hooks, and feature pages. Routing is handled by a central router component; React Query manages async data and caching. The app is designed for testability, clear separation of concerns, and incremental implementation by feature.', 'patterns': ['Container / Presentational (pages and feature containers call services/hooks; shared components are purely presentational)', 'Domain contracts + services (domain types in core/contracts.ts; services implement API calls using apiClient)', 'Provider composition (QueryProvider, AuthProvider, ThemeProvider wrap App at root)', 'Feature-based pages (each page under src/pages) with shared components under src/shared', 'Hooks + small local state (React Query for server state; a minimal local auth store for session state)'], 'data_flow': 'User interactions in Pages -> call Hooks (useAuth, useFetch, useForm) or services -> services call apiClient -> apiClient uses app config to call the backend -> results are cached by React Query and exposed to components. AuthProvider and useAuthStore hold authentication state (login/logout), and core events can broadcast cross-cutting state changes. UI components receive props from containers/pages; providers inject cross-cutting capabilities.', 'folder_structure': 'src/\n  app/\n    App.tsx\n    router.tsx\n    config.ts\n  core/\n    contracts.ts\n    events.ts\n    hooks.ts\n    di.ts\n    utils.ts\n  providers/\n    QueryProvider.tsx\n    AuthProvider.tsx\n    ThemeProvider.tsx\n  services/\n    apiClient.ts\n    authService.ts\n    userService.ts\n    todoService.ts\n  state/\n    useAuthStore.ts\n  hooks/\n    useFetch.ts\n    useAuth.ts\n    useForm.ts\n    useDebounce.ts\n  shared/\n    components/\n      Button.tsx\n      Input.tsx\n      Icon.tsx\n      Layout.tsx\n      Header.tsx\n      Footer.tsx\n      Spinner.tsx\n  pages/\n    HomePage.tsx\n    LoginPage.tsx\n    DashboardPage.tsx\n    ProfilePage.tsx\n    NotFoundPage.tsx\n  styles/\n    index.css\n  main.tsx', 'tech_stack': ['React 18+ (functional components, hooks)', 'TypeScript', 'React Router (client routing) - implicit in router.tsx', 'React Query (tanstack/react-query) for async data & caching', 'Context API for AuthProvider + optional lightweight Zustand or local store pattern (useAuthStore)', 'Fetch-based apiClient (wrapped for headers, baseUrl from config)', 'CSS modules / global CSS (src/styles/index.css) or Tailwind (project already configured) depending on base_configs']}, 'kernel_specs': {'overview': 'The core kernel provides a single source of truth for domain contracts, runtime configuration, an in-process typed event bus, an extensible hook registry, a small dependency-injection container, and shared utilities. All application sections (providers, services, hooks, pages, components) import types/contracts and utilities from the kernel to ensure consistent types, predictable runtime configuration and clear extension points. Use @/core/* imports in application code to access these definitions.'}, 'sections': [{'id': 'api-client', 'file_path': 'src/services/apiClient.ts', 'description': 'Thin wrapper around fetch (or global HTTP client) that applies baseUrl, auth headers, error handling and response parsing. Used by all services.', 'dependencies': [], 'exports': ['apiClient', 'ApiResponse', 'HttpError'], 'priority': 1}, {'id': 'app-config', 'file_path': 'src/app/config.ts', 'description': 'Materialized configuration for the application: runtime values such as API_BASE_URL, environment flags, feature toggles. Exported constants used by apiClient and other services.', 'dependencies': [], 'exports': ['API_BASE_URL', 'APP_NAME', 'ENV'], 'priority': 1, 'purpose': 'Materialized application configuration. Exports typed runtime configuration, computed flags and feature helpers. Provides small, deterministic mock data when development mode enables mock data.', 'content': "Summary\n- Purpose: provide a single typed config object that the whole app reads from. Avoid sprinkling process.env checks across the codebase.\n- Conventions: keep the config immutable; computed flags are pure functions of the raw config. Feature keys are strings and accessed via hasFeature(key).\n\nTyped shape\n- export type Environment = 'development' | 'production' | 'test';\n\n- export interface AppConfig {\n    env: Environment;\n    apiBaseUrl: string;\n    appName: string;\n    version?: string;\n    features: string[]; // feature flag names\n    developmentMode: {\n      enableMockData: boolean;\n      verboseLogging: boolean;\n    };\n    websocket: {\n      enabled: boolean;\n      url?: string;\n    };\n  }\n\nMaterialized config (example materialization)\n- The file materializes a concrete APP_CONFIG constant. This value is the canonical runtime configuration the rest of the application uses. You may alter values before building for different environments.\n\nExample APP_CONFIG content (complete and deterministic):\n\nexport const APP_CONFIG: AppConfig = {\n  env: (process.env.NODE_ENV as Environment) || 'development',\n  apiBaseUrl: process.env.REACT_APP_API_BASE_URL || 'https://api.example-health.local/v1',\n  appName: 'DiPeO Health',\n  version: process.env.REACT_APP_VERSION || '0.0.1',\n  features: [\n    'telemedicine',\n    'lab_results',\n    'prescriptions',\n    'patient_portal'\n  ],\n  developmentMode: {\n    enableMockData: (process.env.REACT_APP_ENABLE_MOCKS === 'true') || true,\n    verboseLogging: (process.env.REACT_APP_VERBOSE_LOGGING === 'true') || false\n  },\n  websocket: {\n    enabled: true,\n    url: process.env.REACT_APP_WS_URL || 'wss://ws.example-health.local'\n  }\n};\n\nComputed flags & helpers\n- export const ENV = APP_CONFIG.env;\n- export const API_BASE_URL = APP_CONFIG.apiBaseUrl;\n- export const APP_NAME = APP_CONFIG.appName;\n- export const isDevelopment = APP_CONFIG.env === 'development';\n- export const shouldUseMockData = isDevelopment && APP_CONFIG.developmentMode.enableMockData;\n\n- export function hasFeature(name: string): boolean {\n    return APP_CONFIG.features.includes(name);\n  }\n\nMock data (only included when shouldUseMockData === true)\n- Provide a small deterministic MOCK_USERS array so the app can run in dev without a backend. The array is exported only for developer consumption.\n\n- export const MOCK_USERS = shouldUseMockData ? [\n    {\n      id: 'mock-patient-1',\n      email: 'jane.patient@example.test',\n      firstName: 'Jane',\n      lastName: 'Patient',\n      role: 'patient',\n      avatarUrl: undefined,\n      createdAt: new Date().toISOString()\n    },\n    {\n      id: 'mock-doctor-1',\n      email: 'dr.smith@example.test',\n      firstName: 'John',\n      lastName: 'Smith',\n      role: 'doctor',\n      specialties: ['cardiology'],\n      createdAt: new Date().toISOString()\n    }\n  ] : [];\n\nPatterns and conventions\n- Always import configuration values from this module: import { API_BASE_URL } from '@/app/config'. Do not read process.env directly elsewhere.\n- Feature toggles: use hasFeature('lab_results') to guard UI and service behavior.\n\nIntegration points\n- src/services/apiClient.ts uses API_BASE_URL and websocket.url from this file.\n- src/core/events.ts and src/core/hooks.ts can check shouldUseMockData to alter behavior in development.\n- Providers and storybooks can import MOCK_USERS to bootstrap dev sessions."}, {'id': 'app-root', 'file_path': 'src/app/App.tsx', 'description': 'Root application component. Provides app-level shell and renders Router. Reads light config if needed.', 'dependencies': ['src/app/router.tsx', 'src/shared/components/Layout.tsx', 'src/providers/ThemeProvider.tsx'], 'exports': ['App'], 'priority': 1}, {'id': 'app-router', 'file_path': 'src/app/router.tsx', 'description': 'Central router component that declares routes and lazy-loads pages. Handles protected routes using AuthProvider / useAuth.', 'dependencies': ['src/pages/HomePage.tsx', 'src/pages/LoginPage.tsx', 'src/pages/DashboardPage.tsx', 'src/pages/ProfilePage.tsx', 'src/pages/NotFoundPage.tsx'], 'exports': ['AppRouter'], 'priority': 1}, {'id': 'auth-provider', 'file_path': 'src/providers/AuthProvider.tsx', 'description': 'Context provider for authentication state and session lifecycle. Uses useAuthStore and authService to persist session and expose login/logout functions to the app.', 'dependencies': ['src/services/authService.ts', 'src/state/useAuthStore.ts'], 'exports': ['AuthProvider', 'useAuthContext'], 'priority': 1}, {'id': 'auth-service', 'file_path': 'src/services/authService.ts', 'description': 'Auth-related service: login, logout, refresh token, current user retrieval. Uses apiClient to communicate with backend.', 'dependencies': ['src/services/apiClient.ts'], 'exports': ['login', 'logout', 'getCurrentUser', 'refreshToken'], 'priority': 1}, {'id': 'core-contracts', 'file_path': 'src/core/contracts.ts', 'description': 'Domain types, API request/response contracts and shared TypeScript interfaces used across the app (User, Auth tokens, Todo, API error shapes).', 'dependencies': [], 'exports': ['User', 'AuthTokens', 'LoginRequest', 'LoginResponse', 'Todo', 'ApiError'], 'priority': 1, 'purpose': 'Domain TypeScript types and shared API contracts used across the app. This file defines the canonical domain model (users and healthcare objects), API response envelopes, WebSocket event types, and small UI helper types.', 'content': "Summary\n- Purpose: provide canonical domain interfaces so services, components and tests share the same shapes.\n- Conventions: all ids are strings (UUIDs). Dates are ISO strings (string) in DTOs and Date in internal helpers when appropriate. Optional fields are marked with ?.\n\nTypes & interfaces to define (explicit signatures)\n\n1) Role and User types\n- export type Role = 'patient' | 'doctor' | 'nurse' | 'admin';\n\n- export interface User {\n    id: string; // uuid\n    email: string;\n    firstName: string;\n    lastName: string;\n    role: Role;\n    avatarUrl?: string;\n    createdAt: string; // ISO date string\n    updatedAt?: string;\n  }\n\n- export interface Patient extends User {\n    role: 'patient';\n    dateOfBirth?: string; // ISO\n    medicalRecordId?: string;\n    emergencyContact?: { name: string; phone?: string };\n  }\n\n- export interface Doctor extends User {\n    role: 'doctor';\n    specialties: string[];\n    licenseNumber?: string;\n    clinicId?: string;\n  }\n\n- export interface Nurse extends User {\n    role: 'nurse';\n    unit?: string;\n  }\n\n2) Healthcare domain models\n- export interface Appointment {\n    id: string;\n    patientId: string;\n    providerId: string; // doctor or nurse id\n    scheduledAt: string; // ISO\n    durationMinutes?: number;\n    status: 'scheduled' | 'cancelled' | 'completed' | 'no_show';\n    notes?: string;\n    createdAt: string;\n  }\n\n- export interface MedicalRecord {\n    id: string;\n    patientId: string;\n    summary?: string;\n    allergies?: string[];\n    conditions?: string[];\n    medications?: string[];\n    updatedAt?: string;\n  }\n\n- export interface Prescription {\n    id: string;\n    recordId?: string;\n    patientId: string;\n    providerId: string;\n    drugName: string;\n    dose: string;\n    frequency: string;\n    instructions?: string;\n    issuedAt: string;\n    expiresAt?: string;\n  }\n\n- export interface LabResult {\n    id: string;\n    patientId: string;\n    testName: string;\n    result: string;\n    units?: string;\n    normalRange?: string;\n    collectedAt?: string;\n    reportedAt?: string;\n  }\n\n3) API response envelopes\n- export interface ApiResult<T = unknown> {\n    success: boolean;\n    data?: T;\n    error?: ApiError;\n  }\n\n- export interface ApiError {\n    code: string; // machine code e.g. 'AUTH_INVALID'\n    message: string; // human readable\n    status?: number; // http status if available\n    details?: Record<string, unknown>;\n  }\n\n- export interface PaginatedResponse<T> {\n    items: T[];\n    total: number;\n    page: number;\n    pageSize: number;\n  }\n\n4) WebSocket events (typed)\n- WebSocket is enabled by default in this kernel. If your runtime disables websockets update references in src/app/config.ts.\n\n- export type WebSocketEvent =\n    | { type: 'appointment.created'; payload: Appointment }\n    | { type: 'appointment.updated'; payload: Appointment }\n    | { type: 'user.updated'; payload: Partial<User> & { id: string } }\n    | { type: 'lab.result'; payload: LabResult }\n    | { type: 'prescription.issued'; payload: Prescription };\n\n5) UI helper types\n- export type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\n- export interface FormState<T = any> {\n    values: Partial<T>;\n    errors: Record<string, string>;\n    touched: Record<string, boolean>;\n    isSubmitting: boolean;\n  }\n\nPatterns and conventions\n- All domain models use ISO strings for date/time. Convert to Date at the boundaries (components/services) as needed with utilities in src/core/utils.ts.\n- Use ApiResult<T> for service responses; convert or throw in apiClient for simpler handling in services.\n\nExample usage patterns\n- import { User, Appointment, ApiResult } from '@/core/contracts';\n- const res: ApiResult<Appointment> = await appointmentService.create(...);\n\nIntegration points with other kernel files\n- src/services/apiClient.ts should return ApiResult<T> or throw HttpError; map backend shape to ApiResult.\n- src/core/events.ts uses Appointment and WebSocketEvent types to produce typed events.\n- src/core/hooks.ts uses these models in hook contexts (e.g., onLogin hook receives User)."}, {'id': 'core-di', 'file_path': 'src/core/di.ts', 'description': 'Simple dependency resolver / DI container for swapping implementations in tests. Allows registering services by token and resolving them.', 'dependencies': [], 'exports': ['register', 'resolve', 'DIContainer'], 'priority': 1, 'purpose': 'A minimal TypeScript-friendly dependency injection container for registering and resolving service implementations. Uses symbol-based tokens for type safety and easy overrides in tests.', 'content': "Summary\n- Purpose: allow swapping implementations (e.g., mock services in tests) without coupling all imports to concrete modules. The container supports singleton lifetimes and transient factories.\n- Conventions: tokens are created by createToken<T>('Name') and used to register a value or factory. resolve<T>(token) returns the registered instance or throws when missing unless an optional default is provided.\n\nToken type and creator\n- export interface Token<T> { readonly key: symbol; readonly name: string; }\n- export function createToken<T>(name: string): Token<T> {\n    return { key: Symbol(name), name } as Token<T>;\n  }\n\nContainer signatures\n- export type Factory<T> = (c: DIContainer) => T | Promise<T>;\n\n- export class DIContainer {\n    register<T>(token: Token<T>, implementation: T | Factory<T>, options?: { singleton?: boolean }): void;\n    resolve<T>(token: Token<T>): T;\n    has(token: Token<any>): boolean;\n    clear(): void; // remove all registrations\n  }\n\nImplementation notes\n- Internally keep a Map<Token.key, { impl, singleton, instance? }>\n- When register receives a Factory and singleton=true, call it lazily on first resolve and cache result.\n- When resolve cannot find a registration, throw a helpful error listing the missing token name.\n\nDefault container & convenience functions\n- export const defaultContainer = new DIContainer();\n- export const register = defaultContainer.register.bind(defaultContainer);\n- export const resolve = defaultContainer.resolve.bind(defaultContainer);\n\nCommon tokens (examples used across the app)\n- export const API_CLIENT_TOKEN = createToken<{ request<T>(...args: any[]): Promise<T> }>('ApiClient');\n- export const AUTH_SERVICE_TOKEN = createToken<{ login(...args: any[]): Promise<any>; logout(): Promise<void> }>('AuthService');\n- export const STORAGE_SERVICE_TOKEN = createToken<Storage>('StorageService');\n- export const WEBSOCKET_SERVICE_TOKEN = createToken<{ connect(): void; disconnect(): void }>('WebSocketService');\n\nExample usage\n- Register API client at app boot (main.tsx or provider composition):\n  import { register } from '@/core/di';\n  import { API_CLIENT_TOKEN } from '@/core/di';\n  register(API_CLIENT_TOKEN, apiClientInstance, { singleton: true });\n\n- Resolve inside a service or module (prefer constructor injection where possible):\n  import { resolve } from '@/core/di';\n  const api = resolve(API_CLIENT_TOKEN);\n\nIntegration points\n- QueryProvider or service initialization should register implementations for API_CLIENT_TOKEN and WEBSOCKET_SERVICE_TOKEN.\n- In tests, call defaultContainer.clear() then register() mock implementations to control behavior.\n\nType-safety\n- The container API uses Token<T> so resolve returns T, preserving compile-time typing across registrations and resolutions."}, {'id': 'core-events', 'file_path': 'src/core/events.ts', 'description': 'Small in-process event bus for cross-cutting events (e.g., auth:login, auth:logout). Minimal pub/sub API used by providers and utilities.', 'dependencies': [], 'exports': ['subscribe', 'unsubscribe', 'publish', 'EventMap'], 'priority': 1, 'purpose': 'A small, typed in-process event bus for cross-cutting domain events. Provides synchronous and asynchronous handler support, safe subscribe/unsubscribe, and a singleton instance to be used across the app.', 'content': "Summary\n- Purpose: allow decoupled communication (e.g., AuthProvider emits 'auth:login' and many parts of the app react).\n- Conventions: events are typed via EventMap. Handlers can be sync or return Promise<void>. publish will await async handlers unless publishAsync is explicitly false.\n\nEvent types\n- export interface EventMap {\n    'auth:login': { userId: string; user?: import('@/core/contracts').User };\n    'auth:logout': { userId?: string };\n    'appointment:created': { appointment: import('@/core/contracts').Appointment };\n    'appointment:updated': { appointment: import('@/core/contracts').Appointment };\n    'user:updated': { userId: string; changes: Partial<import('@/core/contracts').User> };\n    'ws:message': { event: import('@/core/contracts').WebSocketEvent };\n  }\n\nAPI and class\n- export type EventHandler<E> = (payload: E) => void | Promise<void>;\n\n- export class EventBus {\n    // internal map: event name -> Set of handlers\n    private handlers = new Map<string, Set<EventHandler<any>>>();\n\n    public on<K extends keyof EventMap>(event: K, handler: EventHandler<EventMap[K]>): () => void {\n      // returns an unsubscribe function\n    }\n\n    public off<K extends keyof EventMap>(event: K, handler: EventHandler<EventMap[K]>): boolean {\n      // returns whether handler was removed\n    }\n\n    public async emit<K extends keyof EventMap>(event: K, payload: EventMap[K], options?: { awaitHandlers?: boolean }): Promise<void> {\n      // if awaitHandlers !== false await all handlers, otherwise fire-and-forget\n    }\n\n    public clear(): void {\n      // remove all handlers (used in tests)\n    }\n  }\n\nImplementation notes (what should be implemented)\n- on(event, handler) registers handler and returns a function that when called removes the handler.\n- off(event, handler) removes a handler; returns true when removed.\n- emit(event, payload, options) iterates over a snapshot of handlers to avoid issues when handlers unregister themselves, calls each handler; when awaitHandlers is true (default) await Promise.all for handlers that return promises but preserve handler execution order for easier debugging (call and collect results in order).\n- clear() is useful for unit tests to reset the bus.\n\nSingleton & convenience functions\n- export const eventBus = new EventBus();\n- export const subscribe = <K extends keyof EventMap>(event: K, handler: EventHandler<EventMap[K]>) => eventBus.on(event, handler);\n- export const unsubscribe = <K extends keyof EventMap>(event: K, handler: EventHandler<EventMap[K]>) => eventBus.off(event, handler);\n- export const publish = <K extends keyof EventMap>(event: K, payload: EventMap[K], options?: { awaitHandlers?: boolean }) => eventBus.emit(event, payload, options);\n\nExample usage\n- import { publish, subscribe } from '@/core/events';\n- const off = subscribe('auth:login', async ({ userId, user }) => { console.log('user logged in', userId); });\n- publish('auth:login', { userId: 'u1' });\n- off();\n\nIntegration points\n- AuthProvider should publish 'auth:login' and 'auth:logout'.\n- WebSocketService publishes 'ws:message' when receiving messages and EventBus handles broadcasting to interested components/services.\n- Tests may call eventBus.clear() between test cases."}, {'id': 'core-hooks-registry', 'file_path': 'src/core/hooks.ts', 'description': 'Registry and types for extension hooks. Lightweight place to declare app-level hook contracts used by plugins/extensions.', 'dependencies': [], 'exports': ['registerHook', 'getHook', 'HookRegistry'], 'priority': 1, 'purpose': 'Lightweight hook registry for extension points. Plugins and features can register handlers for lifecycle events such as beforeApiRequest or onLogin. Hooks are typed and run in a controlled context. The registry is intentionally small and synchronous/async-friendly.', 'content': "Summary\n- Purpose: provide clear extension points used by apiClient, auth flows and routing. Hooks allow modifications to API requests, side-effects after responses, and lifecycle hooks on login/logout or route changes.\n- Conventions: hooks are registered by name; a register call returns an unregister function. Handlers can be async and return values which the registry collates when appropriate.\n\nHook names (HookPoint union)\n- export type HookPoint =\n    | 'beforeApiRequest'\n    | 'afterApiResponse'\n    | 'onLogin'\n    | 'onLogout'\n    | 'onRouteChange';\n\nHook context shape\n- export interface HookContext {\n    // for API hooks\n    request?: {\n      url: string;\n      method?: string;\n      headers?: Record<string,string>;\n      body?: unknown;\n    };\n    response?: {\n      status?: number;\n      body?: unknown;\n      raw?: Response;\n    };\n    // auth & user context\n    user?: import('@/core/contracts').User | null;\n    // route context for onRouteChange\n    route?: {\n      from?: string;\n      to: string;\n      params?: Record<string,string>;\n    };\n    // arbitrary metadata used by plugins\n    meta?: Record<string, any>;\n  }\n\n- export type HookHandler<T extends HookPoint = HookPoint, R = unknown> = (ctx: HookContext) => R | Promise<R>;\n\nRegistry API\n- export class HookRegistry {\n    // register a handler for a specific HookPoint\n    public register<K extends HookPoint>(hook: K, handler: HookHandler<K>): () => void {\n      // returns an unregister function\n    }\n\n    // run handlers for a hook; returns results in order\n    public async run<K extends HookPoint, R = unknown>(hook: K, ctx: HookContext): Promise<R[]> {\n      // call handlers sequentially or in parallel depending on hook; default: sequential to allow mutation of ctx\n    }\n\n    // clear all handlers (useful for tests)\n    public clear(): void {}\n  }\n\nPre-registered standard hooks\n- beforeApiRequest: runs before each API request; handlers can modify ctx.request (headers, body) to add authentication tokens or tracing headers.\n- afterApiResponse: runs after successful or error responses; handlers receive ctx.response and can transform or record metrics.\n- onLogin: runs after a successful login with ctx.user present.\n- onLogout: runs after logout.\n- onRouteChange: runs when the router notifies a route change; can block or redirect by setting ctx.meta.redirect.\n\nSingleton & usage\n- export const hooks = new HookRegistry();\n\nExample usage\n- Register a hook:\n  import { hooks } from '@/core/hooks';\n  const unregister = hooks.register('beforeApiRequest', (ctx) => {\n    // add auth header\n    if (!ctx.request) return;\n    ctx.request.headers = { ...(ctx.request.headers || {}), 'x-app-version': '0.0.1' };\n  });\n\n- Running hooks inside apiClient:\n  await hooks.run('beforeApiRequest', { request });\n  const response = await fetch(...);\n  await hooks.run('afterApiResponse', { request, response: { raw: response } });\n\nIntegration points\n- src/services/apiClient.ts should call hooks.run('beforeApiRequest', ctx) before sending requests and hooks.run('afterApiResponse', ctx) after receiving responses.\n- AuthProvider should call hooks.run('onLogin', { user }) and hooks.run('onLogout', { user: null }).\n- Router can call hooks.run('onRouteChange', { route: { from, to } }) on navigation changes.\n\nTesting and mockability\n- HookRegistry.clear() should be used in tests to reset global state between runs."}, {'id': 'core-utils', 'file_path': 'src/core/utils.ts', 'description': 'Common utilities used across the app (formatDate, safeParseJson, buildUrl, noop, classNames).', 'dependencies': [], 'exports': ['formatDate', 'safeParseJson', 'buildUrl', 'classNames'], 'priority': 1, 'purpose': 'Common utilities used across the application: date formatting, safe JSON parsing, URL builder, className helper and small debug helpers. Keep these small and dependency-free for use in both browser and test environments.', 'content': 'Summary\n- Purpose: lightweight utility helpers used by components, services and tests.\n- Conventions: functions are pure and have narrow responsibilities. Prefer small, well-documented helpers rather than large utility libraries.\n\nFunctions to implement (signatures & behavior)\n\n1) formatDate\n- export function formatDate(isoOrDate: string | Date, locale = \'en-US\'): string;\n- Description: returns a short date (e.g., "Jan 10, 2024") while handling invalid input gracefully by returning \'\' (empty string).\n\n2) formatDateTime\n- export function formatDateTime(isoOrDate: string | Date, locale = \'en-US\'): string;\n- Description: returns a localized date + time string.\n\n3) safeParseJson\n- export function safeParseJson<T = any>(input: string, fallback?: T): T;\n- Description: parses JSON and returns fallback on parse error.\n\n4) safeStringify\n- export function safeStringify(obj: unknown): string;\n- Description: Safe stringify that handles cyclic structures by replacing cycles with \'[Circular]\'.\n\n5) buildUrl\n- export function buildUrl(base: string, path?: string, params?: Record<string, string | number | boolean | undefined>): string;\n- Description: join base + path and append query string from params. Skip undefined values.\n\n6) noop\n- export const noop = (): void => {};\n\n7) classNames\n- export function classNames(...parts: Array<string | false | null | undefined | Record<string, boolean>>): string;\n- Description: small helper to join class names (handles object maps and booleans).\n\n8) assert\n- export function assert(condition: any, message?: string): asserts condition;\n- Description: throw Error when condition falsy; useful to narrow types in code paths.\n\nExamples & usage\n- import { formatDate, buildUrl } from \'@/core/utils\';\n- buildUrl(API_BASE_URL, \'/appointments\', { page: 1, pageSize: 20 });\n- safeParseJson<{ id: string }>(maybeJson, { id: \'unknown\' });\n\nIntegration points\n- Use formatDate in UI components (shared components and pages).\n- Use buildUrl in apiClient to create request URLs safely.\n- safeParseJson used in places where backend responses may be malformed (local caches, localStorage).\n\nTesting\n- Each function is pure and trivial to unit test with typical inputs and edge cases (invalid ISO strings, null/undefined params, cyclic objects for safeStringify).\n\nImplementation notes\n- Keep dependencies minimal (no external libraries). Use URL and URLSearchParams where available for robust query building.'}, {'id': 'global-styles', 'file_path': 'src/styles/index.css', 'description': 'Global CSS / utility imports (tailwind preflight or global resets). Imported by main.tsx.', 'dependencies': [], 'exports': ['global styles'], 'priority': 1}, {'id': 'hook-use-auth', 'file_path': 'src/hooks/useAuth.ts', 'description': 'Hook that exposes auth context and convenience auth helpers for components (isAuthenticated, login, logout, currentUser). Uses AuthProvider context and useAuthStore.', 'dependencies': ['src/state/useAuthStore.ts', 'src/services/authService.ts'], 'exports': ['useAuth'], 'priority': 1}, {'id': 'hook-use-debounce', 'file_path': 'src/hooks/useDebounce.ts', 'description': 'Utility hook to debounce a value or callback (used by inputs/search fields).', 'dependencies': [], 'exports': ['useDebounce'], 'priority': 1}, {'id': 'hook-use-fetch', 'file_path': 'src/hooks/useFetch.ts', 'description': 'A small hook to call services with built-in loading / error state. Can be a wrapper around React Query or fetch for simple local requests.', 'dependencies': ['src/services/apiClient.ts'], 'exports': ['useFetch'], 'priority': 1}, {'id': 'hook-use-form', 'file_path': 'src/hooks/useForm.ts', 'description': 'Small reusable form hook building on React Hook Form patterns: register, handleSubmit, form state helpers (lightweight abstraction).', 'dependencies': [], 'exports': ['useForm'], 'priority': 1}, {'id': 'main-entry', 'file_path': 'src/main.tsx', 'description': 'Application entry point. Hydrates React root, composes top-level providers (QueryProvider, AuthProvider, ThemeProvider) and mounts App component. Imports global styles.', 'dependencies': ['src/app/App.tsx', 'src/providers/QueryProvider.tsx', 'src/providers/AuthProvider.tsx', 'src/providers/ThemeProvider.tsx', 'src/styles/index.css'], 'exports': ['default'], 'priority': 1}, {'id': 'query-provider', 'file_path': 'src/providers/QueryProvider.tsx', 'description': 'Wraps the React Query client provider and configures default caching/ retry policies. Central point to tune query behavior and devtools.', 'dependencies': [], 'exports': ['ReactQueryProvider'], 'priority': 1}, {'id': 'theme-provider', 'file_path': 'src/providers/ThemeProvider.tsx', 'description': 'App theme provider (light/dark) and theme toggler. Exposes ThemeContext to UI components.', 'dependencies': [], 'exports': ['ThemeProvider', 'useTheme'], 'priority': 1}, {'id': 'todo-service', 'file_path': 'src/services/todoService.ts', 'description': 'Example domain service for fetching/updating todo items or app-specific data. Uses apiClient.', 'dependencies': ['src/services/apiClient.ts'], 'exports': ['fetchTodos', 'createTodo', 'updateTodo', 'deleteTodo'], 'priority': 1}, {'id': 'use-auth-store', 'file_path': 'src/state/useAuthStore.ts', 'description': 'Lightweight local store for auth session (token, user). Provides simple persistent methods (sessionStorage) and convenience selectors.', 'dependencies': ['src/services/authService.ts'], 'exports': ['useAuthStore', 'AuthState'], 'priority': 1}, {'id': 'user-service', 'file_path': 'src/services/userService.ts', 'description': 'User-related API calls (get profile, update profile). Uses apiClient.', 'dependencies': ['src/services/apiClient.ts'], 'exports': ['getUserProfile', 'updateUserProfile'], 'priority': 1}, {'id': 'component-button', 'file_path': 'src/shared/components/Button.tsx', 'description': 'Accessible button primitive used across the app. Accepts variant, size, disabled, icon props.', 'dependencies': [], 'exports': ['Button'], 'priority': 2}, {'id': 'component-footer', 'file_path': 'src/shared/components/Footer.tsx', 'description': 'Simple footer for the application.', 'dependencies': [], 'exports': ['Footer'], 'priority': 2}, {'id': 'component-header', 'file_path': 'src/shared/components/Header.tsx', 'description': 'Application header with navigation links, brand and auth controls. Uses useAuth hook to show login/logout.', 'dependencies': ['src/hooks/useAuth.ts', 'src/shared/components/Button.tsx'], 'exports': ['Header'], 'priority': 2}, {'id': 'component-icon', 'file_path': 'src/shared/components/Icon.tsx', 'description': 'Small icon wrapper for consistent sizing and accessible icons. Exports a set of simple icons or an Icon component consuming SVG paths.', 'dependencies': [], 'exports': ['Icon'], 'priority': 2}, {'id': 'component-input', 'file_path': 'src/shared/components/Input.tsx', 'description': 'Text input primitive with label, error, and optional debounced onChange support.', 'dependencies': ['src/hooks/useDebounce.ts'], 'exports': ['Input'], 'priority': 2}, {'id': 'component-layout', 'file_path': 'src/shared/components/Layout.tsx', 'description': 'Top-level app layout component composing Header, Footer and main content area. Used by pages to provide consistent shell.', 'dependencies': ['src/shared/components/Header.tsx', 'src/shared/components/Footer.tsx'], 'exports': ['Layout'], 'priority': 2}, {'id': 'component-spinner', 'file_path': 'src/shared/components/Spinner.tsx', 'description': 'Small loading spinner used throughout the app.', 'dependencies': [], 'exports': ['Spinner'], 'priority': 2}, {'id': 'page-dashboard', 'file_path': 'src/pages/DashboardPage.tsx', 'description': 'Protected dashboard page that lists domain data (e.g., todos). Uses React Query / useFetch and todoService.', 'dependencies': ['src/shared/components/Layout.tsx', 'src/services/todoService.ts', 'src/hooks/useFetch.ts', 'src/shared/components/Spinner.tsx'], 'exports': ['DashboardPage'], 'priority': 3}, {'id': 'page-home', 'file_path': 'src/pages/HomePage.tsx', 'description': 'Public home page. Lightweight landing page that may show summary data or links to features.', 'dependencies': ['src/shared/components/Layout.tsx'], 'exports': ['HomePage'], 'priority': 3}, {'id': 'page-login', 'file_path': 'src/pages/LoginPage.tsx', 'description': 'Login page with form. Uses authService or useAuth hook to perform login and redirect upon success.', 'dependencies': ['src/shared/components/Layout.tsx', 'src/hooks/useAuth.ts', 'src/services/authService.ts', 'src/shared/components/Input.tsx', 'src/shared/components/Button.tsx', 'src/hooks/useForm.ts'], 'exports': ['LoginPage'], 'priority': 3}, {'id': 'page-not-found', 'file_path': 'src/pages/NotFoundPage.tsx', 'description': 'Fallback 404 page shown for unknown routes.', 'dependencies': ['src/shared/components/Layout.tsx'], 'exports': ['NotFoundPage'], 'priority': 3}, {'id': 'page-profile', 'file_path': 'src/pages/ProfilePage.tsx', 'description': "Protected user profile page that fetches and edits the current user's profile via userService.", 'dependencies': ['src/shared/components/Layout.tsx', 'src/services/userService.ts', 'src/hooks/useAuth.ts', 'src/shared/components/Input.tsx', 'src/shared/components/Button.tsx'], 'exports': ['ProfilePage'], 'priority': 3}], 'file_paths': ['src/services/apiClient.ts', 'src/app/config.ts', 'src/app/App.tsx', 'src/app/router.tsx', 'src/providers/AuthProvider.tsx', 'src/services/authService.ts', 'src/core/contracts.ts', 'src/core/di.ts', 'src/core/events.ts', 'src/core/hooks.ts', 'src/core/utils.ts', 'src/styles/index.css', 'src/hooks/useAuth.ts', 'src/hooks/useDebounce.ts', 'src/hooks/useFetch.ts', 'src/hooks/useForm.ts', 'src/main.tsx', 'src/providers/QueryProvider.tsx', 'src/providers/ThemeProvider.tsx', 'src/services/todoService.ts', 'src/state/useAuthStore.ts', 'src/services/userService.ts', 'src/shared/components/Button.tsx', 'src/shared/components/Footer.tsx', 'src/shared/components/Header.tsx', 'src/shared/components/Icon.tsx', 'src/shared/components/Input.tsx', 'src/shared/components/Layout.tsx', 'src/shared/components/Spinner.tsx', 'src/pages/DashboardPage.tsx', 'src/pages/HomePage.tsx', 'src/pages/LoginPage.tsx', 'src/pages/NotFoundPage.tsx', 'src/pages/ProfilePage.tsx'], 'descriptions': ['Thin wrapper around fetch (or global HTTP client) that applies baseUrl, auth headers, error handling and response parsing. Used by all services.', 'Materialized configuration for the application: runtime values such as API_BASE_URL, environment flags, feature toggles. Exported constants used by apiClient and other services.', 'Root application component. Provides app-level shell and renders Router. Reads light config if needed.', 'Central router component that declares routes and lazy-loads pages. Handles protected routes using AuthProvider / useAuth.', 'Context provider for authentication state and session lifecycle. Uses useAuthStore and authService to persist session and expose login/logout functions to the app.', 'Auth-related service: login, logout, refresh token, current user retrieval. Uses apiClient to communicate with backend.', 'Domain types, API request/response contracts and shared TypeScript interfaces used across the app (User, Auth tokens, Todo, API error shapes).', 'Simple dependency resolver / DI container for swapping implementations in tests. Allows registering services by token and resolving them.', 'Small in-process event bus for cross-cutting events (e.g., auth:login, auth:logout). Minimal pub/sub API used by providers and utilities.', 'Registry and types for extension hooks. Lightweight place to declare app-level hook contracts used by plugins/extensions.', 'Common utilities used across the app (formatDate, safeParseJson, buildUrl, noop, classNames).', 'Global CSS / utility imports (tailwind preflight or global resets). Imported by main.tsx.', 'Hook that exposes auth context and convenience auth helpers for components (isAuthenticated, login, logout, currentUser). Uses AuthProvider context and useAuthStore.', 'Utility hook to debounce a value or callback (used by inputs/search fields).', 'A small hook to call services with built-in loading / error state. Can be a wrapper around React Query or fetch for simple local requests.', 'Small reusable form hook building on React Hook Form patterns: register, handleSubmit, form state helpers (lightweight abstraction).', 'Application entry point. Hydrates React root, composes top-level providers (QueryProvider, AuthProvider, ThemeProvider) and mounts App component. Imports global styles.', 'Wraps the React Query client provider and configures default caching/ retry policies. Central point to tune query behavior and devtools.', 'App theme provider (light/dark) and theme toggler. Exposes ThemeContext to UI components.', 'Example domain service for fetching/updating todo items or app-specific data. Uses apiClient.', 'Lightweight local store for auth session (token, user). Provides simple persistent methods (sessionStorage) and convenience selectors.', 'User-related API calls (get profile, update profile). Uses apiClient.', 'Accessible button primitive used across the app. Accepts variant, size, disabled, icon props.', 'Simple footer for the application.', 'Application header with navigation links, brand and auth controls. Uses useAuth hook to show login/logout.', 'Small icon wrapper for consistent sizing and accessible icons. Exports a set of simple icons or an Icon component consuming SVG paths.', 'Text input primitive with label, error, and optional debounced onChange support.', 'Top-level app layout component composing Header, Footer and main content area. Used by pages to provide consistent shell.', 'Small loading spinner used throughout the app.', 'Protected dashboard page that lists domain data (e.g., todos). Uses React Query / useFetch and todoService.', 'Public home page. Lightweight landing page that may show summary data or links to features.', 'Login page with form. Uses authService or useAuth hook to perform login and redirect upon success.', 'Fallback 404 page shown for unknown routes.', "Protected user profile page that fetches and edits the current user's profile via userService."], 'total_files': 34}