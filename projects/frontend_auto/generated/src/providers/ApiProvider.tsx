{'architecture': {'overview': 'A modular React 18+ application built with TypeScript, featuring a lightweight core kernel (contracts, events, DI, hooks, utils) and a plugin-like federation of providers, services, shared components, hooks, features, and pages. The App is bootstrapped through a central AppProviders and a Router, with a ThemeProvider and API layer wired through a minimal DI/event bus for extensibility. Features are implemented as self-contained modules (dashboard, auth) that expose components used by pages. State management is lightweight (React context where needed, optional small store) and API communication is handled by a simple API client with typed contracts.', 'patterns': ['Kernel-first architecture with a minimal Dependency Injection (DI) container', 'Event Bus for decoupled communication', 'Hook Registry for extensibility points (per-core hooks.ts)', 'Feature-based module structure (features/*) with pages consuming feature components', 'Container/Presentational philosophy for shared components', 'Type-safe API contracts and responses'], 'data_flow': 'UI components render with props and consume context/providers. Pages request data via services (via apiClient) or hooks (useApiQuery). Data flows back through UI via callbacks. The core kernel exposes contracts and utilities used by all layers. The AppProviders wire Theme, API context, and Auth providers. The router maps paths to pages, which compose shared components and feature components. Events are published/subscribed through the Event Bus for cross-cutting concerns (e.g., auth changes, global notifications).', 'folder_structure': 'src/\n  core/\n    contracts.ts\n    events.ts\n    hooks.ts\n    di.ts\n    utils.ts\n  app/\n    config.ts\n    bootstrap.ts\n    AppProviders.tsx\n    router.tsx\n  providers/\n    ThemeProvider.tsx\n    ApiProvider.tsx\n  services/\n    apiClient.ts\n    userService.ts\n    productService.ts\n  hooks/\n    useLocalStorage.ts\n    useApiQuery.ts\n  shared/\n    components/\n      Button.tsx\n      Card.tsx\n      Input.tsx\n      Modal.tsx\n      Toast.tsx\n  features/\n    dashboard/\n      DashboardLayout.tsx\n      MetricCard.tsx\n    auth/\n      LoginForm.tsx\n  pages/\n    HomePage.tsx\n    LoginPage.tsx\n    DashboardPage.tsx\n    NotFoundPage.tsx\n  main.tsx', 'tech_stack': ['React 18+', 'TypeScript', 'React Router v6', 'Axios (apiClient)', 'Material UI v5 or custom theme (ThemeProvider)', 'Context/Lightweight state management (optional Zustand or React Context)', 'Event Bus and simple DI container (kernel-level primitives)']}, 'kernel_specs': {'overview': 'Core Kernel: a small, type-safe foundation powering all sections. It provides domain contracts, a materialized app config with feature flags, a decoupled event bus, a hook registry for extensibility points, and a tiny DI container. These primitives are designed to be lightweight, deterministic, and easily mockable for tests or development.'}, 'sections': [{'id': 'api-provider', 'file_path': 'src/providers/ApiProvider.tsx', 'description': 'Provides the API client context to the app and optionally global cross-cutting concerns (auth tokens, interceptors).', 'dependencies': ['src/services/apiClient.ts', 'src/core/events.ts'], 'exports': ['ApiProvider', 'useApiClient'], 'priority': 1}, {'id': 'app-providers', 'file_path': 'src/app/AppProviders.tsx', 'description': 'Root providers wrapper that composes ThemeProvider, ApiProvider, AuthProvider, and any global contexts.', 'dependencies': ['src/providers/ThemeProvider.tsx', 'src/providers/ApiProvider.tsx', 'src/core/events.ts', 'src/app/config.ts'], 'exports': ['AppProviders'], 'priority': 1}, {'id': 'app-router', 'file_path': 'src/app/router.tsx', 'description': 'Routing configuration using React Router v6. Maps paths to pages (Home, Login, Dashboard, NotFound).', 'dependencies': ['src/pages/HomePage.tsx', 'src/pages/LoginPage.tsx', 'src/pages/DashboardPage.tsx', 'src/pages/NotFoundPage.tsx'], 'exports': ['AppRouter'], 'priority': 1}, {'id': 'bootstrap', 'file_path': 'src/app/bootstrap.ts', 'description': 'Initialization helpers (e.g., register core hooks, initialize DI, perform preflight checks).', 'dependencies': ['src/core/di.ts', 'src/core/events.ts', 'src/app/config.ts'], 'exports': ['initializeApp'], 'priority': 1}, {'id': 'main-entry', 'file_path': 'src/main.tsx', 'description': 'Application bootstrap file. Mounts the root React tree and wires AppProviders with the router.', 'dependencies': ['src/app/AppProviders.tsx', 'src/app/router.tsx', 'src/app/bootstrap.ts'], 'exports': ['renderApp'], 'priority': 1}, {'id': 'theme-provider', 'file_path': 'src/providers/ThemeProvider.tsx', 'description': 'Theme wrapper (Material UI or custom theme) for consistent styling across the app.', 'dependencies': ['src/app/config.ts'], 'exports': ['ThemeProvider', 'useAppTheme'], 'priority': 1}, {'id': 'api-client', 'file_path': 'src/services/apiClient.ts', 'description': 'Typed API client (axios-based) with baseURL and common request/response handling.', 'dependencies': [], 'exports': ['apiClient'], 'priority': 2}, {'id': 'api-query-hook', 'file_path': 'src/hooks/useApiQuery.ts', 'description': 'Lightweight data-fetch hook leveraging apiClient for simple query usage.', 'dependencies': ['src/services/apiClient.ts'], 'exports': ['useApiQuery'], 'priority': 2}, {'id': 'btn-component', 'file_path': 'src/shared/components/Button.tsx', 'description': 'Reusable button component with theming and common variants.', 'dependencies': [], 'exports': ['Button', 'ButtonProps'], 'priority': 2}, {'id': 'card-component', 'file_path': 'src/shared/components/Card.tsx', 'description': 'Generic Card container used by dashboards and forms.', 'dependencies': [], 'exports': ['Card', 'CardProps'], 'priority': 2}, {'id': 'dashboard-layout', 'file_path': 'src/features/dashboard/DashboardLayout.tsx', 'description': 'Layout component for dashboard pages, composing cards and panels.', 'dependencies': ['src/shared/components/Card.tsx', 'src/shared/components/Button.tsx'], 'exports': ['DashboardLayout'], 'priority': 2}, {'id': 'dashboard-metric', 'file_path': 'src/features/dashboard/MetricCard.tsx', 'description': 'Metric card component used inside dashboards.', 'dependencies': ['src/shared/components/Card.tsx'], 'exports': ['MetricCard'], 'priority': 2}, {'id': 'input-component', 'file_path': 'src/shared/components/Input.tsx', 'description': 'Input field component with label and error support.', 'dependencies': [], 'exports': ['Input', 'InputProps'], 'priority': 2}, {'id': 'local-storage-hook', 'file_path': 'src/hooks/useLocalStorage.ts', 'description': 'Custom hook to persist state in localStorage with a simple API.', 'dependencies': [], 'exports': ['useLocalStorage'], 'priority': 2}, {'id': 'login-form', 'file_path': 'src/features/auth/LoginForm.tsx', 'description': 'Login form component used by Login page and potential modal flows.', 'dependencies': ['src/shared/components/Input.tsx', 'src/shared/components/Button.tsx'], 'exports': ['LoginForm'], 'priority': 2}, {'id': 'modal-component', 'file_path': 'src/shared/components/Modal.tsx', 'description': 'Modal provider for blocking dialogs and popups.', 'dependencies': [], 'exports': ['Modal', 'ModalProps'], 'priority': 2}, {'id': 'product-service', 'file_path': 'src/services/productService.ts', 'description': 'Product-related API interactions (fetch product list).', 'dependencies': ['src/services/apiClient.ts'], 'exports': ['fetchProducts'], 'priority': 2}, {'id': 'toast-component', 'file_path': 'src/shared/components/Toast.tsx', 'description': 'Toast/notification utility component.', 'dependencies': [], 'exports': ['Toast', 'toast'], 'priority': 2}, {'id': 'user-service', 'file_path': 'src/services/userService.ts', 'description': 'User-related API interactions (login, fetch current user).', 'dependencies': ['src/services/apiClient.ts'], 'exports': ['login', 'fetchCurrentUser'], 'priority': 2}, {'id': 'app-config', 'file_path': 'src/app/config.ts', 'description': 'Materialized runtime configuration (endpoints, feature flags, defaults) consumed by providers and app bootstrap.', 'dependencies': ['src/core/contracts.ts'], 'exports': ['APP_CONFIG', 'FeatureFlags'], 'priority': 3, 'purpose': 'Materialized runtime configuration. Exposes APP_CONFIG, computed feature flags, development helpers, and mock data when enabled.', 'content': '"use strict";\n\nimport type { User } from \'@/core/contracts\';\n\n// Known feature keys used by the app. Extend as new features roll in.\nexport type FeatureKey = \'dashboard\' | \'auth\' | \'notifications\' | \'reports\' | \'settings\';\n\nexport interface AppConfigShape {\n  environment: \'development\' | \'production\' | \'staging\';\n  apiBaseUrl: string;\n  features: FeatureKey[];\n  developmentMode?: {\n    enableMockData?: boolean;\n    logApiRequests?: boolean;\n  };\n  ui?: {\n    theme?: \'light\' | \'dark\';\n    locale?: string;\n  };\n  auth?: {\n    requireEmailVerification?: boolean;\n  };\n}\n\n// Materialized config. In real apps, this could be populated from process.env or a config service.\nexport const APP_CONFIG: AppConfigShape = {\n  environment: \'development\',\n  apiBaseUrl: \'https://api.dev.local\',\n  features: [\'dashboard\', \'auth\', \'notifications\'],\n  developmentMode: {\n    enableMockData: true,\n    logApiRequests: true\n  },\n  ui: {\n    theme: \'dark\',\n    locale: \'en-US\'\n  },\n  auth: {\n    requireEmailVerification: false\n  }\n};\n\n// Feature flags derived from APP_CONFIG.features. Keeps runtime checks centralized\nexport type FeatureFlags = {\n  dashboard: boolean;\n  auth: boolean;\n  notifications: boolean;\n  reports: boolean;\n  settings: boolean;\n};\n\nexport const FeatureFlags: FeatureFlags = {\n  dashboard: APP_CONFIG.features.includes(\'dashboard\'),\n  auth: APP_CONFIG.features.includes(\'auth\'),\n  notifications: APP_CONFIG.features.includes(\'notifications\'),\n  reports: APP_CONFIG.features.includes(\'reports\'),\n  settings: APP_CONFIG.features.includes(\'settings\')\n};\n\n// Convenience computed flags\nexport const isDevelopment = APP_CONFIG.environment === \'development\';\nexport const shouldUseMockData = Boolean(APP_CONFIG.developmentMode?.enableMockData);\n\n// Basic mock user data for development. Cast to the app\'s User type when enabled.\nexport const MOCK_CURRENT_USER: User | null = shouldUseMockData\n  ? {\n      id: \'mock-user-001\',\n      name: \'Mock User\',\n      email: \'mock.user@example.dev\',\n      role: \'patient\', // matches core/contracts Patient shape\n      patientId: \'P-0001\'\n    }\n  : null;\n'}, {'id': 'core-contracts', 'file_path': 'src/core/contracts.ts', 'description': 'Domain types and API contracts shared across the app. Defines generic API response shapes and basic domain models used by services and components.', 'dependencies': [], 'exports': ['ApiResponse', 'ApiError', 'User', 'Product', 'PaginatedResult'], 'priority': 3, 'purpose': 'Domain types and API contracts shared across the app. Defines user roles, healthcare domain models, and standard API response shapes.', 'content': '"use strict";\n\n// Core domain contracts used across services, hooks, and UI components.\n// Authoritative source of truth for domain models and API contracts.\n\n// 1) User domain models (based on roles used by the app).\\n//    The roles are expressed as discriminated unions so we can narrow types safely in UI/services.\\nexport type BaseUser = { id: string; name: string; email: string; };\n\nexport type Patient = BaseUser & { role: \'patient\'; patientId?: string; };\nexport type Doctor  = BaseUser & { role: \'doctor\';  specialty?: string; };\nexport type Nurse   = BaseUser & { role: \'nurse\';   department?: string; };\n\nexport type User = Patient | Doctor | Nurse;\n\n// 2) Healthcare domain models (simplified for core usage)\nexport interface Appointment {\n  id: string;\n  patientId: string;\n  doctorId: string;\n  time: string; // ISO timestamp or local date-time string\n  status: \'scheduled\' | \'completed\' | \'cancelled\' | \'no-show\';\n  reason?: string;\n}\n\nexport interface Prescription {\n  id: string;\n  patientId: string;\n  doctorId: string;\n  medicationName: string;\n  dosage: string;\n  instructions?: string;\n  date?: string; // ISO date\n}\n\nexport interface LabResult {\n  id: string;\n  patientId: string;\n  testName: string;\n  value: string;\n  unit?: string;\n  referenceRange?: string;\n  date?: string;\n}\n\nexport interface MedicalRecord {\n  id: string;\n  patientId: string;\n  diagnoses: string[];\n  allergies?: string[];\n  medications?: Prescription[];\n  notes?: string;\n  lastUpdated?: string;\n}\n\n// 3) API contracts\nexport interface ApiError {\n  code?: string;\n  message: string;\n  details?: unknown;\n}\n\n// Simple discriminated union for API results\nexport type ApiResult<T> =\n  | { success: true; data: T }\n  | { success: false; error: ApiError };\n\nexport interface PaginatedResponse<T> {\n  items: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n  totalPages: number;\n}\n\nexport interface PaginatedResult<T> extends PaginatedResponse<T> {}\n\n// 4) General UI state helpers\nexport type LoadingState = \'idle\' | \'loading\' | \'success\' | \'error\';\nexport type FormState = \'idle\' | \'validating\' | \'submitting\' | \'submitted\' | \'error\';\n\n// 5) Optional WebSocket event typings (when WebSocket is enabled in config)\nexport type WebSocketEventMap = {\n  \'ws:connect\': void;\n  \'ws:message\': { event: string; payload?: any };\n  \'ws:disconnect\': { reason?: string };\n};\nexport type WebSocketEvent = { type: string; payload?: any };\n\n// 6) Example usage (usage patterns are provided in kernel docs and in @/core/* imports)\n// Example: composing an API call and handling errors\n// import { ApiResult, Patient } from \'@/core/contracts\';\n// function handleApi<T>(r: ApiResult<T>) { if (r.success) { /* use r.data */ } else { /* log r.error.message */ } }\n'}, {'id': 'core-di', 'file_path': 'src/core/di.ts', 'description': 'Minimal Dependency Injection container to instantiate and provide core services.', 'dependencies': [], 'exports': ['DIContainer', 'registerService', 'resolveService'], 'priority': 3, 'purpose': 'Minimal Dependency Injection container with token definitions and type-safe resolution. Exposes registerService and resolveService helpers for other kernel pieces.', 'content': '"use strict";\n\n// Dependency Injection tokens for core services\nexport const TOKENS = {\n  ApiClient: Symbol(\'ApiClient\'),\n  AuthService: Symbol(\'AuthService\'),\n  StorageService: Symbol(\'StorageService\'),\n  WebSocketService: Symbol(\'WebSocketService\')\n} as const;\n\nexport type Token = typeof TOKENS[keyof typeof TOKENS];\n\ntype Provider<T> = () => T;\n\nexport class DIContainer {\n  private registry = new Map<Token, Provider<any>>();\n\n  register<T>(token: Token, provider: Provider<T>): void {\n    this.registry.set(token, provider);\n  }\n\n  registerInstance<T>(token: Token, instance: T): void {\n    this.registry.set(token, () => instance);\n  }\n\n  resolve<T>(token: Token): T {\n    const provider = this.registry.get(token);\n    if (!provider) {\n      throw new Error(`DI: No provider registered for token ${String(token)}`);\n    }\n    // Provider returns T when invoked. If a lazy instance is stored, call it.\n    const result = (provider as any)();\n    return result as T;\n  }\n}\n\n// Global DI container singleton\nexport const DI = new DIContainer();\n\nexport function registerService<T>(token: Token, provider: Provider<T>): void {\n  DI.register<T>(token, provider);\n}\n\nexport function resolveService<T>(token: Token): T {\n  return DI.resolve<T>(token);\n}\n'}, {'id': 'core-events', 'file_path': 'src/core/events.ts', 'description': 'Lightweight event bus for decoupled communication between parts of the app (publish/subscribe).', 'dependencies': [], 'exports': ['EventBus', 'EventHandler'], 'priority': 3, 'purpose': 'Lightweight, typed event bus for decoupled communication between app parts. Exposes a singleton bus for domain events.', 'content': '"use strict";\n\nimport type { User } from \'@/core/contracts\';\n\n// Core event map for domain events. Extend with new events as the app grows.\nexport type CoreEventMap = {\n  // Auth lifecycle events\n  \'auth:login\': { user: User };\n  \'auth:logout\': { reason?: string };\n  // Navigation / routing\n  \'route:change\': { path: string; previousPath?: string };\n  // Global notifications\n  \'notification:toast\': { message: string; type?: \'success\'|\'error\'|\'info\' };\n  // Data mutations\n  \'data:updated\': { entity: string; id?: string | number };\n};\n\ntype Handler<T> = (payload: T) => void | Promise<void>;\n\nexport class EventBus<EM extends Record<string, any> = CoreEventMap> {\n  private listeners: Map<string, Set<Handler<any>>> = new Map();\n\n  on<K extends keyof EM>(event: K, handler: (payload: EM[K]) => void | Promise<void>): void {\n    const key = event as string;\n    if (!this.listeners.has(key)) {\n      this.listeners.set(key, new Set());\n    }\n    // @ts-ignore\n    this.listeners.get(key)!.add(handler as Handler<any>);\n  }\n\n  off<K extends keyof EM>(event: K, handler: (payload: EM[K]) => void | Promise<void>): void {\n    const key = event as string;\n    const set = this.listeners.get(key);\n    if (!set) return;\n    set.delete(handler as Handler<any>);\n  }\n\n  async emit<K extends keyof EM>(event: K, payload: EM[K]): Promise<void> {\n    const key = event as string;\n    const set = this.listeners.get(key);\n    if (!set || set.size === 0) return;\n    const promises: Promise<void>[] = [];\n    for (const handler of Array.from(set)) {\n      try {\n        const r = (handler as any)(payload);\n        if (r instanceof Promise) promises.push(r);\n      } catch {\n        // swallow to avoid breaking other listeners\n      }\n    }\n    await Promise.all(promises);\n  }\n}\n\n// Public singleton instance for global event communication\nexport const eventBus = new EventBus<CoreEventMap>();\n'}, {'id': 'core-hooks', 'file_path': 'src/core/hooks.ts', 'description': 'Hook registry to enable extensibility points across the app (register/use hooks at runtime).', 'dependencies': [], 'exports': ['HookRegistry', 'useHook'], 'priority': 3, 'purpose': 'Hook registry enabling extensibility points across the app. Provides a typed mapping of hook points to payloads and a simple API to register and run hooks.', 'content': '"use strict";\n\nimport type { User } from \'@/core/contracts\';\n\n// Hook payload definitions. Extend when introducing new hook points.\ntype HookPayloadMap = {\n  beforeApiRequest: { url: string; options?: any };\n  afterApiResponse: { status: number; data?: any };\n  onLogin: { user: User };\n  onLogout: { user?: User; reason?: string };\n  onRouteChange: { path: string; previousPath?: string };\n};\n\nexport type HookPoint = keyof HookPayloadMap;\n\ntype HookHandlerMap = {\n  [K in HookPoint]: (payload: HookPayloadMap[K], ctx: HookContext) => void | Promise<void>\n};\n\nexport type HookContext = {\n  timestamp: number;\n  source?: string;\n  [key: string]: any;\n};\n\nexport class HookRegistry {\n  private registry = new Map<HookPoint, Array<(payload: any, ctx: HookContext) => void | Promise<void>>>();\n\n  register<K extends HookPoint>(hook: K, fn: (payload: HookPayloadMap[K], ctx: HookContext) => void | Promise<void>): void {\n    const arr = this.registry.get(hook) ?? [];\n    arr.push(fn as any);\n    this.registry.set(hook, arr);\n  }\n\n  async run<K extends HookPoint>(hook: K, payload: HookPayloadMap[K] | undefined, ctx: HookContext): Promise<void> {\n    const handlers = this.registry.get(hook) ?? [];\n    for (const h of handlers) {\n      await (h as any)(payload, ctx);\n    }\n  }\n}\n\n// Global singleton for kernel hooks\nexport const globalHookRegistry = new HookRegistry();\n\n// Simple helper to invoke hooks without directly touching registry instance\nexport async function useHook<K extends HookPoint>(hook: K, payload: HookPayloadMap[K] | undefined, ctx?: HookContext, registry: HookRegistry = globalHookRegistry): Promise<void> {\n  const c: HookContext = ctx ?? { timestamp: Date.now(), source: \'kernel\' };\n  await registry.run<K>(hook, payload, c);\n}\n'}, {'id': 'core-utils', 'file_path': 'src/core/utils.ts', 'description': 'Common utilities used across the app (debounce, delay, formatters, etc.).', 'dependencies': [], 'exports': ['delay', 'formatDate', 'clsx'], 'priority': 3, 'purpose': 'Small, battle-tested utilities used across the codebase. Lightweight, dependency-free implementations.', 'content': '"use strict";\n\n/** Simple delay utility */\nexport function delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/** Basic date formatter with a tiny subset of patterns. Defaults to ISO-ish output. */\nexport function formatDate(input: Date | string | number, pattern: string = \'YYYY-MM-DD HH:mm:ss\'): string {\n  const d = typeof input === \'object\' ? (input as Date) : new Date(input as any);\n  const pad = (n: number) => (n < 10 ? \'0\' + n : \'\' + n);\n  const yyyy = d.getFullYear();\n  const MM = pad(d.getMonth() + 1);\n  const dd = pad(d.getDate());\n  const HH = pad(d.getHours());\n  const mm = pad(d.getMinutes());\n  const ss = pad(d.getSeconds());\n\n  return pattern\n    .replace(\'YYYY\', String(yyyy))\n    .replace(\'MM\', MM)\n    .replace(\'DD\', dd)\n    .replace(\'HH\', HH)\n    .replace(\'mm\', mm)\n    .replace(\'ss\', ss);\n}\n\n/** Tiny classnames helper */\nexport function clsx(...args: (string | false | null | undefined)[]): string {\n  return args.filter((a) => !!a).join(\' \');\n}\n'}, {'id': 'dashboard-page', 'file_path': 'src/pages/DashboardPage.tsx', 'description': 'Dashboard page that assembles the DashboardLayout with metrics and panels.', 'dependencies': ['src/features/dashboard/DashboardLayout.tsx', 'src/features/dashboard/MetricCard.tsx'], 'exports': ['DashboardPage'], 'priority': 3}, {'id': 'home-page', 'file_path': 'src/pages/HomePage.tsx', 'description': 'Landing page composing hero and quick actions.', 'dependencies': ['src/shared/components/Card.tsx', 'src/shared/components/Button.tsx'], 'exports': ['HomePage'], 'priority': 3}, {'id': 'login-page', 'file_path': 'src/pages/LoginPage.tsx', 'description': 'Login page that hosts LoginForm and handles navigation after login.', 'dependencies': ['src/features/auth/LoginForm.tsx'], 'exports': ['LoginPage'], 'priority': 3}, {'id': 'not-found-page', 'file_path': 'src/pages/NotFoundPage.tsx', 'description': 'Fallback 404 page for unknown routes.', 'dependencies': [], 'exports': ['NotFoundPage'], 'priority': 3}], 'file_paths': ['src/providers/ApiProvider.tsx', 'src/app/AppProviders.tsx', 'src/app/router.tsx', 'src/app/bootstrap.ts', 'src/main.tsx', 'src/providers/ThemeProvider.tsx', 'src/services/apiClient.ts', 'src/hooks/useApiQuery.ts', 'src/shared/components/Button.tsx', 'src/shared/components/Card.tsx', 'src/features/dashboard/DashboardLayout.tsx', 'src/features/dashboard/MetricCard.tsx', 'src/shared/components/Input.tsx', 'src/hooks/useLocalStorage.ts', 'src/features/auth/LoginForm.tsx', 'src/shared/components/Modal.tsx', 'src/services/productService.ts', 'src/shared/components/Toast.tsx', 'src/services/userService.ts', 'src/app/config.ts', 'src/core/contracts.ts', 'src/core/di.ts', 'src/core/events.ts', 'src/core/hooks.ts', 'src/core/utils.ts', 'src/pages/DashboardPage.tsx', 'src/pages/HomePage.tsx', 'src/pages/LoginPage.tsx', 'src/pages/NotFoundPage.tsx'], 'descriptions': ['Provides the API client context to the app and optionally global cross-cutting concerns (auth tokens, interceptors).', 'Root providers wrapper that composes ThemeProvider, ApiProvider, AuthProvider, and any global contexts.', 'Routing configuration using React Router v6. Maps paths to pages (Home, Login, Dashboard, NotFound).', 'Initialization helpers (e.g., register core hooks, initialize DI, perform preflight checks).', 'Application bootstrap file. Mounts the root React tree and wires AppProviders with the router.', 'Theme wrapper (Material UI or custom theme) for consistent styling across the app.', 'Typed API client (axios-based) with baseURL and common request/response handling.', 'Lightweight data-fetch hook leveraging apiClient for simple query usage.', 'Reusable button component with theming and common variants.', 'Generic Card container used by dashboards and forms.', 'Layout component for dashboard pages, composing cards and panels.', 'Metric card component used inside dashboards.', 'Input field component with label and error support.', 'Custom hook to persist state in localStorage with a simple API.', 'Login form component used by Login page and potential modal flows.', 'Modal provider for blocking dialogs and popups.', 'Product-related API interactions (fetch product list).', 'Toast/notification utility component.', 'User-related API interactions (login, fetch current user).', 'Materialized runtime configuration (endpoints, feature flags, defaults) consumed by providers and app bootstrap.', 'Domain types and API contracts shared across the app. Defines generic API response shapes and basic domain models used by services and components.', 'Minimal Dependency Injection container to instantiate and provide core services.', 'Lightweight event bus for decoupled communication between parts of the app (publish/subscribe).', 'Hook registry to enable extensibility points across the app (register/use hooks at runtime).', 'Common utilities used across the app (debounce, delay, formatters, etc.).', 'Dashboard page that assembles the DashboardLayout with metrics and panels.', 'Landing page composing hero and quick actions.', 'Login page that hosts LoginForm and handles navigation after login.', 'Fallback 404 page for unknown routes.'], 'total_files': 29}