{'architecture': {'overview': 'A lean React 18+ + TypeScript SPA built around a small, well-defined kernel (contracts, events, hooks, DI, utilities) that exposes extension points and runtime config. The app then layers a minimal set of runtime providers, shared UI primitives, and a Home page to demonstrate the structure. This approach emphasizes modularity, testability, and a clean separation between core concerns and feature/pages.', 'patterns': ['Container/Presentational (Layout as container, pages as presentational wrappers)', 'Dependency Injection (DI container)', 'Event-driven communication (EventBus)', 'Hook registry for extensibility', 'Clean architecture layering (core/kernel vs features)', 'Type-safe contracts across modules'], 'data_flow': '1) Boot: App reads APP_CONFIG from app/config.ts (typed via core/contracts.ts).\n2) DI setup (src/core/di.ts) wires basic services if needed (extendable).\n3) Global events emitted via EventBus (src/core/events.ts) for cross-module signaling.\n4) UI renders through shared Layout (src/shared/components/Layout.tsx).\n5) Pages (src/pages/HomePage.tsx) consume layout and render content.\n6) ThemeProvider (src/providers/ThemeProvider.tsx) can wrap the app to provide theming state via React Context.\n7) Extensions/hooks (src/core/hooks.ts) can register and trigger hooks at runtime as needed.', 'folder_structure': 'src/\n  core/\n    contracts.ts\n    events.ts\n    hooks.ts\n    di.ts\n    utils.ts\n  app/\n    config.ts\n  providers/\n    ThemeProvider.tsx\n  shared/\n    components/\n      Layout.tsx\n  pages/\n    HomePage.tsx', 'tech_stack': ['React 18+', 'TypeScript', 'Lightweight in-app DI (DIContainer)', 'Tiny EventBus for pub/sub', 'Hook registry for extensions', 'Context-based theming (ThemeProvider)']}, 'kernel_specs': {'overview': 'The Core Kernel provides a compact, strongly-typed foundation for all sections to depend on. It defines domain contracts, a materialized runtime config, a typed event bus, a hook registry for extension points, and a tiny DI container. Together, these pieces enable safe cross-module communication, dependency wiring, and extensibility while keeping concerns isolated and testable.'}, 'sections': [{'id': 'app-config', 'file_path': 'src/app/config.ts', 'description': 'Materialized runtime configuration (APP_CONFIG) consumed by bootstrapping code and features.', 'dependencies': ['src/core/contracts.ts'], 'exports': ['APP_CONFIG'], 'priority': 1, 'purpose': 'Materialized runtime configuration (APP_CONFIG) consumed by bootstrapping code and features. Exposes computed flags and mock data helpers.', 'content': "// File: src/app/config.ts\n// Materialized runtime configuration for the app, with helper flags and mock data.\n\nimport type { AppConfig, User } from '@/core/contracts';\n\n// Feature coverage example (align with actual features used in the app)\n// You can expand this union as the application grows.\nexport const APP_CONFIG: AppConfig = {\n  environment: 'development',\n  baseApiUrl: 'https://api.dev.example',\n  wsUrl: 'wss://ws.dev.example',\n  features: [\n    'patientPortal',\n    'appointments',\n    'medicalRecords',\n    'notifications',\n  ],\n  dev: {\n    enableMockData: true,\n    logLevel: 'debug',\n  },\n};\n\n// Computed runtime flags\nexport const isDevelopment = APP_CONFIG.environment === 'development';\nexport const shouldUseMockData = APP_CONFIG.dev?.enableMockData ?? false;\n\nexport const hasFeature = (name: string): boolean => APP_CONFIG.features.includes(name as any);\n\n// Mock user generation for development mode\nexport const getCurrentUser = (): User | undefined => {\n  if (isDevelopment && shouldUseMockData) {\n    // Simple mock user; in real scenarios, you could cycle through a mock catalog\n    return {\n      id: 'mock-user-1',\n      name: 'Mock User',\n      email: 'mock.user@example.com',\n      role: 'patient' as const,\n    };\n  }\n  return undefined;\n};\n\n// Example usage patterns:\n// - Import APP_CONFIG in bootstrapping code to configure services\n// - Call hasFeature('appointments') to toggle feature wiring\n// - Call getCurrentUser() to seed initial session when in development with mock data\n"}, {'id': 'core-contracts', 'file_path': 'src/core/contracts.ts', 'description': 'Domain types and API contracts used across the app; defines AppConfig interface, generic ApiResponse, and common utility types.', 'dependencies': [], 'exports': ['AppConfig', 'ApiResponse', 'EventPayload', 'VoidFn'], 'priority': 1, 'purpose': 'Domain types and API contracts used across the app; defines AppConfig (reusable across the app), generic ApiResponse, and common utility types.', 'content': "// File: src/core/contracts.ts\n// Core domain contracts and utility types shared across the application\n// This file is the single source of truth for shapes used throughout the kernel.\n\n// Feature flag identifiers (string literals are acceptable but you can widen this as needed)\nexport type FeatureFlag = string;\n\n// User and healthcare domain models\nexport type UserRole = 'patient' | 'doctor' | 'nurse' | 'admin';\n\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n  role: UserRole;\n}\n\nexport interface Patient extends User {\n  patientId: string;\n  // optional quick references to clinical concepts\n  allergies?: string[];\n}\n\nexport interface Doctor extends User {\n  specialty?: string;\n}\n\nexport interface Nurse extends User {\n  department?: string;\n}\n\n// Union for ease of type checks when you only care about a role\nexport type HealthcareUser = Patient | Doctor | Nurse | User;\n\n// Healthcare domain models\nexport interface Appointment {\n  id: string;\n  patientId: string;\n  doctorId: string;\n  date: string; // ISO date string\n  status: 'scheduled' | 'completed' | 'cancelled';\n  reason?: string;\n}\n\nexport interface MedicalRecord {\n  id: string;\n  patientId: string;\n  entries: MedicalRecordEntry[];\n}\n\nexport interface MedicalRecordEntry {\n  id: string;\n  date: string; // ISO timestamp\n  type: 'visit' | 'lab' | 'imaging' | 'note';\n  notes: string;\n  authorId?: string;\n}\n\nexport interface Prescription {\n  id: string;\n  patientId: string;\n  doctorId: string;\n  medication: string;\n  dosage: string;\n  startDate: string; // ISO\n  endDate?: string; // ISO\n  notes?: string;\n}\n\nexport interface LabResult {\n  id: string;\n  patientId: string;\n  testName: string;\n  value: string;\n  unit?: string;\n  referenceRange?: string;\n  date: string; // ISO\n}\n\n// API surface types\nexport interface ApiError {\n  code?: string;\n  message: string;\n  details?: any;\n}\n\nexport interface ApiResponse<T> {\n  success: boolean;\n  data?: T;\n  error?: ApiError;\n}\n\nexport type ApiResult<T> = ApiResponse<T>;\n\nexport interface PaginatedResponse<T> {\n  items: T[];\n  page: number;\n  pageSize: number;\n  total: number;\n  totalPages: number;\n}\n\n// Simple utility payload and callbacks\nexport type EventPayload<T = any> = T;\nexport type VoidFn = () => void;\n\n// WebSocket events (optional: used when websockets are enabled in config)\nexport interface WebSocketEvent {\n  type: string;\n  payload?: any;\n  timestamp?: number;\n}\nexport interface WebSocketEventMap {\n  [event: string]: any;\n}\n\n// UI state primitives used across components\nexport type LoadingState = 'idle' | 'loading' | 'success' | 'error';\nexport type FormState = 'idle' | 'valid' | 'invalid' | 'submitting' | 'submitted';\n\n// Runtime app config contract (imported by app/config.ts and consumers)\nexport interface AppConfig {\n  environment: 'development' | 'production' | 'staging';\n  baseApiUrl: string;\n  wsUrl?: string;\n  features: FeatureFlag[];\n  dev?: {\n    enableMockData?: boolean;\n    logLevel?: 'debug' | 'info' | 'warn' | 'error';\n  };\n}\n\n// Reusable type helpers for internal API contracts\nexport type ApiClientLike<T = any> = {\n  fetch: (input: RequestInfo, init?: RequestInit) => Promise<ApiResponse<T>>;\n};\n\n// Note: Consumers should import types from '@/core/contracts'\n"}, {'id': 'core-di', 'file_path': 'src/core/di.ts', 'description': 'Minimal dependency injection container to register and resolve services by token.', 'dependencies': [], 'exports': ['DIContainer', 'di'], 'priority': 1, 'purpose': 'Tiny dependency injection container to register and resolve services by token; includes explicit token definitions for core services.', 'content': "// File: src/core/di.ts\n// Minimal DI container with explicit tokens to enable decoupled wiring across modules.\n\nexport const TOKENS = {\n  ApiClient: 'ApiClient',\n  AuthService: 'AuthService',\n  StorageService: 'StorageService',\n  WebSocketService: 'WebSocketService',\n} as const;\n\nexport type Token = typeof TOKENS[keyof typeof TOKENS];\n\n// Simple service contracts\nexport interface ApiClient<T = any> {\n  fetch(input: RequestInfo, init?: RequestInit): Promise<import('./contracts').ApiResponse<T>>;\n}\n\nexport interface StorageService {\n  setItem(key: string, value: string): void;\n  getItem(key: string): string | null;\n  removeItem(key: string): void;\n}\n\nexport interface AuthService {\n  login(username: string, password: string): Promise<void>;\n  logout(): Promise<void>;\n}\n\nexport interface WebSocketService {\n  connect(url: string): Promise<void>;\n  disconnect(): void;\n}\n\nexport class DIContainer {\n  private registry = new Map<string, any>();\n\n  register<T>(token: string, value: T): void {\n    this.registry.set(token, value);\n  }\n\n  resolve<T>(token: string): T {\n    if (!this.registry.has(token)) {\n      throw new Error(`DI: Unregistered token '${token}'`);\n    }\n    return this.registry.get(token) as T;\n  }\n}\n\nexport const di = new DIContainer();\n"}, {'id': 'core-events', 'file_path': 'src/core/events.ts', 'description': 'Global event bus enabling publish/subscribe across modules without tight coupling.', 'dependencies': [], 'exports': ['EventBus', 'eventBus'], 'priority': 1, 'purpose': 'Typed event system: a global EventBus enabling publish/subscribe across modules without tight coupling; provides a singleton instance for app-wide use.', 'content': "// File: src/core/events.ts\n// Global event bus with a strongly-typed event map.\n\nexport interface AppEventMap {\n  beforeApiRequest: { url: string; options?: RequestInit };\n  afterApiResponse: { url: string; status: number; response?: any };\n  login: { userId: string; timestamp?: number };\n  logout: { reason?: string; timestamp?: number };\n  routeChange: { path: string; params?: Record<string, string> };\n  appointmentCreated: { appointmentId: string; patientId?: string };\n}\n\ntype Handler<T> = (payload: T) => void | Promise<void>;\n\nexport class EventBus<EM extends Record<string, any> = AppEventMap> {\n  private listeners = new Map<string, Set<(payload: any) => void | Promise<void>>>();\n\n  on<K extends keyof EM>(event: K, handler: Handler<EM[K]>): void {\n    const key = event as string;\n    if (!this.listeners.has(key)) this.listeners.set(key, new Set());\n    this.listeners.get(key)!.add(handler as any);\n  }\n\n  off<K extends keyof EM>(event: K, handler: Handler<EM[K]>): void {\n    const key = event as string;\n    this.listeners.get(key)?.delete(handler as any);\n  }\n\n  async emit<K extends keyof EM>(event: K, payload: EM[K]): Promise<void> {\n    const key = event as string;\n    const handlers = this.listeners.get(key);\n    if (!handlers) return;\n    // Execute handlers sequentially to preserve order and allow awaits\n    for (const h of Array.from(handlers)) {\n      try {\n        const res = (h as Function)(payload);\n        if (res instanceof Promise) await res;\n      } catch (e) {\n        // In production, route to a logger\n        console.error('[EventBus] handler error', e);\n      }\n    }\n  }\n}\n\nexport const eventBus = new EventBus<AppEventMap>();\n"}, {'id': 'core-hooks', 'file_path': 'src/core/hooks.ts', 'description': 'Hook registry that allows extensions to register and execute lifecycle hooks.', 'dependencies': [], 'exports': ['HookRegistry', 'hooks'], 'priority': 1, 'purpose': 'Hook registry that enables extension points across modules; provides a context object to all registered hooks and a run/trigger mechanism.', 'content': "// File: src/core/hooks.ts\n// Hook registry for extension points. Hooks receive a shared context and payload.\n\nimport { di } from './di';\nimport { eventBus } from './events';\nimport type { AppConfig, User } from '@/core/contracts';\n\n// Define all hook points that extensions can opt into\nexport type HookPoint = 'beforeApiRequest' | 'afterApiResponse' | 'onLogin' | 'onLogout' | 'onRouteChange';\n\nexport interface HookContext {\n  di: typeof di;\n  eventBus: typeof eventBus;\n  config?: AppConfig;\n  currentUser?: User;\n}\n\ntype HookHandler = (ctx: HookContext, payload: any) => void | Promise<void>;\n\nexport class HookRegistry {\n  private registry = new Map<HookPoint, HookHandler[]>();\n\n  register(point: HookPoint, handler: HookHandler): void {\n    const existing = this.registry.get(point) ?? [];\n    existing.push(handler);\n    this.registry.set(point, existing);\n  }\n\n  async run(point: HookPoint, payload: any): Promise<void> {\n    const handlers = this.registry.get(point) ?? [];\n    const ctx: HookContext = { di, eventBus, config: undefined, currentUser: undefined };\n    for (const handler of handlers) {\n      await handler(ctx, payload);\n    }\n  }\n}\n\n// Singleton export for convenient usage across modules\nexport const hooks = new HookRegistry();\n\n// Usage patterns (in application bootstrap or feature modules):\n// 1. Import { hooks } from '@/core/hooks';\n// 2. hooks.register('beforeApiRequest', (ctx, payload) => { /* mutate payload or log */ });\n// 3. await hooks.run('beforeApiRequest', { url: '/api/foo', options: {} });\n"}, {'id': 'core-utils', 'file_path': 'src/core/utils.ts', 'description': 'Common utility helpers (e.g., delay, clamp) used across modules.', 'dependencies': [], 'exports': ['delay', 'clamp'], 'priority': 1, 'purpose': 'Common utility helpers used across modules; includes small helpers like delay, clamp, safe JSON operations and simple formatters.', 'content': '// File: src/core/utils.ts\n// Lightweight utility helpers for bootstrapping and runtime helpers.\n\nexport const delay = (ms: number): Promise<void> => new Promise((resolve) => setTimeout(resolve, ms));\n\nexport const clamp = (value: number, min: number, max: number): number => {\n  return Math.max(min, Math.min(max, value));\n};\n\nexport const safeJsonParse = <T = any>(text: string, reviver?: (this: any, key: string, value: any) => any): T | null => {\n  try {\n    return JSON.parse(text, reviver) as T;\n  } catch {\n    return null;\n  }\n};\n\nexport const safeJsonStringify = (value: any): string | null => {\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return null;\n  }\n};\n\nexport const nowIso = (): string => new Date().toISOString();\n'}, {'id': 'theme-provider', 'file_path': 'src/providers/ThemeProvider.tsx', 'description': 'Theme provider component and hook to expose current theme to the app.', 'dependencies': [], 'exports': ['ThemeProvider', 'useTheme'], 'priority': 2}, {'id': 'home-page', 'file_path': 'src/pages/HomePage.tsx', 'description': 'Home page that composes the Layout and renders introductory content.', 'dependencies': ['src/shared/components/Layout.tsx'], 'exports': ['HomePage', 'default HomePage'], 'priority': 3}, {'id': 'layout-component', 'file_path': 'src/shared/components/Layout.tsx', 'description': 'Generic layout wrapper for pages; provides header and content container.', 'dependencies': [], 'exports': ['Layout'], 'priority': 3}], 'file_paths': ['src/app/config.ts', 'src/core/contracts.ts', 'src/core/di.ts', 'src/core/events.ts', 'src/core/hooks.ts', 'src/core/utils.ts', 'src/providers/ThemeProvider.tsx', 'src/pages/HomePage.tsx', 'src/shared/components/Layout.tsx'], 'descriptions': ['Materialized runtime configuration (APP_CONFIG) consumed by bootstrapping code and features.', 'Domain types and API contracts used across the app; defines AppConfig interface, generic ApiResponse, and common utility types.', 'Minimal dependency injection container to register and resolve services by token.', 'Global event bus enabling publish/subscribe across modules without tight coupling.', 'Hook registry that allows extensions to register and execute lifecycle hooks.', 'Common utility helpers (e.g., delay, clamp) used across modules.', 'Theme provider component and hook to expose current theme to the app.', 'Home page that composes the Layout and renders introductory content.', 'Generic layout wrapper for pages; provides header and content container.'], 'total_files': 9}