version: light

persons:
  Section Planner:
    service: openai
    model: gpt-5-mini-2025-08-07
    api_key_id: APIKEY_52609F
    system_prompt: |
      You are a senior product/front-end architect with expertise in React, TypeScript, and modern web architecture.
      
      Your task is to:
      1. Define the overall architecture and folder structure
      2. Split work into sections where EACH section represents ONE specific file
      3. List all files that need to be implemented with clear descriptions
      
      Focus on:
      - COMPLETENESS: Include every file that will be imported anywhere
      - Clear file paths and responsibilities
      - Logical grouping and dependencies between files
      - Modern React 18+ and TypeScript patterns
      
      Note: You don't need to provide detailed implementation steps. The Core Kernel will handle shared contracts, and the Frontend Generator will handle implementation details.

  Core Kernel Architect:
    service: openai
    model: gpt-5-mini-2025-08-07
    api_key_id: APIKEY_52609F
    system_prompt: |
      You are an expert TypeScript architect specializing in creating foundational contracts and utilities.
      
      Your task is to generate the Core Kernel - a set of 5-7 foundational files that ALL sections will depend on.
      These files establish the single source of truth for types, configuration, events, hooks, and utilities.
      
      Generate complete, production-ready TypeScript code with:
      - Comprehensive domain types and API contracts
      - Materialized configuration from the app config
      - Event bus for decoupled communication
      - Hook system for extension points
      - Dependency injection tokens
      
      Every file must be immediately usable with no placeholders or TODOs.

  Frontend Generator:
#    service: openai
#    model: gpt-5-nano-2025-08-07
#    api_key_id: APIKEY_52609F
    service: claude-code
    model: claude-code
    api_key_id: APIKEY_CLAUDE
    system_prompt: |
      You are an expert React/TypeScript engineer. Your task is to generate production-ready code following the detailed instructions in the prompt file.
      
      KEY FOCUS:
      - Generate raw code without explanations or commentary
      - Follow conventions and contracts defined in the prompt
      - Build iteratively using context from previous sections
      - Code must be complete, working, and deployable as-is

nodes:
  - label: Start
    type: start
    position: {x: 60, y: 240}
    props:
      trigger_mode: manual
      custom_data:
        # Default config file path - can be overridden via --input-data
        config_file: projects/frontend_auto/variants/healthcare_portal_config.json
      
  - label: Load Config
    type: db
    position: {x: 300, y: 240}
    props:
      operation: read
      sub_type: file
      format: json
      source_details: "{config_file}"

  - label: Plan Sections
    type: person_job
    position: {x: 400, y: 240}
    props:
      person: Section Planner
      text_format_file: projects/frontend_auto/section_models.py
      default_prompt: |
        Analyze the requirements and create a file structure plan:

        App config: {{config}}

        Your response MUST include:
        1. Architecture:
           - High-level overview of the application structure
           - Key patterns and technologies to use
           - Folder structure showing organization
           - Data flow description

        2. Sections (one per file):
           - id: unique identifier
           - file_to_implement: exact file path
           - description: what the file does
           - dependencies: other files it imports from
           - exports: what it provides to other files
           - priority: 0=kernel, 1=foundational, 2=components, 3=pages

        REQUIREMENTS:
        - Order sections by priority and dependencies
        - Include ALL files that will exist in the app
        - Start with core kernel files (priority 0):
          * core/contracts.ts - Domain types and API contracts
          * app/config.ts - Materialized configuration
          * core/events.ts - Event bus system
          * core/hooks.ts - Hook registry for extensions
          * core/di.ts - Dependency injection (if needed)
          * core/utils.ts - Common utilities (if needed)
        - Then include: pages, providers, services, shared components, hooks, features
        - Every import must have a corresponding section

  - label: Extract Section Properties
    type: code_job
    position: {x: 600, y: 240}
    props:
      language: python
      code: |
        # Extract file_paths and descriptions from sections
        sections = sections_data.get('sections', [])
        
        file_paths = [section['file_path'] for section in sections]
        descriptions = [section['description'] for section in sections]
        
        # Return data with extracted properties at same level
        result = {
            'architecture': sections_data.get('architecture', {}),
            'sections': sections,
            'file_paths': file_paths,
            'descriptions': descriptions
        }

  - label: Generate Core Kernel
    type: person_job
    position: {x: 1050, y: 240}
    props:
      person: Core Kernel Architect
      text_format_file: projects/frontend_auto/core_kernel_models.py
      prompt_file: core_kernel_generator.txt
      memorize_to: "as-is"

  - label: Merge Kernel and Sections
    type: code_job
    position: {x: 900, y: 240}
    props:
      language: python
      code: |
        import json
        from pathlib import Path
        
        # Save kernel data for reference
        kernel_json_path = Path("projects/frontend_auto/generated/core_kernel_data.json")
        with open(kernel_json_path, 'w', encoding='utf-8') as f:
            json.dump(kernel, f, indent=2)
        
        # Get sections and sort by priority
        sections = sections_data.get('sections', [])
        sections.sort(key=lambda x: (x.get('priority', 2), x.get('id', '')))
        
        # Create a map of kernel files by file_path for easy lookup
        kernel_files_map = {}
        if 'files' in kernel:
            for kf in kernel['files']:
                kernel_files_map[kf['file_path']] = kf
        
        # Merge kernel details into corresponding sections
        for section in sections:
            # Check if this section corresponds to a kernel file
            if section['file_path'] in kernel_files_map:
                kernel_file = kernel_files_map[section['file_path']]
                # Merge the detailed kernel specs into the section
                section['purpose'] = kernel_file.get('purpose', '')
                section['content'] = kernel_file.get('content', '')
                # Keep the original description as fallback
                if not section.get('description'):
                    section['description'] = kernel_file.get('purpose', '')
        
        # Extract file paths and descriptions from sorted sections
        file_paths = [section['file_path'] for section in sections]
        descriptions = [section.get('description', '') for section in sections]
        
        # Return merged data with kernel overview (without duplicate files array)
        result = {
            'architecture': sections_data.get('architecture', {}),
            'kernel_specs': {'overview': kernel.get('overview', '')},  # Only keep overview
            'sections': sections,  # Now contains merged kernel details
            'file_paths': file_paths,
            'descriptions': descriptions,
            'total_files': len(sections)
        }

  - label: Save Merged Data
    type: db
    position: {x: 1100, y: 240}
    props:
      operation: write
      sub_type: file
      format: json
      source_details: projects/frontend_auto/generated/sections_data.json

  - label: load Data
    type: db
    position: {x: 1100, y: 240}
    props:
      operation: read
      sub_type: file
      format: json
      source_details: projects/frontend_auto/generated/sections_data.json

  - label: Check Continue
    type: condition
    position: {x: 1750, y: 240}
    props:
      condition_type: custom
#      expression: current_index >= 4
      expression: current_index >= default.total_files
      expose_index_as: current_index
      flipped: [false, true]

  - label: Load Merged Data
    type: db
    position: {x: 1750, y: 400}
    props:
      operation: read
      sub_type: file
      format: json
      source_details: projects/frontend_auto/generated/sections_data.json

  - label: Generate Frontend Code
    type: person_job
    position: {x: 2000, y: 240}
    props:
      person: Frontend Generator
      max_iteration: 100
      memorize_to: "Only prior sections that this file imports or depends on (providers, hooks, shared components referenced in file_to_implement). Exclude generic commentary."
      at_most: 5
      prompt_file: frontend_generator.txt

  - label: Write Section Result
    type: db
    position: {x: 2400, y: 240}
    props:
      operation: write
      sub_type: file
      format: text
      source_details: "projects/frontend_auto/generated/temp_section_{current_index}.tsx"

  - label: Rename Files
    type: code_job
    position: {x: 1950, y: 600}
    props:
      language: python
      filePath: projects/frontend_auto/rename_generated_files.py
      functionName: rename_generated_files

#  - label: Compile Results
#    type: code_job
#    position: {x: 1400, y: 600}
#    props:
#      language: python
#      code: |
#        import json
#        import os
#        from pathlib import Path
#
#        # Read all generated section files
#        generated_dir = Path("projects/frontend_enhance/generated")
#        section_files = sorted(generated_dir.glob("consolidated_section_*.json"))
#
#        all_sections = []
#        for file in section_files:
#          with open(file, 'r') as f:
#            all_sections.append(json.load(f))
#
#        result = {
#          "success": True,
#          "total_sections_processed": len(all_sections),
#          "sections": all_sections,
#          "architecture": sorted_data.get('architecture', {}),
#          "approach": "Sequential processing with intelligent memory selection"
#        }


  - label: End
    type: endpoint
    position: {x: 2200, y: 600}
    props:
      save_to_file: false

connections:
  # Initial setup
  - {from: Start, to: Load Config, label: default, content_type: object}
  - {from: Load Config, to: Plan Sections, label: config, content_type: object}
  - {from: Load Config, to: Generate Core Kernel, label: config, content_type: object }

  - {from: Plan Sections, to: Extract Section Properties, label: sections_data, content_type: object}
  - {from: Plan Sections, to: Generate Core Kernel, label: sections_data, content_type: object}

  # Merge kernel and sections (direct connections)
  - {from: Extract Section Properties, to: Merge Kernel and Sections, label: sections_data, content_type: object}
  - {from: Generate Core Kernel, to: Merge Kernel and Sections, label: kernel, content_type: object}
  - {from: Merge Kernel and Sections, to: Save Merged Data, content_type: object}
  - {from: Save Merged Data, to: load Data, content_type: object}
  - { from: load Data, to: Check Continue, content_type: object }

  # Section iteration loop (now processes both kernel and regular sections)
  - {from: Check Continue_condfalse, to: Load Merged Data, content_type: object}
  - {from: Load Merged Data, to: Generate Frontend Code, content_type: object}
  - {from: Generate Frontend Code, to: Write Section Result, content_type: object}
  - {from: Write Section Result, to: Check Continue, content_type: object}

  # Finalization
  - {from: Check Continue_condtrue, to: Rename Files, content_type: object}
  - {from: Rename Files, to: End, content_type: object}
