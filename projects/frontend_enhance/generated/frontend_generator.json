"src/components/MyComponent/index.ts\n```ts\n/**\n * Public exports for MyComponent package.\n *\n * All exports include JSDoc on their definitions in-file. This barrel file consolidates\n * stable, named exports for consumers.\n */\n\nexport { MyComponent } from './MyComponent';\nexport type { MyComponentProps } from './types';\nexport { MyComponentProvider, useMyComponentContext } from './context/MyComponentContext';\nexport { useMyComponentData } from './hooks/useMyComponentData';\nexport { useMyComponentWebSocket } from './hooks/useMyComponentWebSocket';\nexport { useMyComponentUtils } from './hooks/useMyComponentUtils';\nexport type { Item, PageResponse, QueryParams, WebSocketStatus } from './types';\nexport { ErrorBoundary } from './ErrorBoundary';\nexport { registerServiceWorker } from './serviceWorker';\nexport { sanitizeHtml, serverSanitizeHtml } from './utils';\n```\n\nsrc/components/MyComponent/MyComponent.tsx\n```tsx\nimport React, { useCallback, useMemo, useRef, useState, useEffect } from 'react';\nimport { FixedSizeList as List, ListChildComponentProps } from 'react-window';\nimport AutoSizer from 'react-virtualized-auto-sizer';\nimport clsx from 'clsx';\nimport styles from './MyComponent.module.css';\nimport { useMyComponentData } from './hooks/useMyComponentData';\nimport { useMyComponentWebSocket } from './hooks/useMyComponentWebSocket';\nimport { MyComponentProps, Item } from './types';\nimport { useMyComponentContext } from './context/MyComponentContext';\nimport { sanitizeHtml } from './utils';\nimport { useMyComponentUtils } from './hooks/useMyComponentUtils';\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport ReactDOMServer from 'react-dom/server';\n\n/**\n * MyComponent\n *\n * A virtualized, infinitely-scrollable list component with optimistic mutation support,\n * keyboard navigation (roving tabindex), accessible roles, and live region status updates.\n *\n * Notes:\n * - SSR-safe: any browser-only features (websocket, sanitizer) are guarded internally.\n * - For styling it uses Tailwind utilities via CSS Modules overrides.\n *\n * @param props - See MyComponentProps type for full details.\n */\nexport const MyComponent: React.FC<MyComponentProps> = React.memo(function MyComponent(\n  props\n) {\n  const {\n    queryParams,\n    itemHeight = 88,\n    height = 600,\n    width = '100%',\n    ariaLabel = 'My items list',\n    showWebSocket = true,\n    onItemClick,\n  } = props;\n\n  const ctx = useMyComponentContext();\n  const queryClient = useQueryClient();\n\n  const {\n    items,\n    fetchNextPage,\n    hasNextPage,\n    isFetchingNextPage,\n    status,\n    refetch,\n    queryKey,\n  } = useMyComponentData<Item>({ queryParams, apiBase: ctx.apiBase });\n\n  // WebSocket updates: append or update items on message\n  const { send, status: wsStatus } = useMyComponentWebSocket(\n    showWebSocket ? `${ctx.wsBase}/items` : '',\n    {\n      onMessage: (payload) => {\n        // expect payload to be of shape { type: 'upsert', item: Item }\n        if (payload?.type === 'upsert' && payload.item) {\n          // optimistic merge with queryClient\n          queryClient.setQueryData(queryKey, (old: any) => {\n            const pages = old?.pages ?? [];\n            const flat = pages.flatMap((p: any) => p.items ?? []);\n            const idx = flat.findIndex((i: Item) => i.id === payload.item.id);\n            if (idx === -1) {\n              // prepend newest\n              const first = pages[0] ?? { items: [] };\n              return {\n                ...old,\n                pages: [{ ...first, items: [payload.item, ...first.items] }, ...pages.slice(1)],\n              };\n            } else {\n              // replace\n              return {\n                ...old,\n                pages: pages.map((p: any) => ({\n                  ...p,\n                  items: p.items.map((it: Item) => (it.id === payload.item.id ? payload.item : it)),\n                })),\n              };\n            }\n          });\n        }\n      },\n      reconnectStrategy: { maxRetries: 5, baseDelayMs: 500 },\n    }\n  );\n\n  // Mutation example: toggling \"starred\" with optimistic update and rollback\n  const mutationKey = ['items', queryParams ?? {}] as const;\n  const toggleMutation = useMutation<\n    Item,\n    Error,\n    { id: string; starred: boolean },\n    { previous: unknown }\n  >(\n    async ({ id, starred }) => {\n      // API request; abort not used for mutations here\n      const res = await fetch(`${ctx.apiBase}/items/${id}`, {\n        method: 'PATCH',\n        headers: { 'content-type': 'application/json' },\n        body: JSON.stringify({ starred }),\n      });\n      if (!res.ok) {\n        throw new Error('Failed to update');\n      }\n      return res.json();\n    },\n    {\n      onMutate: async (variables) => {\n        await queryClient.cancelQueries({ queryKey: mutationKey });\n        const previous = queryClient.getQueryData(mutationKey);\n        queryClient.setQueryData(mutationKey, (old: any) => {\n          const pages = old?.pages ?? [];\n          return {\n            ...old,\n            pages: pages.map((p: any) => ({\n              ...p,\n              items: p.items.map((it: Item) =>\n                it.id === variables.id ? { ...it, starred: variables.starred } : it\n              ),\n            })),\n          };\n        });\n        return { previous };\n      },\n      onError: (err, variables, context) => {\n        if (context?.previous) {\n          queryClient.setQueryData(mutationKey, context.previous);\n        }\n      },\n      onSettled: () => {\n        queryClient.invalidateQueries({ queryKey: mutationKey });\n      },\n    }\n  );\n\n  // Keyboard roving tabindex state\n  const [activeIndex, setActiveIndex] = useState<number>(0);\n  const listRef = useRef<List | null>(null);\n\n  useEffect(() => {\n    // reset active index when items change considerably\n    setActiveIndex((ix) => (ix >= items.length ? Math.max(0, items.length - 1) : ix));\n  }, [items.length]);\n\n  const onKeyDown = useCallback(\n    (e: React.KeyboardEvent) => {\n      if (e.key === 'ArrowDown') {\n        e.preventDefault();\n        setActiveIndex((i) => Math.min(i + 1, items.length - 1));\n        listRef.current?.scrollToItem(Math.min(activeIndex + 1, items.length - 1));\n      } else if (e.key === 'ArrowUp') {\n        e.preventDefault();\n        setActiveIndex((i) => Math.max(0, i - 1));\n        listRef.current?.scrollToItem(Math.max(activeIndex - 1, 0));\n      } else if (e.key === 'Home') {\n        e.preventDefault();\n        setActiveIndex(0);\n        listRef.current?.scrollToItem(0);\n      } else if (e.key === 'End') {\n        e.preventDefault();\n        setActiveIndex(items.length - 1);\n        listRef.current?.scrollToItem(items.length - 1);\n      } else if (e.key === 'Enter') {\n        e.preventDefault();\n        const item = items[activeIndex];\n        if (item) onItemClick?.(item);\n      }\n    },\n    [activeIndex, items, onItemClick]\n  );\n\n  // Virtualized list's itemData\n  const itemData = useMemo(\n    () => ({ items, fetchNextPage, hasNextPage, isFetchingNextPage, toggleMutation, activeIndex, setActiveIndex }),\n    [items, fetchNextPage, hasNextPage, isFetchingNextPage, toggleMutation, activeIndex]\n  );\n\n  // Virtualization item renderer\n  const loadingRef = useRef(false);\n\n  const Row = useCallback(\n    ({ index, style, data }: ListChildComponentProps<typeof itemData>) => {\n      const { items, hasNextPage, fetchNextPage, isFetchingNextPage, toggleMutation, activeIndex, setActiveIndex } =\n        data;\n      if (index >= items.length) {\n        // sentinel row for loading more\n        if (hasNextPage && !isFetchingNextPage && !loadingRef.current) {\n          loadingRef.current = true;\n          fetchNextPage().finally(() => {\n            loadingRef.current = false;\n          });\n        }\n        return (\n          <div\n            role=\"row\"\n            aria-rowindex={index + 1}\n            style={style}\n            className={clsx('flex items-center justify-center', styles.row, 'text-sm text-gray-500')}\n          >\n            Loading\u2026\n          </div>\n        );\n      }\n      const item = items[index] as Item;\n      const isActive = index === activeIndex;\n      return (\n        <div\n          role=\"row\"\n          aria-rowindex={index + 1}\n          tabIndex={isActive ? 0 : -1}\n          onKeyDown={onKeyDown}\n          onFocus={() => setActiveIndex(index)}\n          style={style}\n          className={clsx(\n            'p-3 flex items-center gap-3',\n            styles.row,\n            isActive ? 'ring-2 ring-offset-2 ring-indigo-400' : '',\n            item.starred ? 'bg-yellow-50' : 'bg-white'\n          )}\n          onClick={() => onItemClick?.(item)}\n        >\n          <div className=\"flex-1\">\n            <div className=\"font-medium text-sm\">{item.title}</div>\n            <div\n              className=\"text-xs text-gray-600\"\n              // sanitize before rendering dynamic HTML\n              dangerouslySetInnerHTML={{ __html: '' }}\n              aria-hidden\n              // We render sanitized markup below to demonstrate SSR-aware sanitization.\n            />\n            <div className=\"text-xs text-gray-500\">{item.subtitle}</div>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <button\n              aria-label={item.starred ? 'Unstar item' : 'Star item'}\n              onClick={(e) => {\n                e.stopPropagation();\n                toggleMutation.mutate({ id: item.id, starred: !item.starred });\n              }}\n              className={clsx('px-2 py-1 rounded border', item.starred ? 'bg-yellow-300' : 'bg-white')}\n            >\n              {item.starred ? '\u2605' : '\u2606'}\n            </button>\n          </div>\n        </div>\n      );\n    },\n    [onKeyDown, activeIndex]\n  );\n\n  // live region for status (loading / websocket)\n  const statusMessage = useMyComponentUtils().formatStatus({\n    isFetchingNextPage,\n    status,\n    wsStatus,\n  });\n\n  // ensure sanitized snippets if we had HTML - demonstration of sanitizer:\n  // Note: sanitizeHtml will be no-op on server by default (returns input); consumer can call serverSanitizeHtml for server sanitization.\n  useEffect(() => {\n    let mounted = true;\n    async function run() {\n      // Example of safely creating sanitized markup for the first item (demo only)\n      if (items[0]?.htmlSnippet) {\n        const safe = await sanitizeHtml(items[0].htmlSnippet);\n        if (!mounted) return;\n        // for demo, we might store or set innerHTML safely; here we do nothing but show pattern\n        void safe;\n      }\n    }\n    run();\n    return () => {\n      mounted = false;\n    };\n  }, [items]);\n\n  return (\n    <div className=\"w-full\" style={{ width }}>\n      <div className=\"flex justify-between items-center p-2\">\n        <h2 className=\"text-lg font-semibold\">{props.title ?? 'Items'}</h2>\n        <div className=\"text-sm text-gray-600\">WS: {wsStatus}</div>\n      </div>\n\n      <div\n        role=\"grid\"\n        aria-label={ariaLabel}\n        className={clsx('border rounded', styles.container)}\n        style={{ height }}\n      >\n        <div role=\"rowgroup\" className=\"h-full\">\n          <AutoSizer>\n            {({ height: autoH, width: autoW }) => (\n              <List\n                height={autoH}\n                width={autoW}\n                itemCount={items.length + (hasNextPage ? 1 : 0)}\n                itemSize={itemHeight}\n                ref={listRef}\n                itemData={itemData}\n                role=\"presentation\"\n              >\n                {Row}\n              </List>\n            )}\n          </AutoSizer>\n        </div>\n      </div>\n\n      <div aria-live=\"polite\" className=\"sr-only\" role=\"status\">\n        {statusMessage}\n      </div>\n\n      <div className=\"mt-2 text-xs text-gray-500\">\n        <button\n          onClick={() => {\n            refetch();\n          }}\n          className=\"underline\"\n        >\n          Refresh\n        </button>\n        <button\n          onClick={() => {\n            // example of sending a ping via websocket\n            send?.({ type: 'ping' });\n          }}\n          className=\"ml-2 underline\"\n        >\n          Ping WS\n        </button>\n      </div>\n    </div>\n  );\n});\n```\n\nsrc/components/MyComponent/MyComponent.module.css\n```css\n/* Tailwind utilities are used via className in JSX.\n   Scoped overrides / container tweaks are placed here. */\n\n:global(.sr-only) {\n  position: absolute !important;\n  width: 1px !important;\n  height: 1px !important;\n  padding: 0 !important;\n  margin: -1px !important;\n  overflow: hidden !important;\n  clip: rect(0, 0, 0, 0) !important;\n  white-space: nowrap !important;\n  border: 0 !important;\n}\n\n.container {\n  /* Tailwind handles most styling; ensure container query friendliness */\n}\n\n/* row style */\n.row {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.04);\n}\n\n/* allow RTL awareness using dir attribute on root element */\n:host([dir='rtl']) .row {\n  direction: rtl;\n}\n```\n\nsrc/components/MyComponent/hooks/useMyComponentData.ts\n```ts\nimport { useInfiniteQuery } from '@tanstack/react-query';\nimport { PageResponse, QueryParams, Item } from '../types';\n\n/**\n * useMyComponentData\n *\n * A typed data hook that performs cursor-based infinite fetching using @tanstack/react-query's useInfiniteQuery.\n * It is SSR-safe: fetches are made in effects and the fetcher supports AbortController via the `signal` parameter.\n *\n * Generics:\n * - T: the item type returned by pages (default Item).\n *\n * @param options - { apiBase, queryParams }\n * @returns react-query result plus convenience \"items\" array and queryKey for optimistic updates.\n */\nexport function useMyComponentData<T extends Item = Item>(options: {\n  apiBase: string;\n  queryParams?: QueryParams;\n  enabled?: boolean;\n}) {\n  const apiBase = options.apiBase;\n  const queryParams = options.queryParams ?? {};\n  const enabled = options.enabled ?? true;\n\n  const queryKey = ['mycomponent', queryParams] as const;\n\n  async function fetchPage({\n    pageParam = null,\n    signal,\n  }: {\n    pageParam?: string | null;\n    signal?: AbortSignal;\n  }): Promise<PageResponse<T>> {\n    const params = new URLSearchParams();\n    if (queryParams.filter) params.set('filter', queryParams.filter);\n    if (queryParams.pageSize) params.set('pageSize', String(queryParams.pageSize));\n    if (pageParam) params.set('cursor', pageParam);\n\n    const res = await fetch(`${apiBase}/items?${params.toString()}`, {\n      signal,\n    });\n    if (!res.ok) {\n      const text = await res.text();\n      throw new Error(`Failed to fetch: ${res.status} ${text}`);\n    }\n    const data = (await res.json()) as PageResponse<T>;\n    return data;\n  }\n\n  const query = useInfiniteQuery(\n    queryKey,\n    /**\n     * useInfiniteQuery fetcher follows the required pattern:\n     * ({ pageParam, signal }) => fetchPage({ pageParam, signal })\n     */\n    ({ pageParam = null, signal }) => fetchPage({ pageParam, signal }),\n    {\n      enabled,\n      getNextPageParam: (lastPage) => lastPage.nextCursor ?? undefined,\n    }\n  );\n\n  const items = query.data?.pages.flatMap((p) => p.items) ?? [];\n\n  return {\n    ...query,\n    items,\n    queryKey,\n    // We expose apiBase for optimistic update helpers that may need to call server APIs.\n    apiBase,\n  };\n}\n```\n\nsrc/components/MyComponent/hooks/useMyComponentWebSocket.ts\n```ts\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { WebSocketStatus } from '../types';\n\n/**\n * useMyComponentWebSocket\n *\n * Lightweight WebSocket hook with exponential backoff reconnect and cleanup.\n *\n * - url: websocket url. If falsy or running on server, hook will be a no-op and return disabled interface.\n * - options:\n *    - onMessage(payload) called for parsed JSON messages\n *    - reconnectStrategy: { maxRetries, baseDelayMs }\n *\n * Returns:\n * - send(obj): sends JSON if socket open\n * - status: WebSocketStatus\n *\n * All browser usage is guarded by typeof window !== 'undefined'.\n */\nexport function useMyComponentWebSocket(\n  url: string,\n  options?: {\n    onMessage?: (payload: any) => void;\n    reconnectStrategy?: { maxRetries?: number; baseDelayMs?: number };\n    autoReconnect?: boolean;\n  }\n) {\n  const { onMessage, reconnectStrategy, autoReconnect = true } = options ?? {};\n  const socketRef = useRef<WebSocket | null>(null);\n  const retriesRef = useRef(0);\n  const [status, setStatus] = useState<WebSocketStatus>('idle');\n  const shouldReconnectRef = useRef(autoReconnect);\n\n  const maxRetries = reconnectStrategy?.maxRetries ?? 10;\n  const baseDelayMs = reconnectStrategy?.baseDelayMs ?? 1000;\n\n  const connect = useCallback(() => {\n    if (typeof window === 'undefined') return;\n    if (!url) return;\n    setStatus('connecting');\n    try {\n      const ws = new WebSocket(url);\n      socketRef.current = ws;\n\n      ws.onopen = () => {\n        retriesRef.current = 0;\n        setStatus('open');\n      };\n\n      ws.onmessage = (ev) => {\n        try {\n          const payload = JSON.parse(ev.data);\n          onMessage?.(payload);\n        } catch (err) {\n          // ignore invalid JSON\n        }\n      };\n\n      ws.onclose = () => {\n        setStatus('closed');\n        if (shouldReconnectRef.current && retriesRef.current < maxRetries) {\n          const delay = Math.min(30000, baseDelayMs * 2 ** retriesRef.current);\n          retriesRef.current += 1;\n          setStatus('reconnecting');\n          setTimeout(() => {\n            connect();\n          }, delay);\n        } else {\n          setStatus('closed');\n        }\n      };\n\n      ws.onerror = () => {\n        setStatus('error');\n        // let onclose handle reconnect\n      };\n    } catch (err) {\n      setStatus('error');\n    }\n  }, [url, onMessage, maxRetries, baseDelayMs]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    if (!url) return;\n    shouldReconnectRef.current = autoReconnect;\n    connect();\n    return () => {\n      shouldReconnectRef.current = false;\n      const ws = socketRef.current;\n      if (ws) {\n        try {\n          ws.onopen = null;\n          ws.onmessage = null;\n          ws.onclose = null;\n          ws.onerror = null;\n          ws.close();\n        } catch {\n          //\n        }\n      }\n    };\n    // we intentionally avoid putting connect into deps beyond url to keep stable reconnect semantics\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [url]);\n\n  const send = useCallback(\n    (payload: any) => {\n      if (typeof window === 'undefined') return;\n      const ws = socketRef.current;\n      if (ws?.readyState === WebSocket.OPEN) {\n        try {\n          ws.send(JSON.stringify(payload));\n        } catch {\n          // ignore\n        }\n      }\n    },\n    []\n  );\n\n  return { send, status };\n}\n```\n\nsrc/components/MyComponent/hooks/useMyComponentUtils.ts\n```ts\nimport { useCallback } from 'react';\n\n/**\n * useMyComponentUtils\n *\n * Small utilities for the component (formatting, status strings).\n * Exported as hook to allow memoization and future i18n integration.\n */\nexport function useMyComponentUtils() {\n  const formatStatus = useCallback((opts: { isFetchingNextPage?: boolean; status?: string; wsStatus?: string }) => {\n    const parts: string[] = [];\n    if (opts.status) parts.push(`load:${opts.status}`);\n    if (opts.isFetchingNextPage) parts.push('loading-more');\n    if (opts.wsStatus) parts.push(`ws:${opts.wsStatus}`);\n    return parts.join(' ');\n  }, []);\n\n  return { formatStatus };\n}\n```\n\nsrc/components/MyComponent/context/MyComponentContext.tsx\n```tsx\nimport React, { createContext, useContext } from 'react';\n\n/**\n * MyComponentContextValue\n *\n * Defines runtime configuration for MyComponent consumer code.\n */\nexport type MyComponentContextValue = {\n  apiBase: string;\n  wsBase: string;\n};\n\n/**\n * MyComponentProvider\n *\n * Provides context values required for data fetching and websockets.\n *\n * NOTE: Keep defaults minimal. Consumers should configure with real endpoints.\n */\nconst MyComponentContext = createContext<MyComponentContextValue | undefined>(undefined);\n\nexport const MyComponentProvider: React.FC<{ value: MyComponentContextValue; children: React.ReactNode }> = ({\n  value,\n  children,\n}) => {\n  return <MyComponentContext.Provider value={value}>{children}</MyComponentContext.Provider>;\n};\n\n/**\n * useMyComponentContext\n *\n * Hook to access MyComponent configuration. Throws when used outside provider to ensure correct usage.\n */\nexport function useMyComponentContext(): MyComponentContextValue {\n  const ctx = useContext(MyComponentContext);\n  if (!ctx) {\n    throw new Error('useMyComponentContext must be used within a MyComponentProvider');\n  }\n  return ctx;\n}\n```\n\nsrc/components/MyComponent/types.ts\n```ts\n/**\n * Public types for MyComponent package.\n *\n * No \"any\" on exported types; all generics are constrained.\n */\n\n/** Item - core data type represented by the list */\nexport type Item = {\n  id: string;\n  title: string;\n  subtitle?: string;\n  htmlSnippet?: string;\n  starred?: boolean;\n  createdAt?: string;\n};\n\n/** Cursor-based page response */\nexport type PageResponse<T> = {\n  items: T[];\n  nextCursor?: string | null;\n};\n\n/** Query params accepted by useMyComponentData */\nexport type QueryParams = {\n  filter?: string;\n  pageSize?: number;\n};\n\n/** Props for the MyComponent component */\nexport type MyComponentProps = {\n  title?: string;\n  queryParams?: QueryParams;\n  apiBase?: string; // deprecated: prefer provider; allowed for flexibility in demos\n  itemHeight?: number;\n  height?: number;\n  width?: number | string;\n  ariaLabel?: string;\n  showWebSocket?: boolean;\n  onItemClick?: (item: Item) => void;\n};\n\n/** WebSocket status enum as string union */\nexport type WebSocketStatus = 'idle' | 'connecting' | 'open' | 'reconnecting' | 'error' | 'closed';\n```\n\nsrc/components/MyComponent/utils.ts\n```ts\n/**\n * Internal helpers (not exported from package barrel).\n *\n * Keep SSR-safe \u2014 no window/document usage at module load time.\n */\n\n/**\n * sanitizeHtml\n *\n * Dynamically imports isomorphic-dompurify on the client to sanitize HTML.\n * On server it returns the input (no-op) to avoid relying on DOM. Consumers that\n * want server-side sanitization should call serverSanitizeHtml.\n *\n * Usage example shown in README/doc/demo.\n */\nexport async function sanitizeHtml(html: string): Promise<string> {\n  if (typeof window === 'undefined') {\n    // No DOM available in SSR; return input or use serverSanitizeHtml in server code.\n    return html;\n  }\n  // dynamic import to avoid bundling into SSR output\n  const DOMPurify = (await import('isomorphic-dompurify')).default;\n  return DOMPurify.sanitize(html);\n}\n\n/**\n * serverSanitizeHtml\n *\n * Server-side sanitization method: imports isomorphic-dompurify and sanitizes on the server.\n * This function is safe to call in server environments (Node).\n */\nexport async function serverSanitizeHtml(html: string): Promise<string> {\n  const DOMPurify = (await import('isomorphic-dompurify')).default;\n  return DOMPurify.sanitize(html);\n}\n```\n\nsrc/components/MyComponent/ErrorBoundary.tsx\n```tsx\nimport React from 'react';\n\ntype Props = {\n  fallback?: React.ReactNode;\n  onError?: (error: Error, info: React.ErrorInfo) => void;\n  onReset?: () => void;\n  children: React.ReactNode;\n};\n\ntype State = {\n  error: Error | null;\n  resetKey: number;\n};\n\n/**\n * ErrorBoundary\n *\n * Class-based ErrorBoundary with reset capability and typed props.\n *\n * Props:\n * - fallback?: ReactNode - UI shown when an error occurs\n * - onError?: (error, info) => void - callback when an error happens\n * - onReset?: () => void - optional reset callback invoked when the boundary resets\n */\nexport class ErrorBoundary extends React.Component<Props, State> {\n  state: State = { error: null, resetKey: 0 };\n\n  static getDerivedStateFromError(error: Error) {\n    return { error };\n  }\n\n  componentDidCatch(error: Error, info: React.ErrorInfo) {\n    this.props.onError?.(error, info);\n  }\n\n  reset = () => {\n    this.setState((s) => ({ error: null, resetKey: s.resetKey + 1 }));\n    this.props.onReset?.();\n  };\n\n  render() {\n    if (this.state.error) {\n      if (this.props.fallback) {\n        return (\n          <div role=\"alert\">\n            {this.props.fallback}\n            <div>\n              <button onClick={this.reset}>Try again</button>\n            </div>\n          </div>\n        );\n      }\n      return (\n        <div role=\"alert\">\n          <p>Something went wrong.</p>\n          <button onClick={this.reset}>Try again</button>\n        </div>\n      );\n    }\n    return <>{this.props.children}</>;\n  }\n}\n```\n\nsrc/components/MyComponent/serviceWorker.ts\n```ts\n/**\n * Service worker registration snippet (client-only).\n *\n * Usage: call registerServiceWorker({ onUpdateAvailable }) in client entrypoints (inside useEffect).\n *\n * This file does not register SW at module-eval time; registration is performed by calling the function.\n */\n\nexport function registerServiceWorker(opts?: { onUpdateAvailable?: () => void }) {\n  if (typeof window === 'undefined' || !('serviceWorker' in navigator)) return;\n\n  const { onUpdateAvailable } = opts ?? {};\n\n  navigator.serviceWorker\n    .register('/sw.js')\n    .then((registration) => {\n      // Listen for updates\n      registration.addEventListener('updatefound', () => {\n        const newWorker = registration.installing;\n        if (!newWorker) return;\n        newWorker.addEventListener('statechange', () => {\n          if (newWorker.state === 'installed') {\n            // New update available\n            onUpdateAvailable?.();\n          }\n        });\n      });\n    })\n    .catch(() => {\n      // registration failed - ignore gracefully in client code\n    });\n}\n```\n\nsrc/components/MyComponent/fixtures/sampleData.ts\n```ts\nimport { Item } from '../types';\n\nexport const SAMPLE_ITEMS: Item[] = Array.from({ length: 50 }).map((_, i) => ({\n  id: `item-${i + 1}`,\n  title: `Item ${i + 1}`,\n  subtitle: `Subtitle ${i + 1}`,\n  htmlSnippet: `<p>Snippet <strong>${i + 1}</strong></p>`,\n  starred: i % 7 === 0,\n  createdAt: new Date(Date.now() - i * 1000 * 60).toISOString(),\n}));\n```\n\nsrc/components/MyComponent/__tests__/test-utils.tsx\n```tsx\nimport React from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { render } from '@testing-library/react';\n\n/**\n * createTestQueryClient\n *\n * Returns a fresh QueryClient suitable for tests. Retries are disabled by default for deterministic behavior.\n */\nexport function createTestQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        retry: false,\n      },\n      mutations: {\n        retry: false,\n      },\n    },\n  });\n}\n\n/**\n * renderWithClient - helper to render components wrapped in QueryClientProvider.\n */\nexport function renderWithClient(ui: React.ReactElement) {\n  const client = createTestQueryClient();\n  return {\n    ...render(<QueryClientProvider client={client}>{ui}</QueryClientProvider>),\n    client,\n  };\n}\n```\n\nsrc/components/MyComponent/__tests__/useMyComponentData.test.tsx\n```tsx\n/**\n * Tests useMyComponentData pagination using MSW to provide cursor-based responses.\n *\n * - Verifies that useInfiniteQuery is used and pages are concatenated.\n */\n\nimport React from 'react';\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { renderHook, act } from '@testing-library/react-hooks';\nimport { createTestQueryClient } from './test-utils';\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { useMyComponentData } from '../hooks/useMyComponentData';\nimport { PageResponse } from '../types';\n\nconst server = setupServer();\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ntest('concatenates pages and uses nextCursor', async () => {\n  const apiBase = 'https://api.test';\n  // page 1\n  server.use(\n    rest.get(`${apiBase}/items`, (req, res, ctx) => {\n      const cursor = req.url.searchParams.get('cursor');\n      if (!cursor) {\n        const page: PageResponse<{ id: string; title: string }> = {\n          items: [\n            { id: '1', title: 'one' },\n            { id: '2', title: 'two' },\n          ],\n          nextCursor: 'cursor-2',\n        };\n        return res(ctx.json(page));\n      }\n      if (cursor === 'cursor-2') {\n        const page: PageResponse<{ id: string; title: string }> = {\n          items: [{ id: '3', title: 'three' }],\n          nextCursor: null,\n        };\n        return res(ctx.json(page));\n      }\n      return res(ctx.status(404));\n    })\n  );\n\n  const client = createTestQueryClient();\n  const wrapper = ({ children }: any) => <QueryClientProvider client={client}>{children}</QueryClientProvider>;\n\n  const { result, waitFor } = renderHook(\n    () => useMyComponentData<{ id: string; title: string }>({ apiBase, queryParams: { pageSize: 2 } }),\n    { wrapper }\n  );\n\n  // initial fetch\n  await waitFor(() => result.current.items.length === 2);\n  expect(result.current.items.map((i) => i.title)).toEqual(['one', 'two']);\n\n  // fetch next\n  await act(async () => {\n    await result.current.fetchNextPage();\n  });\n\n  expect(result.current.items.map((i) => i.title)).toEqual(['one', 'two', 'three']);\n  expect(result.current.hasNextPage).toBe(false);\n});\n```\n\nsrc/components/MyComponent/__tests__/virtualization.test.tsx\n```tsx\n/**\n * Tests the virtualized list sentinel triggers fetchNextPage.\n */\n\nimport React from 'react';\nimport { render, waitFor, screen } from '@testing-library/react';\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { MyComponent } from '../MyComponent';\nimport { MyComponentProvider } from '../context/MyComponentContext';\nimport { createTestQueryClient } from './test-utils';\nimport { QueryClientProvider } from '@tanstack/react-query';\n\nconst apiBase = 'https://api.test';\nconst wsBase = 'wss://ws.test';\n\nconst server = setupServer();\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ntest('sentinel triggers fetchNextPage and shows loading row', async () => {\n  server.use(\n    rest.get(`${apiBase}/items`, (req, res, ctx) => {\n      const cursor = req.url.searchParams.get('cursor');\n      if (!cursor) {\n        return res(\n          ctx.json({\n            items: Array.from({ length: 5 }).map((_, i) => ({ id: `p1-${i}`, title: `p1-${i}` })),\n            nextCursor: 'c2',\n          })\n        );\n      }\n      if (cursor === 'c2') {\n        return res(\n          ctx.json({\n            items: Array.from({ length: 3 }).map((_, i) => ({ id: `p2-${i}`, title: `p2-${i}` })),\n            nextCursor: null,\n          })\n        );\n      }\n      return res(ctx.status(404));\n    })\n  );\n\n  const client = createTestQueryClient();\n  const { container } = render(\n    <QueryClientProvider client={client}>\n      <MyComponentProvider value={{ apiBase, wsBase }}>\n        <div style={{ width: 400, height: 300 }}>\n          <MyComponent queryParams={{ pageSize: 5 }} itemHeight={50} height={300} />\n        </div>\n      </MyComponentProvider>\n    </QueryClientProvider>\n  );\n\n  // wait for initial items to render\n  await waitFor(() => {\n    expect(container.querySelectorAll('[role=\"row\"]').length).toBeGreaterThan(0);\n  });\n\n  // scroll sentinel by forcing fetchNextPage (simulate user scroll)\n  // Because react-window virtualization is used, we cannot easily scroll in the test environment,\n  // but sentinel triggers fetchNextPage on render index >= items.length; ensure fetch completes by waiting for new item text\n  await waitFor(() => {\n    expect(container.textContent).toContain('p2-0');\n  });\n});\n```\n\nsrc/components/MyComponent/__tests__/optimistic.test.tsx\n```tsx\n/**\n * Tests optimistic mutation flow:\n * - optimistic UI update\n * - rollback on server error\n *\n * Uses MSW to simulate server error response.\n */\n\nimport React from 'react';\nimport { render, screen, waitFor } from '@testing-library/react';\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { MyComponent } from '../MyComponent';\nimport { MyComponentProvider } from '../context/MyComponentContext';\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { createTestQueryClient } from './test-utils';\n\nconst apiBase = 'https://api.test';\nconst wsBase = 'wss://ws.test';\n\nconst server = setupServer();\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ntest('optimistic update then rollback on server error', async () => {\n  // initial list\n  server.use(\n    rest.get(`${apiBase}/items`, (req, res, ctx) => {\n      return res(\n        ctx.json({\n          items: [{ id: '1', title: 'one', starred: false }],\n          nextCursor: null,\n        })\n      );\n    }),\n    // patch will return 500 to trigger rollback\n    rest.patch(`${apiBase}/items/1`, (req, res, ctx) => {\n      return res(ctx.status(500));\n    })\n  );\n\n  const client = createTestQueryClient();\n  render(\n    <QueryClientProvider client={client}>\n      <MyComponentProvider value={{ apiBase, wsBase }}>\n        <div style={{ width: 400, height: 200 }}>\n          <MyComponent />\n        </div>\n      </MyComponentProvider>\n    </QueryClientProvider>\n  );\n\n  // ensure loaded\n  await waitFor(() => screen.getByText('one'));\n\n  // click star button to toggle optimistic state\n  const starButton = screen.getByRole('button', { name: /Star item/ });\n  starButton.click();\n\n  // optimistic UI should reflect starred state\n  await waitFor(() => {\n    expect(starButton).toHaveTextContent('\u2605');\n  });\n\n  // after server error, rollback to unstarred\n  await waitFor(() => {\n    expect(starButton).toHaveTextContent('\u2606');\n  });\n});\n```\n\nsrc/components/MyComponent/__tests__/websocket.test.tsx\n```tsx\n/**\n * Tests WebSocket hook by mocking global WebSocket and ensuring onMessage callback causes state updates.\n */\n\nimport React from 'react';\nimport { render, waitFor, screen } from '@testing-library/react';\nimport { MyComponent } from '../MyComponent';\nimport { MyComponentProvider } from '../context/MyComponentContext';\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { createTestQueryClient } from './test-utils';\n\nconst apiBase = 'https://api.test';\nconst wsBase = 'wss://ws.test';\n\nclass MockWebSocket {\n  url: string;\n  onopen: (() => void) | null = null;\n  onmessage: ((ev: { data: string }) => void) | null = null;\n  onclose: (() => void) | null = null;\n  onerror: (() => void) | null = null;\n  readyState = 1;\n  constructor(url: string) {\n    this.url = url;\n    setTimeout(() => this.onopen?.(), 0);\n  }\n  send(data: string) {\n    // echo back a payload for tests when ping is sent\n    try {\n      const parsed = JSON.parse(data);\n      if (parsed?.type === 'ping') {\n        setTimeout(() => this.onmessage?.({ data: JSON.stringify({ type: 'upsert', item: { id: 'ws-1', title: 'from-ws' } }) }), 0);\n      }\n    } catch {}\n  }\n  close() {\n    this.readyState = 3;\n    this.onclose?.();\n  }\n}\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var OriginalWebSocket: any;\n}\n\nbeforeAll(() => {\n  // save original\n  // @ts-ignore\n  global.OriginalWebSocket = (global as any).WebSocket;\n  // @ts-ignore\n  (global as any).WebSocket = MockWebSocket;\n});\nafterAll(() => {\n  // restore\n  // @ts-ignore\n  (global as any).WebSocket = global.OriginalWebSocket;\n});\n\ntest('websocket messages update UI', async () => {\n  const client = createTestQueryClient();\n\n  // initial list empty\n  render(\n    <QueryClientProvider client={client}>\n      <MyComponentProvider value={{ apiBase, wsBase }}>\n        <div style={{ width: 400, height: 200 }}>\n          <MyComponent showWebSocket />\n        </div>\n      </MyComponentProvider>\n    </QueryClientProvider>\n  );\n\n  // trigger ping to echo a message from mock socket\n  const ping = screen.getByText('Ping WS');\n  ping.click();\n\n  await waitFor(() => {\n    expect(screen.getByText('from-ws')).toBeInTheDocument();\n  });\n});\n```\n\nsrc/components/MyComponent/__tests__/accessibility.test.tsx\n```tsx\n/**\n * Accessibility tests with axe-core\n *\n * Ensures the rendered MyComponent has no critical accessibility violations.\n */\n\nimport React from 'react';\nimport { render } from '@testing-library/react';\nimport { axe } from 'jest-axe';\nimport { MyComponent } from '../MyComponent';\nimport { MyComponentProvider } from '../context/MyComponentContext';\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { createTestQueryClient } from './test-utils';\n\ntest('has no obvious accessibility issues', async () => {\n  const client = createTestQueryClient();\n  const { container } = render(\n    <QueryClientProvider client={client}>\n      <MyComponentProvider value={{ apiBase: 'https://api.test', wsBase: 'wss://ws.test' }}>\n        <div style={{ width: 400, height: 300 }}>\n          <MyComponent />\n        </div>\n      </MyComponentProvider>\n    </QueryClientProvider>\n  );\n\n  const results = await axe(container);\n  expect(results).toHaveNoViolations();\n});\n```\n\nsrc/components/MyComponent/README.md\n```md\n# MyComponent\n\nA production-ready, SSR-safe React + TypeScript component featuring:\n- Virtualized infinite scrolling (react-window)\n- Cursor-based pagination via @tanstack/react-query useInfiniteQuery\n- Optimistic mutations with rollback\n- WebSocket updates with reconnect\n- SSR-friendly sanitization (isomorphic-dompurify)\n- Accessibility (roles, roving tabindex, keyboard support)\n- Tests with Jest, React Testing Library, MSW, and axe\n\n## Exports\n- MyComponent (React component)\n- MyComponentProps (props type)\n- MyComponentProvider, useMyComponentContext (context)\n- useMyComponentData (data hook)\n- useMyComponentWebSocket (websocket hook)\n- ErrorBoundary\n- registerServiceWorker (client-only)\n- sanitizeHtml, serverSanitizeHtml\n\n## Basic usage\n\nWrap your app with a QueryClientProvider and MyComponentProvider:\n\n```tsx\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { MyComponentProvider, MyComponent } from 'your-library';\n\nconst queryClient = new QueryClient();\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <MyComponentProvider value={{ apiBase: 'https://api.example', wsBase: 'wss://ws.example' }}>\n        <MyComponent />\n      </MyComponentProvider>\n    </QueryClientProvider>\n  );\n}\n```\n\nNotes:\n- The library does not export or force a global QueryClient. Create your QueryClient with desired defaults (e.g., retry strategies).\n- To enable service worker registration and websockets, call registerServiceWorker and render MyComponent on the client.\n\n## Data fetching hook - useMyComponentData\n\nExample pattern (cursor-based):\n```ts\nasync function fetchPage({ pageParam = null, signal }) {\n  const res = await fetch(`/api/items?cursor=${pageParam}`, { signal });\n  return res.json();\n}\n\nconst q = useInfiniteQuery(['items', params], ({ pageParam, signal }) => fetchPage({ pageParam, signal }), {\n  getNextPageParam: last => last.nextCursor ?? undefined\n});\n\nconst items = q.data?.pages.flatMap(p => p.items) ?? [];\n```\n\nAbortController support: the hook's fetcher receives a `signal` and will cancel fetches on component unmount.\n\nAlternative page-offset pagination can be implemented by consumers; the default hook uses cursor-based responses of shape:\n```ts\n{ items: T[]; nextCursor?: string | null }\n```\n\n## Optimistic mutation flow\n\nExample (already implemented in component):\n```ts\nconst mutation = useMutation(updateFn, {\n  onMutate: async (newItem) => {\n    await queryClient.cancelQueries(queryKey);\n    const previous = queryClient.getQueryData(queryKey);\n    queryClient.setQueryData(queryKey, (old) => /* optimistic update */);\n    return { previous };\n  },\n  onError: (err, newItem, context) => {\n    queryClient.setQueryData(queryKey, context.previous);\n  },\n  onSettled: () => {\n    queryClient.invalidateQueries(queryKey);\n  }\n});\n```\n\n## Sanitization\n\nUse `sanitizeHtml` on client (no-op on server). For server-side sanitization, use `serverSanitizeHtml` so HTML is sanitized at build-time or SSR time.\n\nPattern:\n```ts\nconst safeHtml = await sanitizeHtml(rawHtml); // client-only sanitization\n// server-side:\nconst safeServer = await serverSanitizeHtml(rawHtml);\n```\n\n## Tests\n\nRun tests:\n- yarn test\n- jest runs tests using JSDOM; tests create fresh QueryClient instances per test.\n\n## SSR notes\n\n- No browser globals are accessed at module load time.\n- WebSockets and service worker registration run only in client contexts (guarded).\n- For server-side rendering of HTML snippets, call `serverSanitizeHtml` during SSR to avoid passing raw HTML to the client.\n\n## Accessibility\n\n- Uses role=\"grid\", role=\"rowgroup\", role=\"row\".\n- Implements roving tabindex (keyboard navigation) with Arrow keys and Home/End.\n- Live region for async statuses.\n- Respects prefers-reduced-motion via CSS where animations are used (none by default).\n\n## Security & CSP\n\n- Avoid using dangerouslySetInnerHTML with unsafe content.\n- Sanitize dynamic HTML.\n- Recommended CSP headers:\n  - Content-Security-Policy: default-src 'self'; script-src 'self'; object-src 'none'; base-uri 'none';\n  - Strict-Transport-Security: max-age=63072000; includeSubDomains; preload\n\n## CI\n\nSee `.github/workflows/ci.yml` sample for an example workflow that runs lint, typecheck, tests, and build.\n\n## TODO / Production hardening\n\n- Integrate real Sentry or analytics using adapter stubs in code (places marked TODO).\n- Fine-tune QueryClient defaults for background refetch behavior.\n- Add localization / RTL testing where needed.\n```\n\ntailwind.config.js\n```js\n/** Tailwind config suggestion (tokens + container queries sample)\n *\n * Consumers should adapt to their design system. This file demonstrates:\n * - custom color token\n * - container query example using @tailwindcss/container-queries (if desired)\n */\nmodule.exports = {\n  content: ['./src/**/*.{js,ts,jsx,tsx}'],\n  theme: {\n    extend: {\n      colors: {\n        brand: {\n          50: '#f5f7ff',\n          500: '#3b82f6',\n        },\n      },\n    },\n  },\n  plugins: [\n    // require('@tailwindcss/container-queries') // optional plugin if using container queries\n  ],\n};\n```\n\ndocs/demo.tsx\n```tsx\n/**\n * SSR-ready demo page (framework-agnostic).\n *\n * Example of how to configure QueryClientProvider and hydrate on the client.\n *\n * Notes:\n * - Preload fonts can be added in the server HTML template:\n *   <link rel=\"preload\" href=\"/fonts/Inter.woff2\" as=\"font\" type=\"font/woff2\" crossorigin>\n *\n * - Service worker registration must be called on client (inside useEffect).\n */\n\nimport React, { Suspense, useEffect } from 'react';\nimport { QueryClient, QueryClientProvider, Hydrate } from '@tanstack/react-query';\nimport { MyComponentProvider, MyComponent, registerServiceWorker } from '../src/components/MyComponent';\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\n\n// Consumer controls QueryClient - do not export a global with forced suspense.\nexport function Demo({ dehydratedState }: { dehydratedState?: unknown }) {\n  const [queryClient] = React.useState(() => new QueryClient());\n\n  useEffect(() => {\n    // client-only features\n    if (typeof window !== 'undefined') {\n      registerServiceWorker({\n        onUpdateAvailable: () => {\n          // show toast to user\n          console.log('SW update available');\n        },\n      });\n    }\n  }, []);\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Hydrate state={dehydratedState}>\n        <MyComponentProvider value={{ apiBase: 'https://api.example', wsBase: 'wss://ws.example' }}>\n          <Suspense fallback={<div>Loading component\u2026</div>}>\n            <div style={{ width: 800, height: 600 }}>\n              <MyComponent title=\"Demo Items\" />\n            </div>\n          </Suspense>\n        </MyComponentProvider>\n      </Hydrate>\n      <ReactQueryDevtools initialIsOpen={false} />\n    </QueryClientProvider>\n  );\n}\n\n/**\n * SSR consideration:\n * - Render a server-side HTML shell and include dehydratedState if you used SSR prefetching.\n * - For server-side sanitization of any HTML snippets, call serverSanitizeHtml during data fetching.\n */\n```\n\nci/github-actions.yml\n```yml\nname: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Use Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 18\n      - name: Install\n        run: yarn install --frozen-lockfile\n      - name: Typecheck\n        run: yarn tsc --noEmit\n      - name: Lint\n        run: yarn lint\n      - name: Test\n        run: yarn test --runInBand --coverage\n      - name: Build\n        run: yarn build\n```\n\nNotes and small guidance (in-code comments)\n- All network fetches use AbortController via react-query's signal param in useInfiniteQuery fetcher.\n- No window/document usage at module top-level; client-only features are guarded with typeof window !== 'undefined'.\n- Consumers should provide their own QueryClient configuration. Example uses QueryClient in demo and tests createTestQueryClient in tests.\n- CSP and security hints are present in README.\n\nPackage test commands (suggested in package.json \u2014 not included here):\n- \"test\": \"jest\"\n- \"lint\": \"eslint 'src/**/*.{ts,tsx}'\"\n- \"build\": \"tsc -p tsconfig.build.json\"\n\nEnd of deliverable."