"Below is a self-contained, production-ready polymorphic Button implementation in React + TypeScript with Tailwind, accessibility considerations, and a small test scaffold. It follows the polymorphic typing strategy you specified and includes a minimal test suite, typings, and usage guidance.\n\nProject structure (recommended)\n- src/\n  - components/\n    - Button/\n      - index.ts\n      - Button.tsx\n      - Button.types.ts\n      - Button.styles.ts\n      - Button.spinner.tsx\n      - Button.test.tsx\n  - utils/\n    - clsxImportGuide.md\n  - story/\n    - Button.stories.tsx\n  - hooks/\n  - tests/\n    - (optional global tests)\n- package.json (dependencies for React 18+, TypeScript, Tailwind, testing)\n\nNote: This is a compact, production-like implementation. You can expand on stories and docs as needed.\n\nCode excerpts\n\n1) src/components/Button/Button.types.ts\n- Precise polymorphic prop definitions with a single source of truth for underlying As element props.\n\n```ts\nimport type React from 'react';\n\nexport type ButtonOwnProps<As extends React.ElementType = 'button'> = {\n  as?: As;\n  children?: React.ReactNode;\n  ariaLabel?: string;\n  loading?: boolean;\n  disabled?: boolean;\n  fullWidth?: boolean;\n  variant?: 'solid' | 'outline' | 'ghost' | 'link';\n  size?: 'xs' | 'sm' | 'md' | 'lg';\n  leftIcon?: React.ReactNode;\n  rightIcon?: React.ReactNode;\n  className?: string;\n  // Optional click handler; actual onClick may come from As props, so we forward/compose carefully\n  onClick?: React.MouseEventHandler<any>;\n};\n\nexport type ButtonProps<As extends React.ElementType> = ButtonOwnProps<As> &\n  Omit<React.ComponentPropsWithoutRef<As>, keyof ButtonOwnProps<As> | 'as'>;\n```\n\n2) src/components/Button/Button.styles.ts\n- Tailwind-based tokens and a single source of truth for variants, sizes, and layout.\n\n```ts\nimport clsx from 'clsx';\n\ntype Variants = 'solid' | 'outline' | 'ghost' | 'link';\ntype Sizes = 'xs' | 'sm' | 'md' | 'lg';\n\nexport const variantClasses: Record<Variants, string> = {\n  solid:\n    'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500 disabled:bg-blue-500',\n  outline:\n    'border border-blue-600 text-blue-600 bg-transparent hover:bg-blue-50 focus:ring-blue-500 disabled:bg-blue-50',\n  ghost:\n    'bg-transparent text-blue-600 hover:bg-blue-50 focus:ring-blue-500 disabled:bg-blue-50',\n  link:\n    'bg-transparent text-blue-600 underline-offset-2 hover:underline focus:ring-0',\n};\n\nexport const sizeClasses: Record<Sizes, string> = {\n  xs: 'px-2 py-1 text-xs',\n  sm: 'px-3 py-2 text-sm',\n  md: 'px-4 py-2 text-sm',\n  lg: 'px-4 py-3 text-base',\n};\n\n// base button styling\nexport const baseClasses =\n  'inline-flex items-center justify-center rounded-md font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-2';\n\nexport const fullWidthClass = 'w-full';\n\n// utility for combining classes\nexport function cx(...classes: (string | false | null | undefined)[]) {\n  return clsx(classes);\n}\n```\n\n3) src/components/Button/Button.spinner.tsx\n- Accessible spinner with aria-label; visually small and consistent.\n\n```tsx\nimport React from 'react';\n\nexport const Spinner: React.FC<{ ariaLabel?: string }> = ({\n  ariaLabel = 'Loading',\n}) => {\n  // Small circular spinner; aria-label ensures testability\n  return (\n    <span\n      role=\"status\"\n      aria-label={ariaLabel}\n      className=\"inline-block w-4 h-4 border-2 border-current border-t-transparent rounded-full animate-spin\"\n    />\n  );\n};\n\nexport default Spinner;\n```\n\n4) src/components/Button/Button.tsx\n- The polymorphic Button implementation with precise typing, ref forwarding, and accessibility.\n\n```tsx\nimport React from 'react';\nimport { Spinner } from './Button.spinner';\nimport { ButtonProps, ButtonOwnProps } from './Button.types';\nimport { baseClasses, sizeClasses, variantClasses, fullWidthClass, cx } from './Button.styles';\n\ntype ButtonForwardRef = <As extends React.ElementType = 'button'>(\n  props: ButtonProps<As> & { ref?: React.Ref<any> }\n) => JSX.Element;\n\nfunction ButtonInner<As extends React.ElementType = 'button'>(\n  props: ButtonProps<As>,\n  ref: React.Ref<any>\n) {\n  const {\n    as,\n    children,\n    ariaLabel,\n    loading = false,\n    disabled = false,\n    fullWidth = false,\n    variant = 'solid',\n    size = 'md',\n    leftIcon,\n    rightIcon,\n    className,\n    onClick: onClickFromProps,\n    ...rest\n  } = props;\n\n  const Element = (as ?? 'button') as React.ElementType;\n\n  // When rendering non-button (e.g., <a>), emulate button semantics\n  const isButtonElement = Element === 'button';\n\n  // Merge classes from design system\n  const computed = cx(\n    baseClasses,\n    sizeClasses[size],\n    variantClasses[variant],\n    fullWidth && fullWidthClass,\n    (loading || disabled) && 'opacity-60 cursor-not-allowed',\n    className\n  );\n\n  // Guarded click handler: do not propagate when loading/disabled\n  const handleClick = (e: React.MouseEvent<any>) => {\n    if (loading || disabled) {\n      e.preventDefault();\n      return;\n    }\n    onClickFromProps?.(e);\n  };\n\n  // Keyboard activation for non-button renderings (Enter/Space)\n  const handleKeyDown = (e: React.KeyboardEvent<any>) => {\n    if (loading || disabled) return;\n    if (!isButtonElement && (e.key === 'Enter' || e.key === ' ')) {\n      e.preventDefault();\n      // Trigger user-provided onClick for non-button elements\n      onClickFromProps?.(e as any);\n    }\n  };\n\n  // Roll in aria-disabled for non-button controls\n  const ariaDisabled = (disabled || loading) ? true : undefined;\n\n  // Ensure focusability for non-button elements\n  const accessibilityProps: any = isButtonElement\n    ? {}\n    : {\n        role: 'button',\n        'aria-disabled': ariaDisabled ?? undefined,\n        tabIndex: 0,\n      };\n\n  // Pass through any intrinsic props from As element while preserving our props\n  // We spread rest first to allow our aria-label to win if provided\n  // and to avoid prop collisions with ButtonOwnProps\n  return (\n    <Element\n      ref={ref}\n      {...rest}\n      {...accessibilityProps}\n      onClick={handleClick}\n      onKeyDown={handleKeyDown}\n      className={computed}\n      aria-label={ariaLabel}\n    >\n      {/* Left icon shown only when not loading to avoid crowding with spinner */}\n      {leftIcon && !loading && <span className=\"mr-2 -ml-0.5\">{leftIcon}</span>}\n\n      {/* Inline loading spinner when loading is true */}\n      {loading && (\n        <span className={leftIcon ? 'mr-2' : 'mr-0'}>\n          <Spinner ariaLabel=\"Loading\" />\n        </span>\n      )}\n\n      {/* Button content/text */}\n      {children}\n\n      {/* Right icon shown only when not loading */}\n      {rightIcon && !loading && <span className=\"ml-2\">{rightIcon}</span>}\n    </Element>\n  );\n}\n\n// Generic wrapper to provide proper typing in consumer code\nconst Button = React.forwardRef(ButtonInner) as unknown as ButtonForwardRef;\n\n// Export types for consumers\nexport type { ButtonProps, ButtonOwnProps };\n\n// Default export\nexport default React.memo(Button);\n```\n\n5) src/components/Button/index.ts\n- Public entry (re-export) to simplify imports.\n\n```ts\nexport { default } from './Button';\nexport type { ButtonProps, ButtonOwnProps } from './Button.types';\n```\n\n6) src/components/Button/Button.test.tsx\n- Deterministic tests for major behaviors (Jest + RTL or Vitest + RTL style).\n\nNote: This test uses React Testing Library + Vitest/Jest style APIs. Adjust import paths if you use Jest vs Vitest.\n\n```tsx\nimport React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport Button from './';\nimport { describe, it, expect, vi } from 'vitest';\nimport CustomComp from './__test-utils__/CustomComp';\n\ndescribe('Button (Polymorphic)', () => {\n  it('renders as a default button and handles click', () => {\n    const onClick = vi.fn();\n    render(\n      <Button onClick={onClick} ariaLabel=\"Submit\">\n        Submit\n      </Button>\n    );\n    const btn = screen.getByRole('button', { name: 'Submit' });\n    expect(btn).toBeInTheDocument();\n    fireEvent.click(btn);\n    expect(onClick).toHaveBeenCalled();\n  });\n\n  it('renders as a polymorphic anchor when as=\"a\"', () => {\n    const onClick = vi.fn();\n    render(\n      <Button as=\"a\" href=\"/path\" onClick={onClick} ariaLabel=\"Go\">\n        Go\n      </Button>\n    );\n    const anchor = screen.getByRole('button', { name: 'Go' });\n    expect(anchor.tagName).toBe('A');\n    fireEvent.click(anchor);\n    expect(onClick).toHaveBeenCalled();\n  });\n\n  it('loading state shows a spinner with aria-label and blocks onClick', () => {\n    const onClick = vi.fn();\n    render(\n      <Button onClick={onClick} ariaLabel=\"Submit\" loading>\n        Submit\n      </Button>\n    );\n    const btn = screen.getByRole('button', { name: 'Submit' });\n    const spinner = screen.getByLabelText('Loading');\n    expect(spinner).toBeInTheDocument();\n    expect(btn).toBeInTheDocument();\n    fireEvent.click(btn);\n    expect(onClick).not.toHaveBeenCalled();\n  });\n\n  it('non-button As is accessible via keyboard (Enter/Space) and triggers onClick', () => {\n    const onClick = vi.fn();\n    render(\n      <Button as=\"a\" href=\"/path\" onClick={onClick} ariaLabel=\"Action\">\n        Action\n      </Button>\n    );\n    const el = screen.getByRole('button', { name: 'Action' });\n    // Simulate Enter\n    fireEvent.keyDown(el, { key: 'Enter', code: 'Enter' });\n    expect(onClick).toHaveBeenCalled();\n  });\n\n  it('ref forwards to the underlying element (button, a, custom)', () => {\n    // Button default\n    const ref1 = React.createRef<HTMLButtonElement>();\n    render(\n      <Button ref={ref1} ariaLabel=\"Button\">\n        Text\n      </Button>\n    );\n    // @ts-ignore\n    expect(ref1.current.tagName).toBe('BUTTON');\n\n    // Anchor\n    const ref2 = React.createRef<HTMLAnchorElement>();\n    render(\n      <Button as=\"a\" href=\"#\" ref={ref2} ariaLabel=\"Link\">\n        Home\n      </Button>\n    );\n    // @ts-ignore\n    expect(ref2.current.tagName).toBe('A');\n\n    // Custom component\n    const Custom = React.forwardRef<HTMLDivElement, any>((props, ref) => (\n      <div ref={ref} {...props} data-testid=\"custom-root\" />\n    ));\n    const ref3 = React.createRef<HTMLDivElement>();\n    render(\n      <Button as={Custom} ref={ref3} ariaLabel=\"Custom\">\n        C\n      </Button>\n    );\n    // @ts-ignore\n    expect(ref3.current.tagName).toBe('DIV');\n  });\n});\n```\n\n7) Minimal usage docs (examples)\n- src/components/Button/README.md (usage notes)\n\n```md\nButton (Polymorphic) - Key Concepts\n\nUsage\n- Default button\n  <Button onClick={handleClick} ariaLabel=\"Submit\" variant=\"solid\" size=\"md\">Submit</Button>\n\n- Polymorphic as an anchor\n  <Button as=\"a\" href=\"/docs\" ariaLabel=\"Docs\" variant=\"outline\" size=\"sm\">Docs</Button>\n\n- Custom component\n  const CustomLink = React.forwardRef<HTMLAnchorElement, any>((props, ref) => (\n    <a ref={ref} {...props} />\n  ));\n  <Button as={CustomLink} href=\"#\" ariaLabel=\"Custom action\" variant=\"ghost\" size=\"md\" />\n\nTyping strategy\n- Button is generic over As extends React.ElementType = 'button'.\n- ButtonProps<As> = ButtonOwnProps<As> & Omit<React.ComponentPropsWithoutRef<As>, keyof ButtonOwnProps<As> | 'as'>.\n- The As prop maps to the actual underlying element props; the ButtonOwnProps provide the shared API.\n\nAccessibility notes\n- Non-button As render with role=\"button\" and aria-disabled when disabled/loading.\n- Keyboard activation: Enter/Space trigger onClick for non-button As.\n- Spinner has aria-label for screen readers.\n\nVariants, sizes, and fullWidth\n- Variants: solid, outline, ghost, link\n- Sizes: xs, sm, md, lg\n- fullWidth: expands to width: 100%\n```\n\n8) Optional helper doc: src/utils/clsxImportGuide.md\n- Short guide on using clsx in this project (if you want to keep a developer doc).\n\n```md\nclsx usage guide\n- Import: import clsx from 'clsx';\n- Merge conditions succinctly:\n  const classes = clsx(base, isActive && 'bg-green-500', className);\n- This project uses a small wrapper (cx) around clsx for consistency:\n  import { cx } from '../Button/Button.styles';\n  const classes = cx(base, isActive && 'bg-green-500', className);\n```\n\n9) Story/usage example (optional)\n- src/story/Button.stories.tsx (if you\u2019re using Storybook)\n\n```tsx\nimport React from 'react';\nimport Button from '../src/components/Button';\n\nexport default {\n  title: 'Components/Button',\n  component: Button,\n};\n\nexport const Basic = () => (\n  <Button ariaLabel=\"Submit\" variant=\"solid\" size=\"md\" onClick={() => {}}>\n    Submit\n  </Button>\n);\n\nexport const AsAnchor = () => (\n  <Button as=\"a\" href=\"/docs\" ariaLabel=\"Docs\" variant=\"outline\" size=\"md\">\n    Docs\n  </Button>\n);\n\nexport const WithIcon = () => (\n  <Button ariaLabel=\"Settings\" variant=\"ghost\" size=\"md\" leftIcon={<span aria-hidden>\u2699\ufe0f</span>}>\n    Settings\n  </Button>\n);\n```\n\n10) Testing setup (tooling hints)\n- Use Vitest or Jest with React Testing Library.\n- Ensure tsconfig and test environment support TS, JSX, and React 18 patterns.\n- Add these devDependencies (example):\n  - react, react-dom, typescript\n  - tailwindcss (plus postcss/preset-env if needed)\n  - @testing-library/react, @testing-library/jest-dom\n  - vitest or jest\n  - ts-jest if using Jest with TS\n  - clsx\n  - eslint, prettier, and their config files for linting/formatting\n\nNotes and considerations\n- Polymorphic typing: ButtonProps<As> uses ButtonOwnProps<As> with Omit<React.ComponentPropsWithoutRef<As>, keyof ButtonOwnProps<As> | 'as'> to avoid collisions. The component uses a generic As type parameter, defaulting to 'button'.\n- Ref forwarding: The Button is implemented with React.forwardRef, preserving the underlying element\u2019s ref (HTMLButtonElement, HTMLAnchorElement, or a DOM element inside a custom component).\n- Accessibility:\n  - Non-button renderings get role=\"button\" and aria-disabled when disabled or loading, with tabIndex for focus.\n  - Enter/Space trigger activation for non-button elements.\n  - Spinner has aria-label, and the overall button uses aria-label (ariaLabel prop) as the primary accessibility name.\n- Styling: Tailwind is used, with a single source of truth for variants, sizes, and fullWidth. Class merging uses a small helper (cx) to avoid prop duplication.\n- Tests: A minimal, deterministic suite covers default rendering, polymorphic rendering, loading state, keyboard activation for non-button As, and ref forwarding.\n\nIf you want, I can tailor this to your exact project stack (specific TS version, preferred test runner, or exact Tailwind tokens). I can also provide a small Git repo scaffold with the above structure and ready-to-run npm scripts."