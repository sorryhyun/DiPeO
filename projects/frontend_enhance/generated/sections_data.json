{
  "architecture": {
    "overview": "Single-page React 18+ dashboard for business analysts, built with TypeScript, Tailwind CSS, React Router, React Query for data fetching, Context API for cross-cutting concerns (auth, theme, i18n), and small local mock servers in development (mock REST endpoints + mock WebSocket). App uses container/presentational split, domain feature folders, and atomic/shared components. Each UI piece is implemented as a self-contained file (component or utility) so teams can develop independently; integration is via well-defined contexts, hooks, and service interfaces. Development mode includes mock data, mock auth, mock APIs and localStorage persistence so the app runs standalone. Emphasis on reusability, type safety, accessibility, and progressive enhancement (Suspense for data, Error Boundaries).",
    "patterns": [
      "Container/Presentational: feature containers use hooks/services to get data and pass props to presentational components",
      "Atomic Design: src/shared/components contains small primitives (Button, Input, Icon) used across features",
      "Domain-driven feature folders: src/features/* with components, hooks, services, types",
      "Context + Hooks: AuthContext, ThemeContext, I18nContext exposing typed hooks (useAuth, useTheme, useI18n)",
      "Boundary patterns: ErrorBoundary components and Suspense boundaries for data fetching",
      "Adapter pattern for API: a single api client interface (src/shared/api/client.ts) which switches between mock and real implementations depending on env"
    ],
    "data_flow": "Data flows from API clients (via React Query) into feature container components. React Query caches and syncs data; components consume queries via typed hooks (e.g., useDashboardMetrics). Mutations use React Query mutation hooks and update cache. Cross-cutting state (auth user, theme, i18n locale) is stored in Contexts with localStorage persistence in dev. Real-time updates come from a WebSocket adapter service; in dev this adapter emits timed mock updates. UI components subscribe to updates via hooks that update React Query caches to keep sources of truth consistent. Routing protects pages by checking AuthContext (protected routes). Error Boundaries and React Query error handling provide fallback UI.",
    "folder_structure": "src/\n  main.tsx\n  App.tsx\n  index.css\n  types/\n    env.d.ts\n  shared/\n    api/\n      client.ts                // typed API client that switches between mock and real\n      endpoints.ts             // endpoint constants\n      mockServer.ts            // mock REST handlers for development (fetch interceptors) + mock WebSocket simulator\n    components/\n      ErrorBoundary.tsx\n      SuspenseFallback.tsx\n      ProtectedRoute.tsx\n      Icon.tsx\n      Button.tsx\n      Input.tsx\n      Toggle.tsx\n    hooks/\n      useAuth.ts               // typed hook using AuthContext\n      useTheme.ts\n      useI18n.ts\n      useWebsocket.ts          // websocket adapter hook\n    contexts/\n      AuthContext.tsx         // provides auth state & actions, uses localStorage in dev\n      ThemeContext.tsx        // dark/light toggle with localStorage\n      I18nContext.tsx         // locale provider\n    services/\n      authService.ts          // signIn/signOut/token storage (mock & real adapter)\n      dashboardService.ts     // typed functions for metrics, chart data\n    libs/\n      validators.ts           // form validators\n      formatters.ts           // data formatting helpers\n    styles/\n      tailwind.css\n  features/\n    navigation/\n      components/\n        ResponsiveNav.tsx     // responsive navigation, mobile drawer\n      hooks/\n        useNav.ts\n    auth/\n      components/\n        LoginForm.tsx\n        UserMenu.tsx\n      pages/\n        LoginPage.tsx\n    dashboard/\n      components/\n        MetricCard.tsx\n        ChartPanel.tsx\n        DashboardLayout.tsx\n      hooks/\n        useDashboardMetrics.ts\n        useDashboardCharts.ts\n      pages/\n        DashboardPage.tsx\n    charts/\n      components/\n        LineChart.tsx         // wrapper over chart library (recharts or chart.js)\n        BarChart.tsx\n  i18n/\n    index.ts\n    en.json\n    es.json\n  routes/\n    routes.tsx\n  utils/\n    localStorage.ts\n    jwt.ts\n  dev/\n    mocks/\n      mockData.ts\n      mockWs.ts\n  tailwind.config.js\n  vite.config.ts\n  tsconfig.json\n  package.json",
    "tech_stack": [
      "React 18+ with TypeScript",
      "Vite for dev tooling",
      "Tailwind CSS for styling and dark mode",
      "React Router v6 for routing and protected routes",
      "React Query (TanStack Query) for data fetching and caching",
      "Recharts or Chart.js (wrapped) for data visualization",
      "socket.io-client (or native WebSocket) with an adapter for mock WS",
      "i18next or react-intl for i18n support",
      "Zod or Yup for form validation",
      "localStorage for persistence in dev; token management via authService",
      "MSW (Mock Service Worker) or a lightweight fetch interceptor for mock REST endpoints in dev",
      "Jest/React Testing Library for testing (not implemented here but planned)"
    ]
  },
  "sections": [
    {
      "id": "auth-context",
      "title": "AuthContext Provider",
      "description": "Provides authentication state, actions (signIn, signOut), token management, role checks and localStorage persistence for development mock users. Exposes useAuth hook (in separate file) to consume context.",
      "file_to_implement": "src/shared/contexts/AuthContext.tsx",
      "acceptance": [
        "Exports AuthProvider React component that wraps children and provides typed context",
        "Provides signIn(email,password) and signOut() methods returning Promise<void>",
        "Persists authenticated user and token to localStorage when development_mode.use_localstorage_persistence is true",
        "Reads mock users when development_mode.enable_mock_data is true and authenticates accordingly",
        "Exposes currentUser, isAuthenticated, and hasRole(role) in context value",
        "Handles token expiry simulation (for mock) and auto sign-out",
        "Includes basic unit-testable pure functions (serialize/deserialize) inside file or exported helpers"
      ],
      "implementation_steps": [
        "1. Define AuthUser and AuthContextValue TypeScript interfaces (id, email, role, token, expiresAt)",
        "2. Create a React context with default value typed as AuthContextValue | undefined",
        "3. Implement helper functions: loadFromStorage(), saveToStorage(), clearStorage() using utils/localStorage.ts and reading process.env.DEV flags (mock enabled)",
        "4. Implement signIn: when mock enabled, validate against dev mock_auth_users (import from dev/mocks/mockData.ts) and on success create token and expiresAt; when mock disabled call authService.signIn(email,password)",
        "5. Implement signOut: clear context state and storage and call authService.signOut if real",
        "6. Implement effect to rehydrate state from storage on mount and to set up token expiry timer (auto sign-out)",
        "7. Provide memoized context value (useMemo) with currentUser, isAuthenticated boolean, signIn, signOut, hasRole helper",
        "8. Export AuthProvider and a small helper getAuthContext() for tests",
        "9. Add ARIA-friendly error message patterns and comments for integration"
      ],
      "integration_points": [
        "Used by src/main.tsx or App.tsx to wrap the app root",
        "Consumed by src/shared/hooks/useAuth.ts to provide typed hook abstractions",
        "LoginForm component (src/features/auth/components/LoginForm.tsx) calls context.signIn",
        "ProtectedRoute (src/shared/components/ProtectedRoute.tsx) reads isAuthenticated and hasRole to guard routes",
        "authService.ts can be used by this provider for real API calls",
        "localStorage utilities in src/utils/localStorage.ts are used for persistence"
      ],
      "prompt_context": {
        "component_type": "context/provider",
        "data_model": "user/auth",
        "interactions": [
          "sign-in",
          "sign-out",
          "rehydrate",
          "role-check"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "dev/mocks/mockData.ts",
          "shared/services/authService.ts",
          "utils/localStorage.ts",
          "shared/hooks/useAuth.ts"
        ]
      },
      "priority": 1
    },
    {
      "id": "use-auth-hook",
      "title": "useAuth Hook",
      "description": "Typed convenience hook that consumes AuthContext; throws descriptive error if used outside provider.",
      "file_to_implement": "src/shared/hooks/useAuth.ts",
      "acceptance": [
        "Exports useAuth() which returns typed AuthContextValue",
        "Throws a helpful error when invoked outside AuthProvider",
        "Provides re-exported helper methods: signIn, signOut, currentUser, isAuthenticated, hasRole",
        "Has small inline JSDoc comments for public API"
      ],
      "implementation_steps": [
        "1. Import React useContext and AuthContext from src/shared/contexts/AuthContext.tsx",
        "2. Define a function useAuth() that calls useContext(AuthContext) and throws if undefined",
        "3. Return the context value and optionally convenient shorthands (e.g., isAdmin = hasRole('admin'))",
        "4. Export useAuth as default and named export"
      ],
      "integration_points": [
        "Consumed by UI components: LoginForm.tsx, UserMenu.tsx, ProtectedRoute.tsx",
        "Testable independently; relies only on AuthContext type"
      ],
      "prompt_context": {
        "component_type": "hook",
        "data_model": "auth",
        "interactions": [
          "read-auth-state",
          "invoke-signin-signout"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "shared/contexts/AuthContext.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "protected-route",
      "title": "ProtectedRoute Component",
      "description": "Route wrapper that restricts access based on authentication and optional required role. Redirects to login page if unauthorized. Accessible and keyboard navigable.",
      "file_to_implement": "src/shared/components/ProtectedRoute.tsx",
      "acceptance": [
        "Receives children or element prop and optional requiredRole string",
        "Checks isAuthenticated and hasRole via useAuth",
        "When not authenticated, navigates to /login and preserves intended path in state",
        "When authenticated but missing role, renders an accessible 403 fallback with ARIA alert",
        "Supports Suspense and ErrorBoundary wrapping",
        "Unit-testable route guard logic"
      ],
      "implementation_steps": [
        "1. Implement a component that accepts { children, requiredRole?: string } props using React.FC and React Router's Navigate & useLocation hooks",
        "2. Use useAuth() to get isAuthenticated and hasRole",
        "3. If not authenticated, return <Navigate to=\"/login\" state={{ from: location }} replace />",
        "4. If authenticated but requiredRole exists and !hasRole(requiredRole), render inline 403 message with aria-live polite and keyboard-focusable container",
        "5. Otherwise render children",
        "6. Add TypeScript prop types and default props",
        "7. Include small comments describing integration and test stubs"
      ],
      "integration_points": [
        "Used in routes config (src/routes/routes.tsx) to guard dashboard routes",
        "Depends on useAuth hook and React Router",
        "When redirecting, LoginPage can read location state to redirect back post-login"
      ],
      "prompt_context": {
        "component_type": "route-guard",
        "data_model": "auth",
        "interactions": [
          "redirect",
          "role-check"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "shared/hooks/useAuth.ts",
          "routes/routes.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "login-form",
      "title": "LoginForm Component",
      "description": "Controlled form for user login with validation, error handling, accessibility, and integration with AuthContext. Uses React Hook Form and Zod for validation and shows loading state.",
      "file_to_implement": "src/features/auth/components/LoginForm.tsx",
      "acceptance": [
        "Renders email and password fields with labels and ARIA attributes",
        "Uses react-hook-form with Zod schema for validation and shows inline validation errors",
        "Calls context.signIn and shows global error banner on failure",
        "Shows a loading spinner on submit and disables inputs while submitting",
        "Persists last-used email to localStorage in dev mode (use utils/localStorage.ts)",
        "Keyboard accessible (Enter to submit, proper tab order)"
      ],
      "implementation_steps": [
        "1. Define Zod schema for email and password and TypeScript form types",
        "2. Setup useForm from react-hook-form with zodResolver and defaultValues (prefill email from storage if available)",
        "3. Implement onSubmit async handler that calls const { signIn } = useAuth(); await signIn(values.email, values.password) and handle errors with setError or formState",
        "4. Render inputs using shared/components/Input.tsx and Button.tsx primitives with tailwind classes and aria-invalid attributes for errors",
        "5. Show inline validation messages and a top-level error area for auth failures",
        "6. Save email to localStorage on successful sign-in attempt if dev persistence enabled",
        "7. Export component and JSDoc"
      ],
      "integration_points": [
        "Used in src/features/auth/pages/LoginPage.tsx",
        "Calls useAuth (src/shared/hooks/useAuth.ts) for signIn",
        "Relies on Input and Button primitives in src/shared/components/",
        "Uses utils/localStorage.ts for persisting email"
      ],
      "prompt_context": {
        "component_type": "form",
        "data_model": "auth",
        "interactions": [
          "submit",
          "validation",
          "error-display"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "shared/hooks/useAuth.ts",
          "shared/components/Input.tsx",
          "shared/components/Button.tsx",
          "utils/localStorage.ts"
        ]
      },
      "priority": 1
    },
    {
      "id": "responsive-nav",
      "title": "Responsive Navigation",
      "description": "Top navigation + collapsible sidebar for desktop and mobile, accessible, supports dark mode and shows current user avatar and UserMenu. Uses Tailwind for responsive layout.",
      "file_to_implement": "src/features/navigation/components/ResponsiveNav.tsx",
      "acceptance": [
        "Renders topbar with app title, search input (non-functional), dark mode toggle, and user avatar",
        "On wide screens shows sidebar with nav links; on small screens shows hamburger that toggles a slide-over menu",
        "Keyboard accessible (focusable menu button, trap focus in mobile drawer while open)",
        "Reflects current route active state via NavLink from react-router",
        "Uses useTheme hook to toggle dark mode and persists selection in ThemeContext/localStorage"
      ],
      "implementation_steps": [
        "1. Create responsive markup: header with left (hamburger/title), center (search placeholder), right (toggle + avatar). Sidebar as <aside> shown on md+ screens and hidden on small screens",
        "2. Implement hamburger button to toggle state; when open render a fixed slide-over panel with focus trap (use a small internal focus management, set initialFocus via ref and restore focus on close)",
        "3. Use NavLink from react-router to render links to Dashboard and Reports; apply tailwind classes for active state",
        "4. Use useTheme() to render and toggle dark mode toggle; ensure aria-pressed used on toggle",
        "5. Display avatar and UserMenu (imported lazily) \u2013 provide fallback initials if no avatar",
        "6. Add aria-labels and keyboard handlers (Escape closes drawer)",
        "7. Export component and small helper types"
      ],
      "integration_points": [
        "Placed inside DashboardLayout (src/features/dashboard/components/DashboardLayout.tsx)",
        "Uses useTheme from src/shared/hooks/useTheme.ts and UserMenu (src/features/auth/components/UserMenu.tsx)",
        "NavLink state integrates with React Router routes in src/routes/routes.tsx"
      ],
      "prompt_context": {
        "component_type": "navigation",
        "data_model": "nav",
        "interactions": [
          "open-drawer",
          "toggle-theme",
          "navigate"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "shared/hooks/useTheme.ts",
          "features/auth/components/UserMenu.tsx",
          "routes/routes.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "metric-card",
      "title": "MetricCard Presentational Component",
      "description": "Small, reusable card that displays a numeric metric with label, delta (percent change), optional sparkline SVG, and accessible semantics. Used in dashboard overview.",
      "file_to_implement": "src/features/dashboard/components/MetricCard.tsx",
      "acceptance": [
        "Accepts props: title, value (number | string), delta (number | null), trend: 'up' | 'down' | 'flat', sparklineData?: number[]",
        "Renders semantic structure (role=status or region) and provides aria-label describing the metric and delta",
        "Colors and icons respond to theme (tailwind dark mode classes)",
        "Optimized to avoid unnecessary re-renders (React.memo with proper prop typing and equality)",
        "Contains minimal inline SVG sparkline rendering when sparklineData provided"
      ],
      "implementation_steps": [
        "1. Define prop interface and add defaultProps where appropriate",
        "2. Implement functional component that renders a header (title), large value, delta with arrow icon, and optional sparkline inline SVG sized responsively",
        "3. Use tailwind classes for spacing/typography and dark variants (e.g., text-gray-900 dark:text-gray-100)",
        "4. Add aria-label summarizing the metric, e.g., `${title}: ${value}, ${delta}% ${trend}` and role='status' container",
        "5. Wrap export with React.memo and provide a custom areEqual comparator focusing on shallow compare of primitive props and sparklineData length/content",
        "6. Add small JSDoc and prop validations via TypeScript"
      ],
      "integration_points": [
        "Used by DashboardPage and DashboardLayout to render metrics fetched by useDashboardMetrics hook",
        "Style tokens consistent with tailwind config; no direct service dependencies",
        "Can be used in storybook or unit tests with mock props"
      ],
      "prompt_context": {
        "component_type": "card",
        "data_model": "metrics",
        "interactions": [
          "display",
          "aria-announcement"
        ],
        "styling_approach": "tailwind",
        "dependencies": []
      },
      "priority": 1
    },
    {
      "id": "dashboard-metrics-hook",
      "title": "useDashboardMetrics Hook",
      "description": "React Query hook that fetches dashboard summary metrics from /api/dashboard/metrics, handles loading/error states, and integrates with mock server in dev. Supports refetch interval for real-time-ish updates and provides manual refresh.",
      "file_to_implement": "src/features/dashboard/hooks/useDashboardMetrics.ts",
      "acceptance": [
        "Exports useDashboardMetrics() that returns { data, isLoading, isError, refetch } typed with Metric types",
        "Uses React Query useQuery with a unique query key ['dashboard','metrics'] and a refetchInterval (configurable) for real-time updates",
        "Parses mock data shape and maps to Metric types",
        "Handles backend unreachable by returning fallback default metrics (fallback mechanism)",
        "In development mode, uses mock endpoints provided by shared/api/mockServer.ts or dev/mocks/mockData.ts"
      ],
      "implementation_steps": [
        "1. Define Metric TypeScript types matching backend mock shape (id, title, value, delta, sparkline[])",
        "2. Create fetcher function that calls client.get('/api/dashboard/metrics') from shared/api/client.ts and transforms response to Metric[]; implement try/catch to return fallback default metrics",
        "3. Use useQuery(['dashboard','metrics'], fetcher, { staleTime: 30_000, refetchInterval: process.env.DEV && disable_websocket ? 10_000 : false, onError: (e) => console.error(e) })",
        "4. Export the hook and a typed refetch function",
        "5. Add JSDoc for usage and note for mock server integration"
      ],
      "integration_points": [
        "Used by DashboardPage to render MetricCard components",
        "Updates to metrics can be made by WebSocket adapter via React Query's queryClient.setQueryData when real-time updates arrive",
        "Relies on shared/api/client.ts and dev mocks"
      ],
      "prompt_context": {
        "component_type": "hook",
        "data_model": "metrics",
        "interactions": [
          "fetch",
          "refetch",
          "fallback"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "shared/api/client.ts",
          "dev/mocks/mockData.ts",
          "shared/hooks/useWebsocket.ts"
        ]
      },
      "priority": 2
    },
    {
      "id": "chart-panel",
      "title": "ChartPanel Component (container + suspense loader)",
      "description": "Container component that displays a chart with title, timeframe selector, and real-time update indicator. Lazily loads chart implementation and uses Suspense fallback while data loads.",
      "file_to_implement": "src/features/dashboard/components/ChartPanel.tsx",
      "acceptance": [
        "Accepts props: chartId, title, defaultRange ('24h'|'7d'|'30d') and optional showRealtime boolean",
        "Uses React.Suspense with a fallback loading skeleton component (import from shared/components/SuspenseFallback.tsx)",
        "Loads chart data using useDashboardCharts hook and renders the appropriate chart component (LineChart / BarChart) lazily with React.lazy",
        "Shows realtime indicator when updates arrive (connected via useWebsocket hook updating React Query cache)",
        "Provides accessible timeframe selector (button group with aria-pressed) and keyboard operable"
      ],
      "implementation_steps": [
        "1. Define props and default values; use useState for selectedRange",
        "2. Lazy import chart components: const LineChart = React.lazy(() => import('src/charts/components/LineChart'))",
        "3. Use useDashboardCharts(chartId, selectedRange) hook (not implemented here but assumed) to get data; wrap the chart render in <Suspense fallback={<SuspenseFallback />}>",
        "4. Render a header with title and a timeframe selector (buttons) with aria attributes; update selectedRange on click/keyboard",
        "5. Show a small badge when realtime updates received (subscribe via useWebsocket or expect that hook to update query data) with aria-live polite",
        "6. Provide error boundary comment for upstream usage (App level ErrorBoundary), but keep internal try/catch for render-time",
        "7. Export component"
      ],
      "integration_points": [
        "Used inside DashboardPage to render multiple ChartPanel instances",
        "Depends on useDashboardCharts hook (src/features/dashboard/hooks/useDashboardCharts.ts) and chart components in src/charts/components/",
        "Listens to updates via useWebsocket hook to reflect realtime indicator"
      ],
      "prompt_context": {
        "component_type": "container",
        "data_model": "charts",
        "interactions": [
          "timeframe-change",
          "real-time-indicator"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "features/dashboard/hooks/useDashboardCharts.ts",
          "shared/components/SuspenseFallback.tsx",
          "charts/components/LineChart.tsx",
          "shared/hooks/useWebsocket.ts"
        ]
      },
      "priority": 2
    },
    {
      "id": "use-dashboard-charts-hook",
      "title": "useDashboardCharts Hook",
      "description": "React Query hook to fetch time-series chart data from /api/dashboard/charts. Supports range parameter and returns formatted series for chart components. Uses fallback behavior when API fails.",
      "file_to_implement": "src/features/dashboard/hooks/useDashboardCharts.ts",
      "acceptance": [
        "Exports useDashboardCharts(chartId, range) returning { data, isLoading, isError, refetch }",
        "Uses query key ['dashboard','charts', chartId, range] and a fetcher calling shared/api/client.ts",
        "Transforms API payload into series arrays expected by chart components",
        "Returns fallback empty series on error and logs error",
        "Supports cancellation via AbortController if new range requested"
      ],
      "implementation_steps": [
        "1. Define ChartPoint and ChartSeries types and the hook signature with chartId:string and range union type",
        "2. Implement fetcher with AbortController that calls client.get(`/api/dashboard/charts?chartId=${chartId}&range=${range}`)",
        "3. Transform response into { series: ChartSeries[] } and handle mapping; catch and return fallback { series: [] }",
        "4. Use useQuery with enabled: Boolean(chartId) and keepPreviousData true to avoid flicker when changing range; add onError console.warn",
        "5. Export hook and document expected return shape"
      ],
      "integration_points": [
        "Used by ChartPanel component to render charts",
        "React Query cache can be updated by websocket adapter to reflect real-time datapoints",
        "Depends on shared/api/client.ts and dev mocks"
      ],
      "prompt_context": {
        "component_type": "hook",
        "data_model": "chart-data",
        "interactions": [
          "fetch-range",
          "cancel-previous"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "shared/api/client.ts",
          "dev/mocks/mockData.ts"
        ]
      },
      "priority": 2
    },
    {
      "id": "line-chart",
      "title": "LineChart Presentational Wrapper",
      "description": "Light wrapper component around a charting library rendering a responsive line chart from series data. Handles minimal accessibility concerns (descriptive title and aria role).",
      "file_to_implement": "src/charts/components/LineChart.tsx",
      "acceptance": [
        "Accepts props: series: { name: string; points: { x: number | string; y: number }[] }[], height?: number",
        "Renders a responsive SVG or uses charting library to produce an accessible chart with title prop",
        "Provides aria-label and role='img' and includes <desc> describing the series",
        "Handles empty data gracefully (renders placeholder message)",
        "Uses tailwind classes for responsive container and respects dark mode"
      ],
      "implementation_steps": [
        "1. Define props types and default height",
        "2. If lightweight, implement an SVG-based line chart renderer supporting multiple series and scales; otherwise wrap a chart library (e.g., Recharts) while keeping props generic",
        "3. Render a container div with role='img' and aria-label/title; include <svg> with viewBox sizing and responsive behavior",
        "4. Iterate over series and draw polyline paths scaled to bounds; include simple axes lines or gridlines if feasible",
        "5. Render fallback placeholder when series.length === 0 with aria-live polite",
        "6. Export component memoized for performance"
      ],
      "integration_points": [
        "Used by ChartPanel to render chart content",
        "Receives data from useDashboardCharts hook via ChartPanel",
        "No direct network dependencies"
      ],
      "prompt_context": {
        "component_type": "chart",
        "data_model": "timeseries",
        "interactions": [
          "render",
          "accessibility"
        ],
        "styling_approach": "tailwind",
        "dependencies": []
      },
      "priority": 2
    }
  ]
}