{
  "architecture": {
    "overview": "This plan defines a cohesive React 18+ dashboard application built with TypeScript, Tailwind, and a modular, scalable architecture. It emphasizes clear separation of concerns, robust state and data management, accessibility, performance, and progressive enhancement. The system is designed for parallel development of independent sections that integrate through well-defined contracts (providers, hooks, and shared services).",
    "patterns": [
      "Container/Presentational",
      "Feature-Sliced Architecture",
      "Compound Components",
      "Hooks-First / Custom Hooks",
      "Reducer + Context for domain state",
      "Server State management with React Query (TanStack Query)",
      "Code-Splitting with React.lazy and Suspense",
      "Error Boundaries with fallback UIs and recovery paths"
    ],
    "data_flow": "User interactions flow from UI components to local state (via useReducer/Context) or server state (via React Query). Server-sourced data streams in through API calls and WebSocket connections, updating caches and triggering re-renders. UI components leverage memoization to minimize renders. Data virtualization handles large collections. A dedicated service worker enables offline support. UI state (theme, navigation, auth status) is provided by a Context-based store; server state is cached and synchronized via React Query with optimistic updates where applicable. SEO/meta management uses dynamic head updates for SPA scenarios. Code splitting ensures large dashboards and charts load on demand.",
    "folder_structure": "src/\n  app/                // routing, layouts, app-wide providers\n  shared/             // design system primitives, utilities, and common components\n  features/           // domain modules (auth, dashboard, analytics, etc.)\n  design-system/      // tokens, themes, Tailwind config extensions\n  hooks/              // custom hooks used across features\n  context/            // global React Contexts (auth, UI, etc.)\n  services/           // API client, WebSocket client, notifications, etc.\n  i18n/               // internationalization setup\n  lib/                // utilities and helpers\n  locales/            // translation resources\n  pages/              // route pages (if using non-sparse routing)\n  styles/             // global styles and Tailwind entry\ntech_stack:[\"React 18+\",\"TypeScript\",\"Tailwind CSS\",\"TanStack Query (React Query)\",\"React Router v6\",\"WebSocket for real-time updates\",\"i18next for i18n\",\"Vitest + React Testing Library\",\"Service Workers (PWA offline)\",\"ESLint/Prettier\",\"Vite (build tooling)\",\"React.lazy + Suspense for code splitting\"]},",
    "tech_stack": [
      "React 18+",
      "TypeScript",
      "Tailwind CSS",
      "TanStack Query (React Query)",
      "React Router v6",
      "WebSocket",
      "i18next",
      "Vitest + React Testing Library",
      "Service Workers (PWA offline)",
      "ESLint/Prettier",
      "Vite (build tooling)"
    ]
  },
  "sections": [
    {
      "id": "component-requirements",
      "title": "Component Requirements",
      "description": "Define, implement, and document a reusable component library and patterns that will power all dashboard UI with accessibility, theming, and performance in mind.",
      "acceptance": [
        "Base component library with 12+ reusable components (Button, Input, Select, Card, Modal, Navbar, Drawer, ChartPanel, Avatar, Icon, Tooltip, Tabs)",
        "Components have strong TypeScript typings, including discriminated unions and generics where appropriate",
        "All components are accessible (ARIA roles, keyboard navigation, focus management) and support dark mode theming",
        "Components are designed for composition (compound components, render props patterns) and can be lazy-loaded",
        "Unit tests cover core behavior and accessibility for critical components",
        "Demonstrated usage in at least three features via example pages or stories"
      ],
      "implementation_steps": [
        "1. Define core component API surface with types for Button, Input, Select, Card, Modal, Navbar, Drawer, ChartPanel",
        "2. Build compound components: Card (Card.Header, Card.Body), Modal with focus-trap, Navbar with responsive items",
        "3. Implement render-props and simple HOC-like patterns where beneficial (e.g., withLoading, withError)",
        "4. Implement Tailwind-based styling with accessibility-friendly defaults and dark mode variants",
        "5. Add strict TypeScript props using discriminated unions (e.g., Button variant/type, Input variants)",
        "6. Create an index barrel exporting all components and a simple design-system token hookup",
        "7. Integrate with design-system tokens for colors, spacing, typography",
        "8. Add RTL/LTR support hooks and direction-aware utilities",
        "9. Write RTL and a11y tests for core components",
        "10. Document usage patterns and provide usage examples in a components guide"
      ],
      "integration_points": [
        "Design System Integration (tokens, dark mode)",
        "Technical Specifications (typing, props patterns)",
        "State Management (consume UI components via context)",
        "Performance Considerations (code-splitting for heavy controls)"
      ],
      "prompt_context": {
        "component_type": "component-library",
        "data_model": "ui-components",
        "interactions": [
          "compose",
          "reuse",
          "customize",
          "test",
          "render"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "design-system-integration",
          "technical-specifications"
        ]
      },
      "priority": 1
    },
    {
      "id": "technical-specifications",
      "title": "Technical Specifications",
      "description": "Document and implement the technical foundation, tooling, and patterns that every section relies on.",
      "acceptance": [
        "Strict TypeScript configuration (noImplicitAny, strictNullChecks)",
        "Consistent folder structure and naming conventions",
        "CI pipeline with lint/test/build steps",
        "Routing with protected routes and token refresh patterns",
        "API client with base URL and auth interceptor",
        "React Query as the primary data-fetch layer with caching and optimistic updates",
        "Error boundaries and Suspense boundaries in place",
        "Code-splitting via React.lazy and dynamic imports"
      ],
      "implementation_steps": [
        "1. Create tsconfig strict settings and path aliases",
        "2. Configure Vite build with React 18, TS, and Tailwind integration",
        "3. Set up React Router v6 with protected routes and lazy-loaded routes",
        "4. Implement API client (fetch-based) with auth token handling and refresh flow",
        "5. Integrate TanStack Query Client for server state management and caching",
        "6. Implement global error boundaries and fallback UI wrappers",
        "7. Set up React Suspense boundaries around heavy UI blocks (charts, dashboards)",
        "8. Enable code-splitting for route modules and features",
        "9. Configure environment variables strategy and per-environment configs",
        "10. Add CI tasks for lint, type-check, tests, and build artifacts"
      ],
      "integration_points": [
        "Component library usage",
        "State Management (QueryClient, auth flows)",
        "Error Handling",
        "Performance Considerations"
      ],
      "prompt_context": {
        "component_type": "section",
        "data_model": "technical-specs",
        "interactions": [
          "setup",
          "configure",
          "validate"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "component-requirements",
          "design-system-integration"
        ]
      },
      "priority": 1
    },
    {
      "id": "design-system-integration",
      "title": "Design System Integration",
      "description": "Align color, typography, spacing, and component tokens across the app via a cohesive design system and Tailwind configuration.",
      "acceptance": [
        "Tailwind configured with a design-token system",
        "Dark mode support and smooth transitions",
        "Fluid typography and container queries support",
        "Accessible color tokens and contrast checks",
        "Components consume tokens consistently across themes"
      ],
      "implementation_steps": [
        "1. Define design tokens (colors, spacing scale, typography scale, radii) in a centralized file",
        "2. Extend Tailwind config to expose custom tokens and utility variants",
        "3. Create CSS variables for theme switching and ensure runtime toggling for dark mode",
        "4. Implement fluid/responsive typography using viewport-based scales",
        "5. Build a small Design System package (tokens, typography, shadows) and export for reuse",
        "6. Create theme toggle mechanism wired to global context",
        "7. Validate contrast ratios and accessibility requirements across components",
        "8. Document tokens and usage guidelines"
      ],
      "integration_points": [
        "Component Requirements",
        "Technical Specifications",
        "State Management (theme state)",
        "Accessibility"
      ],
      "prompt_context": {
        "component_type": "design-system",
        "data_model": "design-tokens",
        "interactions": [
          "theme-switch",
          "token-consumption",
          "token-update"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "technical-specifications",
          "component-requirements"
        ]
      },
      "priority": 2
    },
    {
      "id": "state-management",
      "title": "State Management",
      "description": "Define and implement a robust, scalable state management strategy combining local state, context, reducers, and server state caching.",
      "acceptance": [
        "Context + useReducer for global app state (auth, UI, user preferences)",
        "Seamless server state via TanStack Query with caching, invalidation, and optimistic updates",
        "Clear separation of concerns between UI state, domain state, and server state",
        "Deterministic state changes with immutability and type-safe actions",
        "Devtools-friendly structure and predictable re-renders"
      ],
      "implementation_steps": [
        "1. Define state schemas: AuthState, UIState, DataState with discriminated unions",
        "2. Create AppContext with providers, reducers, and typed dispatchers",
        "3. Expose custom hooks (useAppState, useAppDispatch)",
        "4. Configure TanStack Query Client and default options (staleTime, cacheTime, refetchOnWindowFocus)",
        "5. Implement token refresh flow and session persistence in Auth logic",
        "6. Integrate with protected routes and real-time update handlers",
        "7. Implement memoized selectors and avoid prop drilling",
        "8. Add tests for reducers and selectors",
        "9. Document state contracts and action types"
      ],
      "integration_points": [
        "Technical Specifications",
        "Design System (theme/state)",
        "Component Library (consumes UI state)",
        "Testing Guidelines"
      ],
      "prompt_context": {
        "component_type": "state-management",
        "data_model": "application-state",
        "interactions": [
          "update",
          "select",
          "observe"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "technical-specifications",
          "design-system-integration"
        ]
      },
      "priority": 1
    },
    {
      "id": "error-handling",
      "title": "Error Handling",
      "description": "Provide consistent, user-friendly error handling, boundaries, and reporting for both client and server errors.",
      "acceptance": [
        "Global error boundaries with graceful fallbacks",
        "Uniform error shape for API and runtime errors",
        "Telemetry/logging integration (e.g., Sentry)",
        "Retry and recovery strategies for transient failures",
        "Accessible error messaging with ARIA alerts when appropriate"
      ],
      "implementation_steps": [
        "1. Implement an ErrorBoundary component wrapping top-level routes",
        "2. Create a centralized error store or error boundary context for runtime errors",
        "3. Wrap lazy-loaded modules with boundary fallbacks and recovery options",
        "4. Standardize error payloads from API clients and adapters",
        "5. Integrate with logging/monitoring (Sentry/console fallback)",
        "6. Implement retry policies for recoverable API calls with exponential backoff",
        "7. Provide accessible inline error messages and screen reader announcements",
        "8. Add tests for boundary fallback and error scenarios"
      ],
      "integration_points": [
        "Technical Specifications",
        "State Management",
        "Testing Guidelines",
        "Performance Considerations"
      ],
      "prompt_context": {
        "component_type": "section",
        "data_model": "error-handling",
        "interactions": [
          "catch",
          "report",
          "recover"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "technical-specifications",
          "state-management"
        ]
      },
      "priority": 2
    },
    {
      "id": "performance-considerations",
      "title": "Performance Considerations",
      "description": "Address performance through code-splitting, virtualization, memoization, and efficient rendering to meet Core Web Vitals goals.",
      "acceptance": [
        "Route-based code splitting and lazy loading for heavy modules",
        "Suspense boundaries around heavy components (charts, dashboards)",
        "Memoization of expensive computations and components (React.memo, useMemo, useCallback)",
        "Data virtualization for large lists and infinite scrolling",
        "Optimistic UI updates and controlled loading states for responsiveness"
      ],
      "implementation_steps": [
        "1. Identify heavy routes/components and enable lazy loading",
        "2. Wrap large dashboards with Suspense fallbacks and loading skeletons",
        "3. Memoize expensive computations and component trees",
        "4. Implement virtualization for large lists (e.g., react-window / react-virtualized)",
        "5. Introduce optimistic UI patterns with React Query for mutations",
        "6. Add performance budgets and run Lighthouse audits in CI",
        "7. Enable image optimization patterns (srcset, modern formats)",
        "8. Instrument performance metrics (timing API, Web Vitals)"
      ],
      "integration_points": [
        "Component Requirements",
        "State Management",
        "Accessibility Requirements",
        "Testing Guidelines",
        "SEO/Performance Reporting"
      ],
      "prompt_context": {
        "component_type": "section",
        "data_model": "performance-metrics",
        "interactions": [
          "optimize",
          "measure",
          "iterate"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "technical-specifications",
          "state-management"
        ]
      },
      "priority": 2
    },
    {
      "id": "accessibility-requirements",
      "title": "Accessibility Requirements",
      "description": "Ensure WCAG 2.1 AA compliance with proper ARIA, keyboard navigation, focus management, and screen reader support.",
      "acceptance": [
        "Keyboard navigable all interactive controls",
        "ARIA labels on controls with descriptive text",
        "Focusable modal/dialogs with focus restoration",
        "Contrast ratios meet WCAG standards",
        "Screen reader announcements for dynamic content",
        "RTL support and proper text direction handling"
      ],
      "implementation_steps": [
        "1. Audit all interactive components for keyboard access and focus order",
        "2. Add ARIA labels and roles to widgets (buttons, inputs, charts)",
        "3. Implement focus trap and restoration for modals/drawers",
        "4. Integrate color tokens with accessible contrast checks",
        "5. Ensure dynamic regions have aria-live or aria-atomic as needed",
        "6. Add RTL layout tests and direction-aware utilities",
        "7. Run a11y checks with automated tools and unit tests",
        "8. Document accessibility guidelines and checklists"
      ],
      "integration_points": [
        "Design System Integration",
        "Component Requirements",
        "Performance Considerations",
        "Testing Guidelines"
      ],
      "prompt_context": {
        "component_type": "section",
        "data_model": "a11y-spec",
        "interactions": [
          "navigate",
          "announce",
          "focus"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "design-system-integration",
          "component-requirements"
        ]
      },
      "priority": 2
    },
    {
      "id": "testing-guidelines",
      "title": "Testing Guidelines",
      "description": "Define testing strategy and concrete test plans for unit and integration tests across components and features.",
      "acceptance": [
        "Unit tests for core components and hooks",
        "Integration tests for key flows (auth, data fetch, realtime updates)",
        "Accessibility tests (a11y)",
        "Mocking/stubbing of API and WebSocket in tests",
        "Test suite integrated with CI and coverage thresholds"
      ],
      "implementation_steps": [
        "1. Set up testing framework (Vitest) with React Testing Library",
        "2. Create test utilities for mocks and providers (Theme, Router, QueryClient, Auth)",
        "3. Write unit tests for core components (Button, Input, Card, Modal)",
        "4. Write integration tests for Auth flow and data fetch with React Query mocks",
        "5. Add tests for real-time updates and WS cleanup",
        "6. Add a11y tests using jest-axe or similar",
        "7. Integrate coverage reporting and enforce minimum thresholds",
        "8. Create CI job to run tests on push/PR",
        "9. Provide test data factories and utilities"
      ],
      "integration_points": [
        "Technical Specifications",
        "State Management",
        "Error Handling",
        "Performance Considerations",
        "Design System Integration"
      ],
      "prompt_context": {
        "component_type": "section",
        "data_model": "testing-plan",
        "interactions": [
          "test",
          "validate",
          "report"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "technical-specifications",
          "component-requirements",
          "state-management"
        ]
      },
      "priority": 3
    }
  ]
}