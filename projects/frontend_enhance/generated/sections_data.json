{
  "architecture": {
    "overview": "A modular, production-grade React 18+ dashboard architecture built around a feature-first, container/presentational pattern. The app uses a thin set of core providers to manage cross-cutting concerns (auth, theming, data fetching) and lazy-loads feature modules for optimal performance. Data flows in a unidirectional manner: API/WebSocket data -> React Query cache or local state -> UI components. Real-time updates propagate via a WebSocket hook that feeds React Query caches or local state with optimistic UI where appropriate. Accessibility, performance, and maintainability are baked in through patterns like Suspense, Error Boundaries, code-splitting, and strict TypeScript typings. The design favors small, independent sections that integrate through well-defined contracts (contexts, hooks, and provider components).",
    "patterns": [
      "Container/Presentational",
      "Feature-based (domain modules under src/features)",
      "Compound components for form controls",
      "Render props and hooks for extensibility",
      "Reducer-based state management via React.useReducer + Context",
      "Code-splitting with React.lazy and dynamic imports",
      "Data fetching with React Query (TanStack Query) including caching and optimistic updates",
      "Suspense for data loading, Error Boundaries for resilience"
    ],
    "data_flow": "User interactions -> UI events -> actions trigger reducers or API mutations via React Query/mutations -> server responses -> cache updates (React Query) or local state -> components re-render. Real-time data uses a WebSocket hook to feed the cache/local state and trigger UI updates with proper cleanup. Global state is accessed via Context (Auth, Theme) while per-page data is managed by React Query. Code-splitting and lazy loading minimize initial bundle size. Asset loading, images, and fonts are handled with responsive, lazy-loading strategies and Tailwind for styling.",
    "folder_structure": "src/\n  app/\n    App.tsx\n    providers/\n      QueryClientProvider.tsx\n    contexts/\n      AuthContext.tsx\n      ThemeContext.tsx\n  features/\n    auth/\n      components/\n        LoginForm.tsx\n    navigation/\n      components/\n        ResponsiveNav.tsx\n    theme/\n      components/\n        ThemeToggle.tsx\n    dashboard/\n      components/\n        ChartPanel.tsx\n        VirtualizedList.tsx\n  shared/\n    components/\n      ErrorBoundary.tsx\n    hooks/\n      useWebSocket.ts\n  utils/\n    hooks/\n      useWebSocket.ts\n  mocks/\n    (optional mocks for dev/testing)\n  assets/\n    (images, icons, logos)\n  index.html\n  main.tsx",
    "tech_stack": [
      "React 18+",
      "TypeScript",
      "Tailwind CSS",
      "TanStack/React Query (data fetching and caching)",
      "React Router (routing)",
      "WebSocket API for real-time features",
      "Accessibility tooling (ARIA, keyboard nav)",
      "Code-splitting with React.lazy",
      "Error Boundaries",
      "Testing Library (RTL) for tests",
      "i18n (optional placeholder)",
      "Service Workers for PWA/offline (optional]"
    ]
  },
  "sections": [
    {
      "id": "app-entrypoint",
      "title": "App bootstrap and routing",
      "description": "Root app component that wires providers, suspense, routes, protected routes, and error boundary.",
      "file_to_implement": "src/app/App.tsx",
      "acceptance": [
        "Renders the application root and bootstraps providers (Auth, Theme, React Query).",
        "Configures React Router with public (Login) and protected (Dashboard) routes.",
        "Uses React.Suspense for lazy-loaded routes and wraps the app in an ErrorBoundary.",
        "Ensures accessibility attributes are present on core navigational elements."
      ],
      "implementation_steps": [
        "1. Create App.tsx as the application bootstrap.",
        "2. Import and render AppProviders (AuthContext, ThemeContext, QueryClientProvider).",
        "3. Set up React Router with routes: /login (LoginForm) and /dashboard (lazy-loaded Dashboard module) and a catch-all redirect.",
        "4. Wrap routes in Suspense with a global fallback UI.",
        "5. Wrap everything in an ErrorBoundary with reset capability.",
        "6. Ensure Tailwind CSS classes are applied and support for dark mode is wired via ThemeContext.",
        "7. Expose a public root element for rendering (e.g., ReactDOM.createRoot(document.getElementById('root')).render)."
      ],
      "integration_points": [
        "Imports AppProviders from src/app/providers/QueryClientProvider.tsx; uses AuthContext and ThemeContext from their respective files; lazy-loads dashboard module via React.lazy; protects routes via a PrivateRoute-like mechanism (could be internal to App.tsx)"
      ],
      "prompt_context": {
        "component_type": "file",
        "data_model": "application",
        "interactions": [
          "initialize",
          "navigate",
          "protect_route"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "src/app/providers/QueryClientProvider.tsx",
          "src/app/contexts/AuthContext.tsx",
          "src/app/contexts/ThemeContext.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "query-client-provider",
      "title": "React Query Client Provider",
      "description": "Configures a TanStack React Query client with sane default options and optional devtools for development.",
      "file_to_implement": "src/app/providers/QueryClientProvider.tsx",
      "acceptance": [
        "Exports a React component that provides a configured QueryClient to the app.",
        "Sets defaultQueryOptions for caching, stale times, and retry behavior.",
        "Optionally exposes ReactQueryDevtools in development.",
        "Is a wrapper that App.tsx can compose around the app tree."
      ],
      "implementation_steps": [
        "1. Import React, QueryClient, QueryClientProvider, and ReactQueryDevtools (optional).",
        "2. Instantiate a QueryClient with options: defaultOptions for queries (staleTime, cacheTime, refetchOnWindowFocus), mutations, and retries.",
        "3. Create a functional component QueryClientProviderWrapper({children}).",
        "4. Return <QueryClientProvider client={client}>{children} {devtools}</QueryClientProvider>",
        "5. Export the wrapper as default and also export the client if needed for tests."
      ],
      "integration_points": [
        "Used by App.tsx to wrap the app tree with data-fetching capabilities."
      ],
      "prompt_context": {
        "component_type": "file",
        "data_model": "application services",
        "interactions": [
          "fetch",
          "cache",
          "invalidate"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "src/app/contexts/AuthContext.tsx",
          "src/app/contexts/ThemeContext.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "auth-context",
      "title": "Authentication context",
      "description": "Centralized authentication state, sign-in/out, and token handling.",
      "file_to_implement": "src/app/contexts/AuthContext.tsx",
      "acceptance": [
        "Provides a hook to access authentication state (useAuth).",
        "Stores and validates tokens in memory and localStorage securely.",
        "Offers signIn and signOut methods; reports isAuthenticated and user info.",
        "Integrates with protected routes logic in App.tsx."
      ],
      "implementation_steps": [
        "1. Define User type and AuthState interface.",
        "2. Create AuthContext with default values.",
        "3. Implement AuthProvider component with useState for user and tokens; load from localStorage on init.",
        "4. Implement signIn(credentials) to simulate/mutate and store tokens; implement signOut to clear tokens.",
        "5. Expose useAuth hook for components to access state and actions.",
        "6. Ensure token refresh mechanism placeholder (optional) and access control for protected routes.",
        "7. Add minimal test hooks or console warnings for development."
      ],
      "integration_points": [
        "Used by LoginForm.tsx for authenticating users; used by App.tsx to guard routes; may connect with backend via API module in future."
      ],
      "prompt_context": {
        "component_type": "file",
        "data_model": "auth/user_session",
        "interactions": [
          "login",
          "logout",
          "token_refresh"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "src/app/app.tsx",
          "src/features/auth/components/LoginForm.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "theme-context",
      "title": "Theme (dark/light) context",
      "description": "Global theme state with a toggle and persistent preference.",
      "file_to_implement": "src/app/contexts/ThemeContext.tsx",
      "acceptance": [
        "Provides a ThemeContext with current theme and toggleTheme function.",
        "Persists user preference in localStorage.",
        "Applies theme class (e.g., 'dark') on document root for Tailwind dark mode support.",
        "Exports useTheme hook for components to read and toggle theme."
      ],
      "implementation_steps": [
        "1. Define Theme type ('light'|'dark').",
        "2. Create ThemeContext with default theme.",
        "3. Implement ThemeProvider that reads initial theme from localStorage or system preference.",
        "4. Implement toggleTheme to switch themes and persist choice.",
        "5. Update document.documentElement.classList to reflect the current theme.",
        "6. Export useTheme hook for consumption."
      ],
      "integration_points": [
        "Used by ThemeToggle.tsx and App.tsx to ensure theme consistency across the app."
      ],
      "prompt_context": {
        "component_type": "file",
        "data_model": "ui/theme",
        "interactions": [
          "toggle",
          "persist"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "src/features/theme/components/ThemeToggle.tsx",
          "src/app/App.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "login-form",
      "title": "Login form UI",
      "description": "Accessible authentication form with validation and integration with AuthContext.",
      "file_to_implement": "src/features/auth/components/LoginForm.tsx",
      "acceptance": [
        "Renders username/email and password fields with real-time validation.",
        "Shows inline errors and loading state during sign-in.",
        "Calls AuthContext.signIn on submit and handles success/failure gracefully.",
        "Includes ARIA attributes, keyboard navigation, and responsive layout."
      ],
      "implementation_steps": [
        "1. Create functional component LoginForm with internal state for email, password, and errors.",
        "2. Use useAuth() to access signIn.",
        "3. Implement validation rules (required fields, email format, password length).",
        "4. Render accessible form controls with proper labels and aria-invalid/aria-live for errors.",
        "5. Show loading spinner and disable submit while authenticating.",
        "6. On success, navigate to /dashboard; on failure, display error state and reset as appropriate.",
        "7. Apply Tailwind classes for responsive layout."
      ],
      "integration_points": [
        "Used on /login route from App.tsx; authenticates via useAuth hook from AuthContext; after login, route protection logic redirects to dashboard."
      ],
      "prompt_context": {
        "component_type": "file",
        "data_model": "auth/login",
        "interactions": [
          "submit",
          "validation",
          "redirect"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "src/app/contexts/AuthContext.tsx",
          "src/app/App.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "responsive-nav",
      "title": "Responsive navigation bar",
      "description": "Accessible, responsive navigation with mobile drawer and keyboard support.",
      "file_to_implement": "src/features/navigation/components/ResponsiveNav.tsx",
      "acceptance": [
        "Renders brand/logo and navigation links.",
        "Collapses into a mobile-friendly drawer with proper aria attributes.",
        "Keyboard accessible and supports focus management.",
        "Integrates with Router Links and ThemeToggle if needed."
      ],
      "implementation_steps": [
        "1. Build a functional component with state for open/closed mobile menu.",
        "2. Use Tailwind for responsive layout; implement aria-expanded and role attributes.",
        "3. Render Link components for navigation; ensure focus trap and keyboard handlers (Escape to close).",
        "4. Ensure color contrast and ARIA labels for all controls.",
        "5. Integrate with ThemeToggle if part of the header."
      ],
      "integration_points": [
        "Used by App.tsx as the main navigation component; consumes route information to render active states."
      ],
      "prompt_context": {
        "component_type": "file",
        "data_model": "ui/navigation",
        "interactions": [
          "navigate",
          "toggle_menu"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "src/app/App.tsx",
          "src/features/theme/components/ThemeToggle.tsx"
        ]
      },
      "priority": 2
    },
    {
      "id": "theme-toggle",
      "title": "Theme toggle button",
      "description": "UI control to switch between light and dark themes.",
      "file_to_implement": "src/features/theme/components/ThemeToggle.tsx",
      "acceptance": [
        "Renders a accessible toggle button with proper aria-labels.",
        "Updates ThemeContext on toggle and persists preference.",
        "Does not cause layout shifts; uses prefers-color-scheme as fallback."
      ],
      "implementation_steps": [
        "1. Create a button element with aria-label 'Toggle theme'.",
        "2. Consume useTheme to read current mode and toggleTheme function.",
        "3. On click, call toggleTheme and ensure class on documentElement is updated.",
        "4. Apply appropriate Tailwind classes for iconography and hover states."
      ],
      "integration_points": [
        "Used by ResponsiveNav.tsx and standalone header areas; relies on ThemeContext to reflect changes across UI."
      ],
      "prompt_context": {
        "component_type": "file",
        "data_model": "ui/theme",
        "interactions": [
          "toggle",
          "persist"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "src/app/contexts/ThemeContext.tsx",
          "src/features/navigation/components/ResponsiveNav.tsx"
        ]
      },
      "priority": 2
    },
    {
      "id": "chart-panel",
      "title": "Chart panel for data visualization",
      "description": "Generic ChartPanel component that renders a simple SVG line chart with configurable data.",
      "file_to_implement": "src/features/dashboard/components/ChartPanel.tsx",
      "acceptance": [
        "Renders a responsive SVG line chart based on provided data.",
        "Accepts props for data, labels, color, width, height and optional loading state.",
        "Exported as React.memo to avoid unnecessary re-renders.",
        "Accessible with descriptive title and aria-labels on interactive elements."
      ],
      "implementation_steps": [
        "1. Define ChartPanelProps with data:number[], labels:string[], color:string, width?:number, height?:number, loading?:boolean.",
        "2. Compute scales (min/max) and map data to SVG coordinates.",
        "3. Build SVG path string for the line chart and render axes/labels simplistically.",
        "4. Add a simple hover tooltip (optional) using local state.",
        "5. Wrap with React.memo and expose default props.",
        "6. Ensure responsiveness (viewBox-based scaling) and Tailwind container classes."
      ],
      "integration_points": [
        "Used by dashboard sections to visualize data; can be fed by data fetched via React Query or WebSocket hook for real-time updates."
      ],
      "prompt_context": {
        "component_type": "file",
        "data_model": "dashboard/chart",
        "interactions": [
          "update_data",
          "tooltip",
          "resize"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "src/features/dashboard/components/ChartPanel.tsx",
          "src/utils/hooks/useWebSocket.ts"
        ]
      },
      "priority": 2
    },
    {
      "id": "use-websocket",
      "title": "WebSocket hook for real-time updates",
      "description": "Generic hook to manage a WebSocket connection with cleanups and typed messages.",
      "file_to_implement": "src/utils/hooks/useWebSocket.ts",
      "acceptance": [
        "Establishes a WebSocket connection and handles onOpen, onMessage, onError, onClose.",
        "Provides a send function to emit messages.",
        "Cleans up on unmount and handles reconnection strategy if needed.",
        "Types messages to ensure type safety and easy consumption by UI components."
      ],
      "implementation_steps": [
        "1. Define a generic type TMessage and a callback signature for onMessage.",
        "2. Implement useEffect to open and close WebSocket based on URL or options.",
        "3. Return an object with send(data), lastMessage, readyState, and a close function.",
        "4. Add optional auto-reconnect logic with exponential backoff (basic example).",
        "5. Ensure cleanup on unmount; handle component unmount mid-connection gracefully."
      ],
      "integration_points": [
        "Can be used by ChartPanel or Realtime components to push data into UI via lastMessage or via a separate state update flow."
      ],
      "prompt_context": {
        "component_type": "file",
        "data_model": "real-time websocket",
        "interactions": [
          "connect",
          "disconnect",
          "send",
          "receive"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "src/features/dashboard/components/ChartPanel.tsx"
        ]
      },
      "priority": 2
    },
    {
      "id": "error-boundary",
      "title": "Error Boundary component",
      "description": "Reusable error boundary to catch rendering errors in React tree with fallback UI and recovery.",
      "file_to_implement": "src/shared/components/ErrorBoundary.tsx",
      "acceptance": [
        "Catches errors in child components and renders a fallback UI with a reset option.",
        "Does not crash the entire app; provides a mechanism to retry/recover.",
        "Supports custom fallback UI if provided through props."
      ],
      "implementation_steps": [
        "1. Implement a class component extending React.Component with state { hasError:boolean }.",
        "2. Implement componentDidCatch to log error and set state.",
        "3. Render either children or a fallback UI with a reset button.",
        "4. Expose a resetErrorBoundary method to reset state and trigger a re-render.",
        "5. Add ability to customize the fallback UI via props."
      ],
      "integration_points": [
        "Used at App.tsx to wrap the app and catch errors from any child route or component."
      ],
      "prompt_context": {
        "component_type": "file",
        "data_model": "ui/error-handling",
        "interactions": [
          "catch",
          "recover"
        ],
        "styling_approach": "tailwind",
        "dependencies": [
          "src/app/App.tsx"
        ]
      },
      "priority": 1
    }
  ]
}