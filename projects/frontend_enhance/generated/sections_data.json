{
  "architecture": {
    "overview": "A modular, feature-sliced React 18+ dashboard application with a strong emphasis on type safety, accessibility, and performance. The system uses Tailwind for styling, TanStack/React Query for data fetching and caching, and a set of well-defined hooks and components to ensure separation of concerns. Real-time capabilities are provided via a reusable WebSocket hook, with data virtualization for large lists, code-splitting for optimal bundles, and robust error handling via error boundaries. The architecture supports offline capabilities, i18n, and progressive enhancement, while remaining testable with RTL and integration tests.",
    "patterns": [
      "Feature-Sliced Architecture (shared, features, app layers)",
      "Container/Presentational separation",
      "Compound components and render props where appropriate",
      "Custom hooks pattern for side effects and data fetching",
      "Reducer-based and Context-based state management with local/state lifting",
      "Code splitting with React.lazy and dynamic imports",
      "Unidirectional data flow with React Query for server state",
      "Accessibility-first approaches (ARIA, keyboard navigation, focus management)"
    ],
    "data_flow": "UI actions originate in components and can trigger local state updates or dispatch to a global UI reducer. Server state is fetched via React Query (with optimistic updates and caching). Real-time updates flow through a centralized WebSocket hook that pushes changes into React Query caches or local components. Data visualization components consume chart data from queries and render via chart primitives. Global configuration and feature flags are provided via a Config context. Routing is guarded by ProtectedRoute wrappers and redirects to SignIn when unauthenticated. All components are designed for lazy loading to optimize LCP. Error boundaries wrap high-risk boundaries, and Suspense provides fallbacks for async parts. Logging/telemetry hooks emit events for analytics and monitoring.",
    "folder_structure": "src/\n  app/\n    main.tsx\n    config/\n      config.ts\n    routes/\n      ProtectedRoute.tsx\n      Router.tsx\n  shared/\n    components/\n      ChartCard.tsx\n      Card.tsx\n      Button.tsx\n      Modal.tsx\n    hooks/\n      useWebSocket.ts\n      useDebouncedEffect.ts\n    i18n/\n      i18n.ts\n    utils/\n      api.ts\n      logger.ts\n  features/\n    auth/\n      components/\n        SignIn.tsx\n    dashboard/\n      pages/\n        Dashboard.tsx\n      components/\n        DashboardLayout.tsx\n        DataTable.tsx\n        LiveUpdates.tsx\n        Sparkline.tsx\n  styles/\n    tailwind.css\n  locales/\n    en.json\n  types/\n    index.d.ts",
    "tech_stack": [
      "React 18+ with TypeScript",
      "Tailwind CSS with dark mode and container queries",
      "TanStack Query (React Query) for data fetching and caching",
      "React Router for client-side routing",
      "WebSocket hook for real-time features",
      "react-window or similar for data virtualization",
      "React.lazy / Suspense for code splitting",
      "Context + useReducer for global UI state",
      "i18n with react-i18next",
      "Charting library (e.g., Recharts/Visx) wrapped by ChartCard",
      "RTL/LTR support and WCAG 2.1 AA compliance",
      "Service Worker for offline support",
      "RTL-friendly components and semantic HTML with ARIA labels"
    ]
  },
  "sections": [
    {
      "id": "app-main-entry",
      "title": "Application Entry Point (src/app/main.tsx)",
      "description": "Bootstraps the React application, initializes providers, routing, and global error handling.",
      "file_to_implement": "src/app/main.tsx",
      "acceptance": [
        "Renders to document.getElementById('root')",
        "Wraps app with QueryClientProvider, ThemeProvider (dark mode aware), and I18n provider",
        "Configures Router with protected routes and SignIn route",
        "Uses React.Suspense with a global fallback and a global ErrorBoundary",
        "Initializes app-wide configuration (env-based) and supports dark mode toggle state"
      ],
      "implementation_steps": [
        "1. Create ReactRoot via createRoot and render AppRoot",
        "2. Instantiate TanStack Query Client with default options (staleTime, cacheTime, refetchOnWindowFocus false by default)",
        "3. Initialize i18n instance and wrap AppRoot with I18nProvider",
        "4. Wrap with ThemeProvider using initial color scheme from config and a toggle mechanism",
        "5. Add BrowserRouter and define routes: '/signin' -> SignIn, '/' -> Dashboard (ProtectedRoute)",
        "6. Wrap with ErrorBoundary and Suspense boundaries with appropriate fallbacks",
        "7. Ensure global CSS import (Tailwind) and register service worker for offline if enabled"
      ],
      "integration_points": [
        "Depends on src/app/config/config.ts for environment values",
        "Depends on src/app/routes/ProtectedRoute.tsx to guard routes",
        "Depends on src/features/auth/components/SignIn.tsx for unauthenticated redirects",
        "Provides routing context to all feature pages"
      ],
      "prompt_context": {
        "component_type": "entry",
        "data_model": null,
        "interactions": [
          "bootstrapping",
          "routing",
          "provider setup"
        ],
        "styling_approach": "Tailwind",
        "dependencies": [
          "src/app/config/config.ts",
          "src/app/routes/ProtectedRoute.tsx",
          "src/features/auth/components/SignIn.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "protected-route",
      "title": "Protected Route (src/app/routes/ProtectedRoute.tsx)",
      "description": "Guarded wrapper component that ensures only authenticated users can access protected screens.",
      "file_to_implement": "src/app/routes/ProtectedRoute.tsx",
      "acceptance": [
        "Renders children when authentication state is valid",
        "Redirects to '/signin' when not authenticated and preserves intended path",
        "Refreshes/validates token if near expiry using config and auth service",
        "Accessible focus management when redirect occurs"
      ],
      "implementation_steps": [
        "1. Import React, React Router's Navigate, and auth context/service",
        "2. Create a functional component ProtectedRoute({ children }): JSX.Element",
        "3. Read auth state from a global AuthContext or useAuth hook",
        "4. If not authenticated, return <Navigate to='/signin' replace state={{ from: location }} />",
        "5. If authenticated, render children",
        "6. Optionally trigger token refresh in effect when route is accessed and token is near expiry"
      ],
      "integration_points": [
        "Used by src/app/main.tsx router definitions",
        "Depends on src/features/auth/hooks/useAuthProvider.ts or similar",
        "Provides consistent redirect behavior to SignIn"
      ],
      "prompt_context": {
        "component_type": "routing",
        "data_model": "user authentication state",
        "interactions": [
          "route guarding",
          "redirection"
        ],
        "styling_approach": "Tailwind",
        "dependencies": [
          "src/app/config/config.ts",
          "src/features/auth/components/SignIn.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "auth-signin",
      "title": "Sign-in Component (src/features/auth/components/SignIn.tsx)",
      "description": "Authentication form with validation, submission to API, and token handling. Redirects on success.",
      "file_to_implement": "src/features/auth/components/SignIn.tsx",
      "acceptance": [
        "Renders email and password fields with accessible labels and ARIA attributes",
        "Client-side validation with real-time feedback and error messages",
        "Submits credentials to login API, handles loading, success (store token), and error states",
        "On success, redirects to the originally requested route or dashboard",
        "Stores authentication token securely (e.g., HttpOnly cookie guidance or secure localStorage as fallback)"
      ],
      "implementation_steps": [
        "1. Create SignIn functional component with internal local state for form fields and errors",
        "2. Integrate a form validation library (e.g., react-hook-form or simple validators) and display inline errors",
        "3. Call an Auth API wrapper (src/shared/utils/api.ts) to perform login",
        "4. On success, store token in a secure place and update global auth context",
        "5. Use useNavigate to redirect to intended path or '/dashboard'",
        "6. Provide accessibility features (aria-invalid, aria-live for errors, keyboard support)"
      ],
      "integration_points": [
        "Used by App Router as the SignIn route",
        "Updates global auth state consumed by ProtectedRoute and dashboard data fetchers",
        "Can leverage i18n for labels and messages"
      ],
      "prompt_context": {
        "component_type": "form",
        "data_model": "authentication",
        "interactions": [
          "login",
          "validation",
          "redirect"
        ],
        "styling_approach": "Tailwind",
        "dependencies": [
          "src/app/config/config.ts",
          "src/shared/utils/api.ts"
        ]
      },
      "priority": 1
    },
    {
      "id": "dashboard-page",
      "title": "Dashboard Page (src/features/dashboard/pages/Dashboard.tsx)",
      "description": "Orchestrates the dashboard by composing layout, live updates, charts, and data tables. Fetches data via React Query.",
      "file_to_implement": "src/features/dashboard/pages/Dashboard.tsx",
      "acceptance": [
        "Fetches dashboard metrics and table data via React Query",
        "Renders DashboardLayout with a responsive grid and proper spacing",
        "Includes LiveUpdates, multiple ChartCard instances, and DataTable",
        "Supports loading and error states via Suspense/ErrorBoundary or query fallbacks",
        "Code-split via React.lazy for heavy sub-sections"
      ],
      "implementation_steps": [
        "1. Define a Dashboard component that uses useQuery (or multiple queries) to fetch metrics and table data",
        "2. Use dynamic imports for heavy sections (e.g., charts) via React.lazy",
        "3. Compose DashboardLayout and pass children for main content slots",
        "4. Include LiveUpdates component and DataTable with virtualization",
        "5. Ensure proper aria-labels and keyboard navigation for sections",
        "6. Provide fallback UI for loading states and handle query error states"
      ],
      "integration_points": [
        "Renders within src/app/main.tsx routing as the protected dashboard route",
        "Consumes DashboardLayout, LiveUpdates, DataTable, and ChartCard components",
        "Uses useWebSocket hook through LiveUpdates for real-time data"
      ],
      "prompt_context": {
        "component_type": "page",
        "data_model": "dashboard",
        "interactions": [
          "fetch",
          "display",
          "real-time updates",
          "filter/sort"
        ],
        "styling_approach": "Tailwind",
        "dependencies": [
          "src/features/dashboard/components/DashboardLayout.tsx",
          "src/features/dashboard/components/LiveUpdates.tsx",
          "src/features/dashboard/components/DataTable.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "dashboard-layout",
      "title": "Dashboard Layout (src/features/dashboard/components/DashboardLayout.tsx)",
      "description": "Responsive layout with header, navigation, and content area. Provides slots for header actions and content.",
      "file_to_implement": "src/features/dashboard/components/DashboardLayout.tsx",
      "acceptance": [
        "Responsive header with dark mode toggle and user avatar",
        "Sticky responsive navigation that collapses on small screens",
        "Content area renders children with consistent padding and grid gaps",
        "ARIA roles and keyboard accessible navigation"
      ],
      "implementation_steps": [
        "1. Create a functional component DashboardLayout that accepts children and optional headerActions",
        "2. Implement header with title, search (ARIA-labeled), theme toggle, and user menu",
        "3. Implement responsive sidebar navigation using Tailwind utilities",
        "4. Use a CSS grid/flex layout to arrange header, nav, and main content",
        "5. Ensure proper focus management and keyboard navigation for menu items"
      ],
      "integration_points": [
        "Used by Dashboard.tsx to wrap content",
        "Contains ChartCard and LiveUpdates sections as children"
      ],
      "prompt_context": {
        "component_type": "layout",
        "data_model": "UI chrome",
        "interactions": [
          "navigate",
          "theme-toggle"
        ],
        "styling_approach": "Tailwind",
        "dependencies": [
          "src/features/dashboard/pages/Dashboard.tsx",
          "src/shared/components/ChartCard.tsx"
        ]
      },
      "priority": 1
    },
    {
      "id": "chart-card",
      "title": "Chart Card (src/shared/components/ChartCard.tsx)",
      "description": "A reusable card wrapper for charts: title, loading state, and responsive chart container.",
      "file_to_implement": "src/shared/components/ChartCard.tsx",
      "acceptance": [
        "Renders a title, optional subtitle, and a chart/content area",
        "Shows a loading skeleton when data is not yet available",
        "Accepts children and passes through aria-labels for accessibility",
        "Memoized to prevent unnecessary re-renders"
      ],
      "implementation_steps": [
        "1. Create a React.memo functional component ChartCard that accepts title, subtitle, loading, and children",
        "2. Structure layout with a header row (title, subtitle) and body container",
        "3. Render a skeleton/loading indicator when loading is true",
        "4. Inject a11y attributes such as role='region' and aria-label",
        "5. Forward any extra props to the container div for flexibility"
      ],
      "integration_points": [
        "Used by Dashboard.tsx to wrap LineChart/BarChart components",
        "Receives chart content as children from lazy-loaded chart components"
      ],
      "prompt_context": {
        "component_type": "compound",
        "data_model": "UI chart container",
        "interactions": [
          "display",
          "loading state"
        ],
        "styling_approach": "Tailwind",
        "dependencies": [
          "src/shared/utils/api.ts"
        ]
      },
      "priority": 2
    },
    {
      "id": "live-updates",
      "title": "Live Updates (src/features/dashboard/components/LiveUpdates.tsx)",
      "description": "Real-time feed panel subscribing to WebSocket updates and rendering a compact list with virtualization.",
      "file_to_implement": "src/features/dashboard/components/LiveUpdates.tsx",
      "acceptance": [
        "Subscribes to a WebSocket stream via useWebSocket hook",
        "Renders a compact, accessible list with live items",
        "Implements optimistic updates when local edits occur (if applicable)",
        "Cleans up WebSocket connection on unmount"
      ],
      "implementation_steps": [
        "1. Import useWebSocket hook and define a channel/endpoint from config",
        "2. Use the hook to subscribe to updates and store in local state or query cache",
        "3. Render items using a virtualized list if the number of updates is large",
        "4. Provide a11y-friendly notifications area (aria-live) and proper focus management",
        "5. Implement cleanup on unmount"
      ],
      "integration_points": [
        "Tied to Dashboard page and WebSocket config from src/shared/hooks/useWebSocket.ts",
        "Updates UI in near realtime inside the dashboard layout"
      ],
      "prompt_context": {
        "component_type": "real-time",
        "data_model": "live-update feed",
        "interactions": [
          "subscribe",
          "update UI",
          "handle reconnection"
        ],
        "styling_approach": "Tailwind",
        "dependencies": [
          "src/shared/hooks/useWebSocket.ts"
        ]
      },
      "priority": 2
    },
    {
      "id": "data-table",
      "title": "Data Table (src/features/dashboard/components/DataTable.tsx)",
      "description": "Generic virtualization-enabled data table with sorting and filtering hooks.",
      "file_to_implement": "src/features/dashboard/components/DataTable.tsx",
      "acceptance": [
        "Renders a virtualized list using react-window (or similar)",
        "Supports column-based sorting and client-side filtering",
        "Accessible table with proper semantic markup and ARIA attributes",
        "Accepts a generic row type and column definitions via props"
      ],
      "implementation_steps": [
        "1. Define a generic DataTable<T> component with props: columns, data, onSort, onFilter",
        "2. Integrate react-window to render only visible rows",
        "3. Implement header with sortable columns and ARIA sort indicators",
        "4. Add an inline filter input per column or global filter as needed",
        "5. Ensure keyboard navigation and screen-reader friendly markup"
      ],
      "integration_points": [
        "Used by Dashboard.tsx to display metrics or transactional data",
        "Receives data from React Query in Dashboard.tsx or via a shared API layer"
      ],
      "prompt_context": {
        "component_type": "data-grid",
        "data_model": "array-row",
        "interactions": [
          "sort",
          "filter",
          "scroll"
        ],
        "styling_approach": "Tailwind",
        "dependencies": [
          "src/shared/hooks/useWebSocket.ts"
        ]
      },
      "priority": 2
    },
    {
      "id": "websocket-hook",
      "title": "WebSocket Hook (src/shared/hooks/useWebSocket.ts)",
      "description": "Reusable hook to manage a WebSocket connection with clean lifecycle and reconnection logic.",
      "file_to_implement": "src/shared/hooks/useWebSocket.ts",
      "acceptance": [
        "Establishes a WebSocket connection on mount and closes on unmount",
        "Provides onMessage callback and a stable data stream interface",
        "Includes simple reconnection/backoff strategy on error",
        "Exposes status and lastMessage for easy consumption by components"
      ],
      "implementation_steps": [
        "1. Create a generic hook function useWebSocket(url, onMessage?)",
        "2. Manage socket instance with useRef and connection state with useState",
        "3. Implement onopen, onmessage, onclose handlers and a reconnect strategy with exponential backoff",
        "4. Provide a cleanup effect to close socket on unmount",
        "5. Return { data, status, error, lastMessage } to consumers"
      ],
      "integration_points": [
        "Used by LiveUpdates.tsx for real-time data",
        "Can be reused by other real-time features (e.g., notifications)"
      ],
      "prompt_context": {
        "component_type": "hook",
        "data_model": "stream data",
        "interactions": [
          "connect",
          "receive",
          "disconnect"
        ],
        "styling_approach": "Tailwind",
        "dependencies": [
          "src/app/config/config.ts"
        ]
      },
      "priority": 1
    },
    {
      "id": "config-file",
      "title": "App Configuration (src/app/config/config.ts)",
      "description": "Centralized, typed configuration sourced from environment variables with safe defaults.",
      "file_to_implement": "src/app/config/config.ts",
      "acceptance": [
        "Exports a typed Config object with fields like apiBaseUrl, featureFlags, enableOffline, etc.",
        "Implements a safe, runtime-checked initialization with defaults",
        "Supports environment overrides (process.env or import.meta.env depending on bundler)",
        "Provides color mode default and feature flags for conditional rendering"
      ],
      "implementation_steps": [
        "1. Define TypeScript interface Config with required properties",
        "2. Create a config object reading from environment variables with defaults",
        "3. Validate required fields (throw during dev if missing) and export as default",
        "4. Export helper getters for runtime decisions (e.g., isDarkMode, apiBaseUrl)"
      ],
      "integration_points": [
        "Used by main.tsx, ProtectedRoute, and API clients",
        "Controls feature flags and environment-sensitive behavior"
      ],
      "prompt_context": {
        "component_type": "config",
        "data_model": null,
        "interactions": [
          "load",
          "validate",
          "expose"
        ],
        "styling_approach": "Tailwind",
        "dependencies": []
      },
      "priority": 1
    }
  ]
}