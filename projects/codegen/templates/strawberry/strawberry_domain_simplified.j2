"""
Strawberry GraphQL domain types for DiPeO.
Auto-generated from TypeScript interfaces using simplified type resolver.

Generated at: {{ generated_at }}
"""

import strawberry
from typing import Optional, Dict, Any, List, Union
from strawberry.scalars import JSON as JSONScalar

# Import the Pydantic domain models
from dipeo.diagram_generated.domain_models import (
{%- for type in types %}
    {{ type['name'] }},
{%- endfor %}
)

# Import required enums for GraphQL type resolution
from dipeo.diagram_generated.enums import (
    Status,
    NodeType,
    EventType,
    HandleLabel,
    HandleDirection,
    DataType,
    ContentType,
    LLMService,
    APIServiceType,
    ToolType,
)

# Import scalar types from shared file
from .scalar_aliases import (
    CliSessionIDScalar,
    NodeIDScalar,
    ArrowIDScalar,
    HandleIDScalar,
    PersonIDScalar,
    ApiKeyIDScalar,
    DiagramIDScalar,
    ExecutionIDScalar,
    FileIDScalar,
    HookIDScalar,
    TaskIDScalar,
    SerializedNodeOutput,
)

# Import generated types that already exist
from dipeo.diagram_generated.graphql.strawberry_domain import (
    ToolConfigType,
)

# Create Strawberry types from Pydantic models
# Order matters - define types that are referenced by others first
{% for type in types %}
{%- if type.get('can_use_pydantic_decorator') %}
@strawberry.experimental.pydantic.type(model={{ type['name'] }}, all_fields=True)
class {{ type['name'] }}Type:
    """{{ type.get('description', 'Auto-generated from Pydantic model') }}"""
    pass
{%- else %}
@strawberry.type
class {{ type['name'] }}Type:
{%- if type.get('description') %}
    """{{ type.get('description') }}"""
{%- endif %}
{%- if type.get('resolved_fields') %}
    {%- for field in type.get('resolved_fields', []) %}
    {{ field['name'] }}: {{ field['strawberry_type'] }}{{ field.get('default', '') }}
    {%- endfor %}
{%- else %}
    # Using original fields as fallback (should not happen with resolver)
    {%- for field in type.get('fields', []) %}
    {%- if field.get('is_json_dict') %}
    {{ field['name'] }}: {{ 'Optional[JSONScalar]' if field.get('optional') else 'JSONScalar' }}{{ ' = None' if field.get('optional') else '' }}
    {%- elif field.get('is_literal') %}
    {{ field['name'] }}: {{ 'Optional[str]' if field.get('optional') else 'str' }}{{ ' = None' if field.get('optional') else '' }}
    {%- elif field.get('type', '').startswith('List[Domain') %}
    {{ field['name'] }}: List[{{ field.get('type', '').replace('List[', '').replace(']', '') }}Type]
    {%- elif field.get('type', '').startswith('Domain') %}
    {{ field['name'] }}: {{ field.get('type') }}Type
    {%- elif field.get('type', '').endswith('ID') %}
    {{ field['name'] }}: {{ 'Optional[' + field.get('type') + 'Scalar]' if field.get('optional') else field.get('type') + 'Scalar' }}{{ ' = None' if field.get('optional') else '' }}
    {%- else %}
    {{ field['name'] }}: {{ 'Optional[' + field.get('type', '') + ']' if field.get('optional') and not field.get('type', '').startswith('Optional[') else field.get('type', '') }}{{ ' = None' if field.get('optional') else '' }}
    {%- endif %}
    {%- endfor %}
{%- endif %}

{%- if type.get('needs_manual_conversion') and type.get('conversion_method') %}

    {{ type.get('conversion_method') | indent(4) }}
{%- elif type.get('needs_manual_conversion') %}

    @staticmethod
    def from_pydantic(obj: {{ type['name'] }}) -> "{{ type['name'] }}Type":
        """Convert from Pydantic model"""
        return {{ type['name'] }}Type(
        {%- for field in type.get('resolved_fields', []) %}
            {%- if field.get('conversion_expr') %}
            {{ field['name'] }}={{ field.get('conversion_expr') }},
            {%- else %}
            {{ field['name'] }}=obj.{{ field['name'] }},
            {%- endif %}
        {%- endfor %}
        )
{%- endif %}
{%- endif %}

{% endfor %}
