"""
Strawberry GraphQL mutations for DiPeO nodes.
Generated automatically from node specifications.

Generated at: {{ generated_at | default('N/A') }}
"""

import strawberry
from typing import *
from strawberry.types import *

# Import data types and unions
from .strawberry_nodes import *

# Import base types
from dipeo.diagram_generated.graphql.domain_types import *
from dipeo.diagram_generated.graphql.inputs import *
from .enums import DiagramFormatGraphQL
from strawberry.file_uploads import Upload

# Import services and keys
from dipeo.application.registry import ServiceRegistry
from dipeo.application.registry.keys import (
    DIAGRAM_PORT,
    EXECUTION_SERVICE,
    PERSON_REPOSITORY,
    CONVERSATION_REPOSITORY,
    API_KEY_SERVICE,
    ServiceKey
)


# Generate input types for each node if node_specs exist
{% if node_specs %}
{% for type_info in node_specs %}
@strawberry.input
class Create{{ type_info['name'] | pascal_case }}Input:
    """Input for creating a {{ type_info.get('spec', {}).get('displayName', type_info['name']) }} node"""
    diagram_id: str
    position: Vec2Input
    label: Optional[str] = None

    # Node-specific fields from specification
    {% for field in type_info.get('spec', {}).get('fields', []) %}
    {% if field['is_enum'] %}
    # Enum field: {{ field['description'] }}
    {{ field['name'] }}: {{ 'Optional[str]' if not field['required'] else 'str' }}{{ ' = None' if not field['required'] }}  # Values: {{ field['enum_values'] }}
    {% elif field['is_object_type'] %}
    {{ field['name'] }}: {{ 'Optional[strawberry.scalars.JSON]' if not field['required'] else 'strawberry.scalars.JSON' }}{{ ' = None' if not field['required'] }}  # {{ field['description'] }}
    {% elif field['graphql_type'] == 'Int' %}
    {{ field['name'] }}: {{ 'Optional[int]' if not field['required'] else 'int' }}{{ ' = None' if not field['required'] }}  # {{ field['description'] }}
    {% elif field['graphql_type'] == 'Boolean' %}
    {{ field['name'] }}: {{ 'Optional[bool]' if not field['required'] else 'bool' }}{{ ' = None' if not field['required'] }}  # {{ field['description'] }}
    {% else %}
    {{ field['name'] }}: {{ 'Optional[str]' if not field['required'] else 'str' }}{{ ' = None' if not field['required'] }}  # {{ field['description'] }}
    {% endif %}
    {% endfor %}

@strawberry.input
class Update{{ type_info['name'] | pascal_case }}Input:
    """Input for updating a {{ type_info.get('spec', {}).get('displayName', type_info['name']) }} node"""
    position: Optional[Vec2Input] = None
    label: Optional[str] = None

    # Node-specific fields from specification (all optional for updates)
    {% for field in type_info.get('spec', {}).get('fields', []) %}
    {% if field['is_enum'] %}
    # Enum field: {{ field['description'] }}
    {{ field['name'] }}: Optional[str] = None  # Values: {{ field['enum_values'] }}
    {% elif field['is_object_type'] %}
    {{ field['name'] }}: Optional[strawberry.scalars.JSON] = None  # {{ field['description'] }}
    {% elif field['graphql_type'] == 'Int' %}
    {{ field['name'] }}: Optional[int] = None  # {{ field['description'] }}
    {% elif field['graphql_type'] == 'Boolean' %}
    {{ field['name'] }}: Optional[bool] = None  # {{ field['description'] }}
    {% else %}
    {{ field['name'] }}: Optional[str] = None  # {{ field['description'] }}
    {% endif %}
    {% endfor %}

{% endfor %}
{% endif %}


@strawberry.type
class NodeMutations:
    """Type-safe mutations for node operations"""

{# Process mutations from the operations IR data - use raw_mutations for correct structure #}
{% if raw_mutations %}
{% for mutation in raw_mutations %}
    @strawberry.mutation
    async def {{ mutation['name'] | snake_case }}(
        self,
        info: Info,
        {% if mutation.variables %}
        {% for var in mutation.variables %}
        {{ var['name'] }}: {{ var.get('python_type', var.get('type')) | graphql_to_python(required= var.get('required', false)) }}{{ "," if not loop.last }}
        {% endfor %}
        {% endif %}
    ) -> Any:  # Return type will be determined by the resolver
        """{{ mutation['name'] }} - {{ mutation.get('entity', '') }} mutation"""
        registry: ServiceRegistry = info.context["registry"]

        # Build variables dict
        variables = {
            {% if mutation.variables %}
            {% for var in mutation.variables %}
            "{{ var['name'] }}": {{ var['name'] }}{{ "," if not loop.last }}
            {% endfor %}
            {% endif %}
        }

        # Determine service and execute mutation based on type
        mutation_lower = "{{ mutation['name'] }}".lower()

        {% if 'node' in mutation['name'].lower() or 'Node' in mutation['name'] %}
        # Node-related mutations use DIAGRAM_PORT
        service = registry.resolve(DIAGRAM_PORT)

        # Call the appropriate method based on the operation
        {% if 'create' in mutation['name'].lower() %}
        result = await service.create_node(**variables)
        {% elif 'update' in mutation['name'].lower() %}
        result = await service.update_node(**variables)
        {% elif 'delete' in mutation['name'].lower() %}
        result = await service.delete_node(**variables)
        {% else %}
        # Generic node operation
        result = await service.handle_mutation("{{ mutation['name'] }}", variables)
        {% endif %}

        {% elif 'diagram' in mutation['name'].lower() %}
        # Diagram mutations
        service = registry.resolve(DIAGRAM_PORT)
        result = await service.handle_mutation("{{ mutation['name'] }}", variables)

        {% elif 'execution' in mutation['name'].lower() %}
        # Execution mutations
        service = registry.resolve(EXECUTION_SERVICE)
        result = await service.handle_mutation("{{ mutation['name'] }}", variables)

        {% elif 'person' in mutation['name'].lower() %}
        # Person mutations
        service = registry.resolve(PERSON_REPOSITORY)
        result = await service.handle_mutation("{{ mutation['name'] }}", variables)

        {% elif 'conversation' in mutation['name'].lower() %}
        # Conversation mutations
        service = registry.resolve(CONVERSATION_REPOSITORY)
        result = await service.handle_mutation("{{ mutation['name'] }}", variables)

        {% elif 'api_key' in mutation['name'].lower() or 'apikey' in mutation['name'].lower() %}
        # API Key mutations
        service = registry.resolve(API_KEY_SERVICE)
        result = await service.handle_mutation("{{ mutation['name'] }}", variables)

        {% else %}
        # Default to DIAGRAM_PORT
        service = registry.resolve(DIAGRAM_PORT)
        result = await service.handle_mutation("{{ mutation['name'] }}", variables)
        {% endif %}

        return result

{% endfor %}
{% else %}
    # No mutations defined yet
    pass
{% endif %}


# Export mutations
__all__ = [
    'NodeMutations',
{% if node_specs %}
{% for type_info in node_specs %}
    'Create{{ type_info['name'] | pascal_case }}Input',
    'Update{{ type_info['name'] | pascal_case }}Input',
{% endfor %}
{% endif %}
]
