"""
Strawberry GraphQL mutations for DiPeO nodes.
Generated automatically from node specifications.

Generated at: {{ generated_at | default('N/A') }}
"""

import strawberry
from typing import *
from strawberry.types import *

# Import data types and unions
from .strawberry_nodes import *

# Import base types
from dipeo.diagram_generated.graphql.domain_types import *
from dipeo.diagram_generated.graphql.inputs import *

# Import services and keys
from dipeo.application.registry import *
from dipeo.application.registry.keys import *


# Generate input types for each node
{% for type_info in node_specs %}
@strawberry.input
class Create{{ type_info['name'] | pascal_case }}Input:
    """Input for creating a {{ type_info.get('spec', {}).get('displayName', type_info['name']) }} node"""
    diagram_id: str
    position: Vec2Input
    # TODO: Add node-specific fields from spec
    # For now, we accept a generic data dict that will be validated
    data: strawberry.scalars.JSON

@strawberry.input
class Update{{ type_info['name'] | pascal_case }}Input:
    """Input for updating a {{ type_info.get('spec', {}).get('displayName', type_info['name']) }} node"""
    # TODO: Add node-specific fields from spec
    # For now, we accept a generic data dict that will be validated
    data: Optional[strawberry.scalars.JSON] = None
    position: Optional[Vec2Input] = None

{% endfor %}


@strawberry.type
class NodeMutations:
    """Type-safe mutations for node operations"""

{% for mutation in mutations %}
    @strawberry.mutation
    async def {{ mutation['name'] }}(
        self,
        info: Info,
        {% if mutation.get('operation') == 'create' %}input: {{ mutation['input_type'] }}{% else %}id: str, input: {{ mutation['input_type'] }}{% endif %}
    ) -> {{ mutation['return_type'] }}:
        """{{ mutation.get('operation', '').capitalize() }} a {{ mutation.get('node_type', '').replace('_', ' ').title() }} node"""
        registry: ServiceRegistry = info.context["registry"]

        {% if mutation.get('operation') == 'create' %}
        # Prepare node data
        node_data = {
            "type": "{{ mutation.node_type }}",
            "position": input.position,
            "data": input.data
        }

        # Get diagram service
        integrated_service = registry.resolve(DIAGRAM_PORT)

        # Create the node
        domain_node = await integrated_service.create_node(
            diagram_id=input.diagram_id,
            node_data=node_data
        )
        {% else %}
        # Get diagram service
        integrated_service = registry.resolve(DIAGRAM_PORT)

        # Update the node
        domain_node = await integrated_service.update_node(
            diagram_id=None,  # TODO: Need diagram_id from somewhere
            node_id=id,
            data=input.data
        )
        {% endif %}

        # Convert to GraphQL type
        # For now, return the DomainNodeType directly
        return DomainNodeType(
            id=domain_node.id,
            type=domain_node.type,
            position=domain_node.position,
            data=domain_node.data
        )

{% endfor %}


# Export mutations
__all__ = [
    'NodeMutations',
{% for type_info in node_specs %}
    'Create{{ type_info.name | pascal_case }}Input',
    'Update{{ type_info.name | pascal_case }}Input',
{% endfor %}
]
