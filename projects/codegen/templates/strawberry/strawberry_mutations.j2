"""
Strawberry GraphQL mutations for DiPeO nodes.
Generated automatically from node specifications.

Generated at: {{ generated_at | default('N/A') }}
"""

import strawberry
from typing import *
from strawberry.types import *

# Import data types and unions
from .strawberry_nodes import *

# Import base types
from dipeo.diagram_generated.graphql.domain_types import *
from dipeo.diagram_generated.graphql.inputs import *
from .enums import DiagramFormatGraphQL
from strawberry.file_uploads import Upload

# Import services and keys
from dipeo.application.registry import ServiceRegistry
from dipeo.application.registry.keys import (
    DIAGRAM_PORT,
    EXECUTION_SERVICE,
    PERSON_REPOSITORY,
    CONVERSATION_REPOSITORY,
    API_KEY_SERVICE,
    ServiceKey
)


# Generate input types for each node if node_specs exist
{% if node_specs %}
{% for type_info in node_specs %}
@strawberry.input
class Create{{ type_info['name'] | pascal_case }}Input:
    """Input for creating a {{ type_info.get('spec', {}).get('displayName', type_info['name']) }} node"""
    diagram_id: str
    position: Vec2Input
    # TODO: Add node-specific fields from spec
    # For now, we accept a generic data dict that will be validated
    data: strawberry.scalars.JSON

@strawberry.input
class Update{{ type_info['name'] | pascal_case }}Input:
    """Input for updating a {{ type_info.get('spec', {}).get('displayName', type_info['name']) }} node"""
    # TODO: Add node-specific fields from spec
    # For now, we accept a generic data dict that will be validated
    data: Optional[strawberry.scalars.JSON] = None
    position: Optional[Vec2Input] = None

{% endfor %}
{% endif %}


@strawberry.type
class NodeMutations:
    """Type-safe mutations for node operations"""

{# Process mutations from the operations IR data - use raw_mutations for correct structure #}
{% if raw_mutations %}
{% for mutation in raw_mutations %}
    @strawberry.mutation
    async def {{ mutation.name | snake_case }}(
        self,
        info: Info,
        {% if mutation.variables %}
        {% for var in mutation.variables %}
        {{ var.name }}: {{ var.python_type | default(var.type) | graphql_to_python(required= var.required) }}{{ "," if not loop.last }}
        {% endfor %}
        {% endif %}
    ) -> Any:  # Return type will be determined by the resolver
        """{{ mutation.name }} - {{ mutation.entity | default('') }} mutation"""
        registry: ServiceRegistry = info.context["registry"]

        # Build variables dict
        variables = {
            {% if mutation.variables %}
            {% for var in mutation.variables %}
            "{{ var.name }}": {{ var.name }}{{ "," if not loop.last }}
            {% endfor %}
            {% endif %}
        }

        # Determine service and execute mutation based on type
        mutation_lower = "{{ mutation.name }}".lower()

        {% if 'node' in mutation.name.lower() or 'Node' in mutation.name %}
        # Node-related mutations use DIAGRAM_PORT
        service = registry.resolve(DIAGRAM_PORT)

        # Call the appropriate method based on the operation
        {% if 'create' in mutation.name.lower() %}
        result = await service.create_node(**variables)
        {% elif 'update' in mutation.name.lower() %}
        result = await service.update_node(**variables)
        {% elif 'delete' in mutation.name.lower() %}
        result = await service.delete_node(**variables)
        {% else %}
        # Generic node operation
        result = await service.handle_mutation("{{ mutation.name }}", variables)
        {% endif %}

        {% elif 'diagram' in mutation.name.lower() %}
        # Diagram mutations
        service = registry.resolve(DIAGRAM_PORT)
        result = await service.handle_mutation("{{ mutation.name }}", variables)

        {% elif 'execution' in mutation.name.lower() %}
        # Execution mutations
        service = registry.resolve(EXECUTION_SERVICE)
        result = await service.handle_mutation("{{ mutation.name }}", variables)

        {% elif 'person' in mutation.name.lower() %}
        # Person mutations
        service = registry.resolve(PERSON_REPOSITORY)
        result = await service.handle_mutation("{{ mutation.name }}", variables)

        {% elif 'conversation' in mutation.name.lower() %}
        # Conversation mutations
        service = registry.resolve(CONVERSATION_REPOSITORY)
        result = await service.handle_mutation("{{ mutation.name }}", variables)

        {% elif 'api_key' in mutation.name.lower() or 'apikey' in mutation.name.lower() %}
        # API Key mutations
        service = registry.resolve(API_KEY_SERVICE)
        result = await service.handle_mutation("{{ mutation.name }}", variables)

        {% else %}
        # Default to DIAGRAM_PORT
        service = registry.resolve(DIAGRAM_PORT)
        result = await service.handle_mutation("{{ mutation.name }}", variables)
        {% endif %}

        return result

{% endfor %}
{% else %}
    # No mutations defined yet
    pass
{% endif %}


# Export mutations
__all__ = [
    'NodeMutations',
{% if node_specs %}
{% for type_info in node_specs %}
    'Create{{ type_info['name'] | pascal_case }}Input',
    'Update{{ type_info['name'] | pascal_case }}Input',
{% endfor %}
{% endif %}
]
