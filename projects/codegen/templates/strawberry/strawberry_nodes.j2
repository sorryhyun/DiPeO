"""
Strawberry GraphQL types for DiPeO nodes.
Generated automatically from node specifications.

Generated at: {{ generated_at }}
"""

import strawberry
from typing import Optional, Dict, Any, List, Union, Literal
from strawberry.types import *
from strawberry.scalars import JSON as JSONScalar
from .strawberry_domain import TemplatePreprocessorType, ToolConfigType
from .domain_types import Vec2Type

# Import Pydantic models

from ..domain_models import *
from ..unified_nodes import *

# Import generated scalars
from .scalars import *


# Generate Strawberry types for node data
{% for type_info in node_specs %}
@strawberry.type
class {{ type_info['name'] | pascal_case }}DataType:
    """{{ type_info.get('spec', {}).get('description', '') }} - Data fields only"""
    # Base fields (all nodes have these)
    id: NodeIDScalar
    position: Vec2Type
    type: strawberry.Private[NodeType]  # Not exposed in GraphQL
    label: Optional[str] = None
    flipped: Optional[bool] = False
    metadata: Optional[JSONScalar] = None  # Use JSONScalar for Dict fields

    # Node-specific fields from specification
    {% for field in type_info.get('spec', {}).get('fields', []) %}
    {% if field.get('is_object_type') or field.get('is_dict_type') %}
    {{ field['name'] }}: {{ 'JSONScalar' if field.get('required') else 'Optional[JSONScalar]' }}{{ ' = None' if not field.get('required') }}  # {{ field.get('description', '') }}
    {% elif field.get('is_enum') %}
    # Enum field: {{ field.get('description', '') }} (Values: {{ field.get('enum_values', []) | join(', ') }})
    {{ field['name'] }}: {{ 'str' if field.get('required') else 'Optional[str]' }}{{ ' = None' if not field.get('required') }}
    {% elif field.get('graphql_type') == 'Int' or field.get('python_type') == 'int' %}
    {{ field['name'] }}: {{ 'int' if field.get('required') else 'Optional[int]' }}{{ ' = None' if not field.get('required') }}  # {{ field.get('description', '') }}
    {% elif field.get('graphql_type') == 'Boolean' or field.get('python_type') == 'bool' %}
    {{ field['name'] }}: {{ 'bool' if field.get('required') else 'Optional[bool]' }}{{ ' = None' if not field.get('required') }}  # {{ field.get('description', '') }}
    {% elif field.get('graphql_type') == '[JSON]' or field.get('python_type', '').startswith('List[') %}
    {{ field['name'] }}: {{ 'List[JSONScalar]' if field.get('required') else 'Optional[List[JSONScalar]]' }}{{ ' = None' if not field.get('required') }}  # {{ field.get('description', '') }}
    {% else %}
    {{ field['name'] }}: {{ 'str' if field.get('required') else 'Optional[str]' }}{{ ' = None' if not field.get('required') }}  # {{ field.get('description', '') }}
    {% endif %}
    {% endfor %}

    @classmethod
    def from_pydantic(cls, node: {{ type_info['name'] | pascal_case }}Node) -> "{{ type_info['name'] | pascal_case }}DataType":
        """Convert from Pydantic model to Strawberry type."""
        # Convert Dict fields to JSONScalar
        metadata = node.metadata if node.metadata else None

        # Get node-specific fields with type conversion
        field_values = {}
        {% for field in type_info.get('spec', {}).get('fields', []) %}
        field_value = getattr(node, "{{ field['name'] }}", None)
        {% if field.get('is_object_type') or field.get('is_dict_type') %}
        # Convert dict/object fields to JSONScalar
        field_values["{{ field['name'] }}"] = field_value
        {% else %}
        # Direct assignment for other types
        field_values["{{ field['name'] }}"] = field_value
        {% endif %}
        {% endfor %}

        return cls(
            id=node.id,
            position=Vec2Type(x=node.position.x, y=node.position.y),
            type=node.type,
            label=node.label,
            flipped=node.flipped,
            metadata=metadata,
            **field_values
        )

{% endfor %}
{% if node_specs %}

# Create union type for all node data types
NodeDataUnion = strawberry.union(
    "NodeDataUnion",
    (
{% for type_info in node_specs %}
        {{ type_info['name'] | pascal_case }}DataType,
{% endfor %}
    )
)
{% else %}

# Placeholder type when no node types are available yet
@strawberry.type
class PlaceholderNodeData:
    """Placeholder type used during initial generation"""
    message: str = "No node types generated yet"

NodeDataUnion = PlaceholderNodeData
{% endif %}


# Export all types
__all__ = [
    'NodeDataUnion',
{% for type_info in node_specs %}
    '{{ type_info['name'] | pascal_case }}DataType',
{% endfor %}
]
