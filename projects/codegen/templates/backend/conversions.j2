"""
GENERATED FILE - DO NOT EDIT
Generated by backend conversions generation
Generated at: {{ generated_at }}

Type conversion utilities between frontend and backend
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union
from datetime import datetime
from .enums import NodeType
{%- if conversions and conversions.type_conversions %}

# Node type mappings (snake_case to CONSTANT_CASE)
NODE_TYPE_MAP = {
{%- for snake_case, constant_case in conversions.node_type_map.items() %}
    '{{ snake_case }}': '{{ constant_case }}',
{%- endfor %}
}
NODE_TYPE_REVERSE_MAP: Dict[NodeType, str] = {v: k for k, v in NODE_TYPE_MAP.items()}

# TypeScript to Python type conversions
TYPE_CONVERSIONS = {
{%- for ts_type, py_type in conversions.type_conversions.items() %}
    '{{ ts_type }}': '{{ py_type }}',
{%- endfor %}
}

# Field type mappings (for UI components)
FIELD_MAPPINGS = {
{%- for field_type, ui_type in conversions.field_mappings.items() %}
    '{{ field_type }}': '{{ ui_type }}',
{%- endfor %}
}

def ts_to_python_type(ts_type: str) -> str:
    """Convert TypeScript type to Python type."""
    return TYPE_CONVERSIONS.get(ts_type, ts_type)

def python_to_ts_type(py_type: str) -> str:
    """Convert Python type to TypeScript type."""
    reverse_map = {v: k for k, v in TYPE_CONVERSIONS.items()}
    return reverse_map.get(py_type, py_type)

def get_node_type_constant(snake_case: str) -> str:
    """Get the constant case node type from snake case."""
    return NODE_TYPE_MAP.get(snake_case, snake_case.upper())

def get_field_ui_type(field_type: str) -> str:
    """Get the UI component type for a field type."""
    return FIELD_MAPPINGS.get(field_type, 'text')

def node_kind_to_domain_type(kind: str) -> NodeType:
    try:
        return NODE_TYPE_MAP[kind]
    except KeyError as exc:
        raise ValueError(f"Unknown node kind: {kind}") from exc


def domain_type_to_node_kind(node_type: NodeType) -> str:
    try:
        return NODE_TYPE_REVERSE_MAP[node_type]
    except KeyError as exc:
        raise ValueError(f"Unknown node type: {node_type}") from exc

{%- else %}

# Default type conversions
TYPE_CONVERSIONS = {
    'string': 'str',
    'number': 'float',
    'boolean': 'bool',
    'any': 'Any',
    'unknown': 'Any',
    'null': 'None',
    'undefined': 'None',
    'void': 'None',
    'Date': 'datetime',
    'object': 'Dict[str, Any]',
}

def ts_to_python_type(ts_type: str) -> str:
    """Convert TypeScript type to Python type."""
    # Handle array types
    if ts_type.startswith('Array<') and ts_type.endswith('>'):
        inner_type = ts_type[6:-1]
        return f'List[{ts_to_python_type(inner_type)}]'

    if ts_type.endswith('[]'):
        inner_type = ts_type[:-2]
        return f'List[{ts_to_python_type(inner_type)}]'

    return TYPE_CONVERSIONS.get(ts_type, ts_type)

def python_to_ts_type(py_type: str) -> str:
    """Convert Python type to TypeScript type."""
    reverse_map = {v: k for k, v in TYPE_CONVERSIONS.items()}

    # Handle List types
    if py_type.startswith('List[') and py_type.endswith(']'):
        inner_type = py_type[5:-1]
        return f'{python_to_ts_type(inner_type)}[]'

    return reverse_map.get(py_type, py_type)
{%- endif %}

# Export utilities
__all__ = [
    'NODE_TYPE_MAP',
    'TYPE_CONVERSIONS',
    'FIELD_MAPPINGS',
    'ts_to_python_type',
    'python_to_ts_type',
    'get_node_type_constant',
    'get_field_ui_type',
]
