"""
Auto-generated unified node model for {{ nodeType }}.
DO NOT EDIT THIS FILE DIRECTLY.
"""

from typing import *
from pydantic import BaseModel, Field, field_validator

from dipeo.domain.diagram.models.executable_diagram import BaseExecutableNode
from dipeo.diagram_generated.domain_models import NodeID, Vec2
from dipeo.diagram_generated.enums import NodeType
{% if nodeType == 'person_job' %}
from dipeo.diagram_generated.domain_models import DomainPerson, PersonLLMConfig
{% endif %}
from dipeo.diagram_generated.enums import *
from dipeo.diagram_generated.integrations import *


class {{ nodeType | pascal_case }}Node(BaseModel):
    """{{ description | default('Node model') }}

    Unified model handling both validation and execution.
    """
    # Required base fields
    id: NodeID
    position: Vec2

    # Required node-specific fields
{%- for field in fields %}
{%- if field.get('required') %}
    {% set python_field_name = field['name'] | snake_case -%}
    {% set needs_alias = python_field_name != field['name'] -%}
    {{ python_field_name }}: {{ field | python_type_with_context(nodeType) }}{% if field.get('description') or needs_alias %} = Field({% if needs_alias %}alias="{{ field['name'] }}"{% if field.get('description') %}, {% endif %}{% endif %}{% if field.get('description') %}description="{{ field['description'] }}"{% endif %}){% endif %}
{%- endif %}
{%- endfor %}

    # Optional base fields
    label: str = Field(default="", description="Node label for display")
    flipped: bool = Field(default=False, description="Whether handles are flipped")
    metadata: Optional[Dict[str, Any]] = Field(default=None, description="Additional metadata")

    # Node type (constant for this node class)
    type: NodeType = Field(default=NodeType.{{ nodeType | replace('-', '_') | upper }}, frozen=True)

    # Optional node-specific fields
{%- for field in fields %}
{%- if not field.get('required') %}
    {% set python_field_name = field['name'] | snake_case -%}
    {% set needs_alias = python_field_name != field['name'] -%}
{%- if field.get('type') in ['object', 'dict', 'json'] %}
    {{ python_field_name }}: {{ field | python_type_with_context(nodeType) }} = Field(default_factory=dict{% if field.get('description') or needs_alias %}, {% if needs_alias %}alias="{{ field['name'] }}"{% if field.get('description') %}, {% endif %}{% endif %}{% if field.get('description') %}description="{{ field['description'] }}"{% endif %}{% endif %})
{%- elif field.get('type') in ['array', 'list'] %}
    {{ python_field_name }}: {{ field | python_type_with_context(nodeType) }} = Field(default_factory=list{% if field.get('description') or needs_alias %}, {% if needs_alias %}alias="{{ field['name'] }}"{% if field.get('description') %}, {% endif %}{% endif %}{% if field.get('description') %}description="{{ field['description'] }}"{% endif %}{% endif %})
{%- else %}
    {{ python_field_name }}: {{ field | python_type_with_context(nodeType) }} = Field(default={{ field | python_default }}{% if field.get('description') or needs_alias %}, {% if needs_alias %}alias="{{ field['name'] }}"{% if field.get('description') %}, {% endif %}{% endif %}{% if field.get('description') %}description="{{ field['description'] }}"{% endif %}{% endif %})
{%- endif %}
{%- endif %}
{%- endfor %}

    class Config:
        # Make the instance immutable after creation
        frozen = True
        # Forbid extra fields
        extra = "forbid"
        # Use enum values for JSON serialization
        use_enum_values = False
        # Allow field aliases for camelCase compatibility
        populate_by_name = True

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation for serialization."""
        data = {
            "id": self.id,
            "type": self.type.value if hasattr(self.type, 'value') else self.type,
            "position": {"x": self.position.x, "y": self.position.y},
            "label": self.label,
            "flipped": self.flipped
        }
        if self.metadata:
            data["metadata"] = self.metadata

        # Add node-specific fields using original names
{%- for field in fields %}
{%- set python_field_name = field['name'] | snake_case %}
{%- if python_field_name != field['name'] %}
        # Use original field name for compatibility
        data["{{ field['name'] }}"] = getattr(self, "{{ python_field_name }}")
{%- else %}
        data["{{ field['name'] }}"] = self.{{ field['name'] }}
{%- endif %}
{%- endfor %}

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "{{ nodeType | pascal_case }}Node":
        """Create node from dictionary representation.

        Handles both camelCase (from JSON/GraphQL) and snake_case (internal) field names.
        """
        # Convert position if needed
        if "position" in data and isinstance(data["position"], dict):
            data["position"] = Vec2(x=data["position"]["x"], y=data["position"]["y"])

        # The Pydantic model will handle field aliasing automatically
        return cls(**data)

    def __hash__(self) -> int:
        """Make the node hashable for use in sets/dicts."""
        return hash(self.id)

    def __eq__(self, other: Any) -> bool:
        """Equality based on node ID."""
        if not isinstance(other, {{ nodeType | pascal_case }}Node):
            return False
        return self.id == other.id
