# Direct TypeScript Batch Parser
# Uses the TypeScript AST node's batch mode to parse all files in a single operation
# Much more efficient than sub_diagram batch approach

version: light

nodes:
  - label: Start
    type: start
    position: {x: 50, y: 200}
    
  # Gather all TypeScript model files
  - label: Gather TypeScript Files
    type: code_job
    position: {x: 200, y: 200}
    props:
      language: python
      code: |
        import os
        import glob
        
        # Define base paths for TypeScript models
        base_dir = os.environ.get('DIPEO_BASE_DIR', '/home/soryhyun/DiPeO')
        models_dir = os.path.join(base_dir, 'dipeo/models/src')
        
        # Gather TypeScript files from main dir and subdirectories
        ts_files = []
        
        # Main directory files
        ts_files.extend(glob.glob(os.path.join(models_dir, '*.ts')))
        
        # Core files
        ts_files.extend(glob.glob(os.path.join(models_dir, 'core', '*.ts')))
        ts_files.extend(glob.glob(os.path.join(models_dir, 'core', 'nodes', '*.ts')))
        ts_files.extend(glob.glob(os.path.join(models_dir, 'core', 'enums', '*.ts')))
        
        # Specifications files
        ts_files.extend(glob.glob(os.path.join(models_dir, 'specifications', '*.ts')))
        ts_files.extend(glob.glob(os.path.join(models_dir, 'specifications', 'nodes', '*.ts')))
        
        # Utilities files
        ts_files.extend(glob.glob(os.path.join(models_dir, 'utilities', '*.ts')))
        
        # Codegen files
        ts_files.extend(glob.glob(os.path.join(models_dir, 'codegen', '*.ts')))
        
        # Frontend files
        ts_files.extend(glob.glob(os.path.join(models_dir, 'frontend', '*.ts')))
        ts_files.extend(glob.glob(os.path.join(models_dir, 'frontend', 'query-definitions', '*.ts')))
        
        print(f"Found {len(ts_files)} TypeScript files to parse")
        
        result = {
            'file_paths': ts_files
        }
    
  # Read all TypeScript sources into a dictionary
  - label: Read All Sources
    type: code_job
    position: {x: 400, y: 200}
    props:
      language: python
      code: |
        import os
        
        file_paths = inputs.get('default', {}).get('file_paths', [])
        sources = {}
        for file_path in file_paths:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Use file path as key for tracking
                    sources[file_path] = content
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                continue
        
        print(f"Successfully read {len(sources)} TypeScript files")
        result = {'sources':sources}
        
  # Parse all TypeScript sources in a single batch operation
  - label: Batch Parse TypeScript
    type: typescript_ast
    position: {x: 600, y: 200}
    props:
      batch: true
      batchInputKey: sources
      includeJSDoc: true
      parseMode: module
      outputFormat: for_codegen
      extractPatterns: ["interface", "type", "enum", "const"]
      
  # Save parsed results to cache files
  - label: Save Cache Files
    type: code_job
    position: {x: 800, y: 200}
    props:
      language: python
      code: |
        import os
        import json
        
        # Get batch results
        batch_results = inputs.get('default', {})
        if not isinstance(batch_results, dict):
            print("Warning: No batch results to cache")
            result = {'cached_count': 0}
        else:
            base_dir = os.environ.get('DIPEO_BASE_DIR', '/home/soryhyun/DiPeO')
            models_dir = os.path.join(base_dir, 'dipeo/models/src')
            cached_count = 0
            for file_path, parse_result in batch_results.items():
                # Get relative path from models_dir
                if file_path.startswith(models_dir):
                    relative_path = os.path.relpath(file_path, models_dir)
                else:
                    # Fallback to basename if not in expected location
                    relative_path = os.path.basename(file_path)
                
                # Create cache path preserving directory structure
                cache_path = os.path.join(base_dir, f'temp/{relative_path}.json')
                cache_dir = os.path.dirname(cache_path)
                
                # Ensure cache directory exists
                if cache_dir and cache_dir != 'temp':
                    os.makedirs(cache_dir, exist_ok=True)
                
                # Save the parsed result to cache
                try:
                    with open(cache_path, 'w', encoding='utf-8') as f:
                        json.dump(parse_result['ast'], f, indent=2)
                    cached_count += 1
                except Exception as e:
                    print(f"Warning: Failed to cache {file_path}: {e}")
            
            print(f"Successfully cached {cached_count} parsed TypeScript files")
            result = {'cached_count': cached_count}
      
  # End
  - label: End
    type: endpoint
    position: {x: 1000, y: 200}
    props:
      save_to_file: false
      
connections:
  - {from: Start, to: Gather TypeScript Files}
  - {from: Gather TypeScript Files, to: Read All Sources, content_type: object}
  - {from: Read All Sources, to: Batch Parse TypeScript, content_type: object}
  - {from: Batch Parse TypeScript, to: Save Cache Files, content_type: object}
  - {from: Save Cache Files, to: End}