
---

# A. “architecture.md” – Sections That Should Be Revised or Clarified

# B. Current Code-Base – Critical Mismatches / Technical Issues Discovered While Comparing the Refactor With the Document

---

## A. Required / Recommended Edits to `architecture.md`

1. **Package Names & Paths**

   * **Document says:**

     * `packages/python/dipeo_application/`, `dipeo_infra/`, `dipeo_shared/`, etc.
   * **Reality:**

     * `packages/python/dipeo_usecases/` (application layer)
     * `packages/python/dipeo_services/` (infrastructure adapters)
     * `packages/python/dipeo_core/` (shared protocols + base)
     * `apps/server/src/dipeo_server/domains/**` (domain logic)
   * ***Action:*** Rename the paths in the doc or, preferably, rename the code to match the doc – but the two must be consistent.

2. **Domain Layer Location**
   The document locates the domain in `packages/python/dipeo_domain/`, but the bulk of domain logic (services, validators, events) now lives under `apps/server/src/dipeo_server/domains/`.

   * **Either:**

     * Move the domain packages out of `apps/server` into the shared `packages/python` folder, **or**
     * Change the diagram so the "Domain Layer" sits under `dipeo_server/domains`.

3. **Dependency Rule Statement**

   > "Infrastructure → Application → Domain (inward only)."

   * In code, many "domain" classes import infrastructure types (`StateStore`, `MessageRouter`, Notion adapter, etc.).
   * *Clarify in the doc* that the DI container is the only place allowed to wire outward dependencies, and the domain itself must depend solely on **ports**.
   * (See concrete violations below.)

4. **Code-Generation "Single Source of Truth"**
   The doc states TypeScript models generate *all* downstream representations.

   * Python domain models (`packages/python/dipeo_domain/models.py`) and diagram models (`dipeo_diagram/models.py`) are hand-written and already diverging from `packages/domain-models/src/*.ts`.
   * *Amend the doc* to explain current coverage (e.g., "only GraphQL SDL is generated today; Python models are still manual") or finish the pipeline.

5. **Node-Handler Section**
   Good overall, but the registry in code (`dipeo_usecases/handlers/registry.py`) additionally injects **services** according to `node_type`. State this explicitly or simplify the example so it matches the real implementation.

6. **Build Artefacts / *.egg-info***
   The repo currently commits `build/**`, `dist/**`, and `*.egg-info/`.

   * Add a short "Generated artefacts are excluded from VCS" note (and a `.gitignore` entry) to avoid polluting history.

---

## B. Critical Mismatches & Technical Issues in the Refactored Code

1. **Layer Violations (Most Urgent)**

   * a. Domain-service classes import infrastructure implementations directly.

     * *Example:*
       `domains/execution/services/server_execution_service.py` imports
       `dipeo_server.infra.messaging.MessageRouter` and `infra.persistence.StateStore`.
       *This breaks the dependency rule and hampers testability.*

       * **Solution:** Introduce ports (protocols) for messaging & state store, inject them via the DI container, and make the domain depend on those protocols only.
   * b. `ServiceRegistry` lives in the domain folder but depends on `dipeo_services` (infra).

     * *Same fix:* Move either the registry out of the domain or flip its dependencies to protocols.

2. **Duplicate / Diverging Domain Models**

   * `packages/python/dipeo_domain/models.py`
   * `packages/python/dipeo_diagram/models.py`
   * `apps/server/domains/diagram/...`
   * They model the same concepts but are not kept in sync.
     *Pick one authoritative module and delete or re-export the others.*

3. **Mis-named “infra” vs “services” Packages**

   * `packages/python/dipeo_services/` actually contains infrastructure adapters (LLM, Notion…).
   * *Rename to `dipeo_infra` (or update the document) so newcomers understand the intent.*

4. **DI Container Pulls Server-Specific Modules**

   * `dipeo_container.container.Container` resides in a shared package yet imports from `dipeo_server`.
   * That means the "shared" package cannot be reused in CLI or any future micro-service without the full server tree in PYTHONPATH.
   * *Move the container to `apps/server` or split it into an abstract "core container" (shared protocols) and a "server container" that adds adapters.*

5. **Build Artefacts in Repository**

   * `build/` directories and compiled wheels are checked in for every package (`dipeo_core/build/**`, `dipeo_diagram/build/**`, ...).
   * *They bloat the repo and frequently cause stale-code bugs. Remove them and add to `.gitignore`.*

6. **Eggs and Old-Style Packaging**

   * All `*.egg-info` directories are also committed. These are generated by `build`, not source code.
   * *Remove and ignore.*

7. **`dipeo_usecases.handlers.*` Service Mapping**

   * The giant `service_map` dictionary inside `ServiceRegistry.get_handler_services` creates a hard dependency on string literals scattered all over the project.
   * *Consider:*

     * Exposing required services via handler class attributes (self-describing), or
     * Declaring them in the node-type metadata so you don’t need to keep the map in sync.

8. **Tests & Pre-Commit**

   * `architecture.md` promises "≥70% unit test coverage".
   * The repo currently has very few tests outside `apps/cli/tests`.
   * *Add tests for the new domain ports and use cases, then wire `pytest` into pre-commit.*

9. **Naming / Duplication in `dipeo_core`**

   * `dipeo_core/base/protocols.py` defines thirteen protocols – good – but the same interfaces are re-stated in several service modules.
   * *Import the protocols instead of redefining method signatures to avoid drift.*

10. **Unused Code Generation Config**

    * `codegen.yml` exists in multiple locations (`apps/cli`, root) but CI scripts do not run them.
    * *Ensure they are run in the build pipeline or delete stale configs.*

---

## Quick Win Checklist

1. Delete `build/**`, `dist/**`, `*.egg-info/**` and update `.gitignore`.
2. Introduce ports for `StateStore` & `MessageRouter`; make domain depend on them.
3. Pick one canonical Python domain model package; remove duplicates.
4. Decide on naming:

   * keep the doc and rename code (`dipeo_usecases` → `dipeo_application`, `dipeo_services` → `dipeo_infra`), or
   * keep the code and update the doc – but align them.
5. Move or split the DI container so shared packages do not import server-only code.

---

