/**
 * Generated Zod schemas from TypeScript definitions.
 * DO NOT EDIT - This file is automatically generated.
 */

import { z } from 'zod';

// Type aliases as Zod schemas
{% for model in zod_data.models %}
{% if model.type == "type_alias" %}
export const {{ model.name }}Schema = {{ model.definition|toZodSchema }};
export type {{ model.name }} = z.infer<typeof {{ model.name }}Schema>;
{% endif %}
{% endfor %}

// Enum schemas
{% for model in zod_data.models %}
{% if model.type == "enum" %}
export const {{ model.name }}Schema = z.enum([
  {% for enum_value in model.enum_values %}
  "{{ enum_value[1] }}",
  {% endfor %}
]);
export type {{ model.name }} = z.infer<typeof {{ model.name }}Schema>;

{% endif %}
{% endfor %}

// Interface/Class schemas
{% for model in zod_data.models %}
{% if model.type == "class" %}
export const {{ model.name }}Schema = z.object({
  {% for field in model.fields.values() %}
  {{ field.name }}: {{ field.type|toZodType }},
  {% endfor %}
}){% if model.strict %}.strict(){% endif %};

export type {{ model.name }} = z.infer<typeof {{ model.name }}Schema>;

{% endif %}
{% endfor %}

// Union schemas for node types
export const NodeDataSchema = z.discriminatedUnion('type', [
  {% for model in zod_data.models %}
  {% if model.name|endsWith("NodeData") %}
  {{ model.name }}Schema,
  {% endif %}
  {% endfor %}
]);

export type NodeData = z.infer<typeof NodeDataSchema>;

// Helper functions
export function validateNodeData(data: unknown): NodeData {
  return NodeDataSchema.parse(data);
}

export function isValidNodeData(data: unknown): data is NodeData {
  return NodeDataSchema.safeParse(data).success;
}

// Schema registry for dynamic validation
export const SchemaRegistry = {
  {% for model in zod_data.models %}
  {{ model.name }}: {{ model.name }}Schema,
  {% endfor %}
} as const;

// Export all schemas
export {
  {% for model in zod_data.models %}
  {{ model.name }}Schema,
  {% endfor %}
};