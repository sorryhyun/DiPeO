"""
Generated conversion functions for TypeScript <-> Python transformations.
DO NOT EDIT - This file is automatically generated.
"""

from typing import Any, Dict, List, Optional, Union, Type, TypeVar
from enum import Enum
import json

# Import generated models
from .__generated_models__ import *

T = TypeVar('T')


# Enum conversion helpers
{{#each conversion_data.enums}}
def {{snakeCase this.name}}_to_string(value: {{this.name}}) -> str:
    """Convert {{this.name}} enum to string."""
    return value.value if isinstance(value, {{this.name}}) else str(value)


def string_to_{{snakeCase this.name}}(value: str) -> {{this.name}}:
    """Convert string to {{this.name}} enum."""
    try:
        return {{this.name}}(value)
    except ValueError:
        raise ValueError(f"Invalid {{this.name}} value: {value}")

{{/each}}

# Model conversion functions
{{#each conversion_data.models}}
def {{snakeCase this.name}}_to_dict(model: {{this.name}}) -> Dict[str, Any]:
    """Convert {{this.name}} to dictionary."""
    if not isinstance(model, {{this.name}}):
        raise TypeError(f"Expected {{this.name}}, got {type(model)}")
    
    data = model.dict(exclude_none=True)
    
    # Handle enum conversions
    {{#each this.fields}}
    {{#if (isEnum this.type)}}
    if "{{this.name}}" in data and data["{{this.name}}"] is not None:
        data["{{this.name}}"] = {{snakeCase this.type}}_to_string(data["{{this.name}}"])
    {{/if}}
    {{/each}}
    
    return data


def dict_to_{{snakeCase this.name}}(data: Dict[str, Any]) -> {{this.name}}:
    """Convert dictionary to {{this.name}}."""
    if not isinstance(data, dict):
        raise TypeError(f"Expected dict, got {type(data)}")
    
    # Create a copy to avoid modifying the original
    data_copy = data.copy()
    
    # Handle enum conversions
    {{#each this.fields}}
    {{#if (isEnum this.type)}}
    if "{{this.name}}" in data_copy and data_copy["{{this.name}}"] is not None:
        data_copy["{{this.name}}"] = string_to_{{snakeCase this.type}}(data_copy["{{this.name}}"])
    {{/if}}
    {{/each}}
    
    return {{this.name}}(**data_copy)

{{/each}}

# Generic conversion helpers
def model_to_dict(model: BaseModel) -> Dict[str, Any]:
    """Convert any Pydantic model to dictionary."""
    model_type = type(model).__name__
    converter_name = f"{model_type[0].lower()}{model_type[1:]}_to_dict"
    
    # Try to find specific converter
    converter = globals().get(converter_name)
    if converter:
        return converter(model)
    
    # Fallback to generic conversion
    return model.dict(exclude_none=True)


def dict_to_model(data: Dict[str, Any], model_type: Type[T]) -> T:
    """Convert dictionary to specified model type."""
    type_name = model_type.__name__
    converter_name = f"dict_to_{type_name[0].lower()}{type_name[1:]}"
    
    # Try to find specific converter
    converter = globals().get(converter_name)
    if converter:
        return converter(data)
    
    # Fallback to direct instantiation
    return model_type(**data)


# JSON conversion helpers
def model_to_json(model: BaseModel, **kwargs) -> str:
    """Convert model to JSON string."""
    return json.dumps(model_to_dict(model), **kwargs)


def json_to_model(json_str: str, model_type: Type[T]) -> T:
    """Convert JSON string to model."""
    data = json.loads(json_str)
    return dict_to_model(data, model_type)


# Batch conversion helpers
def models_to_dicts(models: List[BaseModel]) -> List[Dict[str, Any]]:
    """Convert list of models to list of dictionaries."""
    return [model_to_dict(model) for model in models]


def dicts_to_models(data_list: List[Dict[str, Any]], model_type: Type[T]) -> List[T]:
    """Convert list of dictionaries to list of models."""
    return [dict_to_model(data, model_type) for data in data_list]


# Node-specific conversion helpers
NODE_TYPE_MAP = {
    {{#each conversion_data.models}}
    {{#if (endsWith this.name "Node")}}
    "{{toNodeType this.name}}": {{this.name}},
    {{/if}}
    {{/each}}
}


def create_node_from_dict(node_type: str, data: Dict[str, Any]) -> BaseModel:
    """Create a node model from node type and data."""
    model_class = NODE_TYPE_MAP.get(node_type)
    if not model_class:
        raise ValueError(f"Unknown node type: {node_type}")
    
    return dict_to_model(data, model_class)


def node_to_dict(node: BaseModel) -> Dict[str, Any]:
    """Convert any node model to dictionary with type information."""
    data = model_to_dict(node)
    
    # Add node type if not present
    if "type" not in data:
        # Infer node type from class name
        class_name = type(node).__name__
        if class_name.endswith("Node"):
            node_type = class_name[:-4].lower()
            # Convert camelCase to snake_case
            import re
            node_type = re.sub(r'(?<!^)(?=[A-Z])', '_', node_type).lower()
            data["type"] = node_type
    
    return data


# Export all conversion functions
__all__ = [
    # Enum converters
    {{#each conversion_data.enums}}
    "{{snakeCase this.name}}_to_string",
    "string_to_{{snakeCase this.name}}",
    {{/each}}
    # Model converters
    {{#each conversion_data.models}}
    "{{snakeCase this.name}}_to_dict",
    "dict_to_{{snakeCase this.name}}",
    {{/each}}
    # Generic helpers
    "model_to_dict",
    "dict_to_model",
    "model_to_json",
    "json_to_model",
    "models_to_dicts",
    "dicts_to_models",
    # Node helpers
    "create_node_from_dict",
    "node_to_dict",
    "NODE_TYPE_MAP",
]