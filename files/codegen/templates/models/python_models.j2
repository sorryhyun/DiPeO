#!/usr/bin/env python3
# __generated__ by DiPeO
"""
Auto-generated Python models from TypeScript domain models.
DO NOT EDIT THIS FILE DIRECTLY - Modify TypeScript sources and regenerate.
"""
from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Literal, NewType, Optional, Union
from pydantic import BaseModel, ConfigDict, Field

# Import all enums from the separate enums module
from .enums import (
    NodeType, HandleDirection, HandleLabel, DataType,
    MemoryView, DiagramFormat, DBBlockSubType, ContentType, SupportedLanguage,
    HttpMethod, HookType, HookTriggerMode, ExecutionStatus, NodeExecutionStatus,
    EventType, LLMService, APIServiceType, NotionOperation, ToolType
)

# ============ Type Aliases ============
{% for alias in type_aliases %}
{{ alias.name }} = {{ alias.type }}
{% endfor %}

# ============ Branded IDs ============
{% for brand in branded_ids %}
{{ brand }} = NewType('{{ brand }}', str)
{% endfor %}


# ============ Models ============
{% for model in models %}
class {{ model.name }}({{ model.extends or 'BaseModel' }}):
    """{{ model.description or model.name + ' model' }}"""
    model_config = ConfigDict(extra='{{ "allow" if allow_extra else "forbid" }}', populate_by_name=True)
    
    {% if model.fields %}
    {% for field in model.fields %}
    {{ field.name }}: {{ field.type }}{% if field.optional %} = Field(default=None){% endif %}
    {% endfor %}
    {% else %}
    pass
    {% endif %}

{% endfor %}

# ============ Helper Functions ============
def parse_handle_id(handle_id: str) -> tuple[NodeID, str, str]:
    """Parse a handle ID into its components."""
    parts = handle_id.split('_')
    if len(parts) < 3:
        raise ValueError(f"Invalid handle ID format: {handle_id}")
    
    node_id = parts[0]
    direction = parts[-1]
    label = '_'.join(parts[1:-1])
    
    return NodeID(node_id), label, direction

def create_handle_id(node_id: NodeID, label: str, direction: str) -> HandleID:
    """Create a handle ID from components."""
    return HandleID(f"{node_id}_{label}_{direction}")

# ============ Type Guards ============
{% for model in models %}
{% if model.name.endswith('Node') %}
def is_{{ model.name|lower }}(node: Any) -> bool:
    """Check if a node is a {{ model.name }}."""
    return hasattr(node, 'type') and node.type == NodeType.{{ model.name|replace('Node', '')|lower }}

{% endif %}
{% endfor %}

# ============ Deferred Type Aliases (Forward References) ============
{% if deferred_aliases %}
{% for alias in deferred_aliases %}
{{ alias.name }} = {{ alias.type }}
{% endfor %}
{% endif %}

# ============ Constants ============
VALID_NODE_TYPES = [{{ enums|selectattr('name', 'equalto', 'NodeType')|map(attribute='members')|first|map(attribute='value')|map('quote')|join(', ') if enums|selectattr('name', 'equalto', 'NodeType')|list else '' }}]
VALID_HANDLE_DIRECTIONS = ['input', 'output']