#!/usr/bin/env python3
# __generated__ by DiPeO
"""
Auto-generated Python models from TypeScript domain models.
DO NOT EDIT THIS FILE DIRECTLY - Modify TypeScript sources and regenerate.
"""
from __future__ import annotations

from enum import *
from typing import *
from pydantic import *

from .enums import *
from .integrations import *

{# ============ Branded IDs ============ #}
{%- set base_branded_ids = ['NodeID', 'ArrowID', 'HandleID', 'PersonID', 'ApiKeyID', 'DiagramID', 'ExecutionID', 'HookID', 'TaskID'] -%}
{%- set all_branded_ids = (model_data.branded_types + base_branded_ids) | unique | sort -%}
{%- for brand in all_branded_ids %}
{{ brand }} = NewType('{{ brand }}', str)
{%- endfor %}

{# ============ Type Aliases ============ #}
{%- set processed_aliases = [] -%}
{%- set deferred_aliases = [] -%}
{%- set interface_names = model_data.interfaces | map(attribute='name') | list -%}
{%- for alias in model_data.types -%}
  {%- set alias_name = alias.name -%}
  {%- set alias_type_raw = alias.type -%}
  {%- set py_type = alias_type_raw | ts_to_python(alias_name) -%}
  {%- if py_type != alias_name and alias_name not in all_branded_ids -%}
    {%- if py_type in interface_names -%}
      {%- set _ = deferred_aliases.append({'name': alias_name, 'type': py_type}) -%}
    {%- else -%}
      {%- set _ = processed_aliases.append({'name': alias_name, 'type': py_type}) -%}
    {%- endif -%}
  {%- endif -%}
{%- endfor -%}
{%- if processed_aliases %}

{% for alias in processed_aliases %}
{{ alias.name }} = {{ alias.type }}
{%- endfor %}
{%- endif %}

{# ============ Models ============ #}
{%- for interface in model_data.interfaces %}
{%- set base_class = interface.extends[0] if interface.extends else 'BaseModel' -%}
{%- set model_name = interface.name %}

class {{ model_name }}({{ base_class }}):
    """{{ interface.description or model_name + ' model' }}"""
    model_config = ConfigDict(extra='{{ "allow" if model_data.config.allow_extra else "forbid" }}', populate_by_name=True)
    {%- if interface.properties %}
    {% for prop in interface.properties -%}
    {%- set ts_type = prop.type -%}
    {%- set field_name = prop.name -%}
    {%- set is_optional = prop.optional or (ts_type | is_optional_ts) -%}
    {%- set py_type = ts_type | ts_to_python(field_name, {'model': model_name, 'all_fields': interface.properties}) %}
    {%- if is_optional %}
    {%- if not py_type.startswith('Optional[') %}
    {{ field_name }}: Optional[{{ py_type }}] = Field(default=None{% if prop.description %}, description="{{ prop.description }}"{% endif %})
    {%- else %}
    {{ field_name }}: {{ py_type }} = Field(default=None{% if prop.description %}, description="{{ prop.description }}"{% endif %})
    {%- endif -%}
    {%- else %}
    {{ field_name }}: {{ py_type }}{% if prop.description %} = Field(description="{{ prop.description }}"){% endif %}
    {%- endif -%}
    {%- endfor -%}
    {%- else %}
    pass
    {%- endif %}
{% endfor -%}

{# ============ Deferred Type Aliases (Forward References) ============ #}
{%- if deferred_aliases %}

# Type aliases that reference models
{%- for alias in deferred_aliases %}
{{ alias.name }} = {{ alias.type }}
{%- endfor %}
{%- endif %}

{# ============ Enums ============ #}
{%- for enum in model_data.enums -%}
{%- if enum.name not in ['NodeType', 'HandleDirection', 'HandleLabel', 'DataType', 'MemoryView', 'DiagramFormat', 'DBBlockSubType', 'ContentType', 'SupportedLanguage', 'HttpMethod', 'HookType', 'HookTriggerMode', 'ExecutionStatus', 'NodeExecutionStatus', 'EventType', 'LLMService', 'APIServiceType', 'ToolType'] %}

class {{ enum.name }}(str, Enum):
    """{{ enum.description or enum.name + ' enumeration' }}"""
    {%- for member in enum.members %}
    {{ member.name | snake_case | upper }} = "{{ member.value }}"
    {%- endfor %}
{%- endif -%}
{%- endfor %}

{# ============ Helper Functions ============ #}
def parse_handle_id(handle_id: str) -> tuple[NodeID, str, str]:
    """Parse a handle ID into its components."""
    parts = handle_id.split('_')
    if len(parts) < 3:
        raise ValueError(f"Invalid handle ID format: {handle_id}")
    
    node_id = parts[0]
    direction = parts[-1]
    label = '_'.join(parts[1:-1])
    
    return NodeID(node_id), label, direction

def create_handle_id(node_id: NodeID, label: str, direction: str) -> HandleID:
    """Create a handle ID from components."""
    return HandleID(f"{node_id}_{label}_{direction}")

{# ============ Type Guards ============ #}
{%- if model_data.config.generate_type_guards %}
# Type guard functions
{%- for interface in model_data.interfaces %}
def is_{{ interface.name | snake_case }}(obj: Any) -> bool:
    """Check if object is a {{ interface.name }}."""
    return isinstance(obj, {{ interface.name }})
{%- endfor -%}
{%- endif %}

{# ============ Constants ============ #}
{%- if model_data.constants %}
# Constants from TypeScript
{%- for const in model_data.constants %}
{{ const.name }} = {{ const.value | tojson }}
{%- endfor -%}
{%- endif %}