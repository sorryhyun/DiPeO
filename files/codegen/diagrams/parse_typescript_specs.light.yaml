# TypeScript Node Specifications Parser
# Parses TypeScript node specification files and extracts specification data

version: light

nodes:
  - label: Start
    type: start
    position: {x: 50, y: 200}
    
  # Parse input to get node type
  - label: Parse Input
    type: code_job
    position: {x: 150, y: 200}
    props:
      language: python
      code: |
        # Handle input from CLI or sub_diagram
        # Support both node_type and node_spec_path formats
        if "node_type" in default:
            node_type = default["node_type"]
        elif "node_spec_path" in default:
            node_type = default["node_spec_path"]
        elif "default" in default and isinstance(default["default"], dict):
            if "node_type" in default["default"]:
                node_type = default["default"]["node_type"]
            elif "node_spec_path" in default["default"]:
                node_type = default["default"]["node_spec_path"]
            else:
                raise ValueError(f"node_type or node_spec_path not found in nested input: {default}")
        else:
            raise ValueError(f"node_type or node_spec_path not found in input: {default}")
        
        # Convert underscore to hyphen for filename
        node_type_filename = node_type.replace('_', '-')
        
        result = {"node_type": node_type, "node_type_filename": node_type_filename}
  
  # Load the TypeScript specification file
  - label: Load TypeScript Spec
    type: db
    position: {x: 300, y: 200}
    props:
      operation: read
      sub_type: file
      source_details: dipeo/models/src/node-specs/{data.node_type_filename}.spec.ts
      
  # Parse TypeScript to extract the specification
  - label: Parse TypeScript AST
    type: typescript_ast
    position: {x: 500, y: 200}
    props:
      extractPatterns: ["const", "export"]
      includeJSDoc: true
      parseMode: module
      
  # Extract specification from AST
  - label: Extract Specification
    type: code_job
    position: {x: 700, y: 200}
    props:
      language: python
      code: |
        # Extract the actual node_type string from the dict
        if isinstance(node_type, dict):
            actual_node_type = node_type.get('node_type', 'unknown')
        else:
            actual_node_type = node_type
        
        # Import the parser function
        from files.codegen.code.shared.typescript_spec_parser import main
        
        # For file-based functions, we need to pass inputs as a dict
        inputs_dict = {
            'ast_data': ast_data,
            'node_type': actual_node_type
        }
        result_dict = main(inputs_dict)
        
        # Extract the spec_data from the result
        spec_data = result_dict.get('spec_data', {})
        result = spec_data
        
  # Convert to JSON for compatibility with existing generators
  - label: Convert to JSON
    type: code_job
    position: {x: 900, y: 200}
    props:
      language: python
      code: |
        import json
        # Get spec_data from the Extract Specification node
        # In code_job nodes, inputs come as direct variables
        # Convert to JSON string for compatibility with existing generators
        result = json.dumps(spec_data, indent=2)
        
  # Return the result
  - label: End
    type: endpoint
    position: {x: 1100, y: 200}
    props:
      save_to_file: false
        
connections:
  - from: Start
    to: Parse Input
    
  - from: Parse Input
    to: Load TypeScript Spec
    label: data
    content_type: object
    
  - from: Load TypeScript Spec
    to: Parse TypeScript AST
    label: source
    
  - from: Parse TypeScript AST
    to: Extract Specification
    label: ast_data
    
  - from: Parse Input
    to: Extract Specification
    label: node_type
    
  - from: Extract Specification
    to: Convert to JSON
    label: spec_data
    
  - from: Convert to JSON
    to: End