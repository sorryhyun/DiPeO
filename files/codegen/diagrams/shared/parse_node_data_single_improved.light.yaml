# Parse Single Node Data File (Improved with typescript_ast)
# Uses typescript_ast node directly instead of code_job with subprocess

version: light

nodes:
  - label: Start
    type: start
    position: {x: 50, y: 200}
    
  # Parse input to get node type and file path
  - label: Parse Input
    type: code_job
    position: {x: 150, y: 200}
    props:
      language: python
      code: |
        # Extract node_type from inputs (handles both dict and string formats)
        node_type = inputs.get('default', {}).get('node_type') if isinstance(inputs.get('default'), dict) else inputs.get('node_type', inputs.get('default'))
        
        if not node_type:
            raise ValueError(f"node_type not provided in input. Got: {inputs}")
        
        # Create file name with hyphens (e.g., "person_job" -> "person-job.data.ts")
        file_name = node_type.replace('_', '-') + '.data.ts'
        
        result = {
            "node_type": node_type,
            "file_name": file_name
        }
  
  # Load the TypeScript source file
  - label: Load TS Source
    type: db
    position: {x: 350, y: 200}
    props:
      operation: read
      sub_type: file
      source_details: dipeo/models/src/node-data/{data.file_name}
      
  # Parse TypeScript using native typescript_ast node
  - label: Parse TypeScript AST
    type: typescript_ast
    position: {x: 550, y: 200}
    props:
      extractPatterns: ["interface", "type", "enum", "const"]
      includeJSDoc: true
      parseMode: module
      outputFormat: for_codegen
        
  # Format result for cache and output
  - label: Format Data
    type: code_job
    position: {x: 750, y: 200}
    props:
      language: python
      code: |
        from pathlib import Path
        
        # Get the AST data and node info from inputs
        ast_data = inputs.get('ast_data', {})
        node_info = inputs.get('node_info', {})
        node_type = node_info.get('node_type', 'unknown')
        
        # Extract main interface (first one or matching name)
        interfaces = ast_data.get('interfaces', [])
        main_interface = None
        if interfaces:
            # Try to find interface matching the node type
            node_type_clean = node_type.replace('_', '')
            for interface in interfaces:
                if interface.get('name', '').lower().replace('nodedata', '') == node_type_clean:
                    main_interface = interface
                    break
            # Fallback to first interface if no match
            if not main_interface:
                main_interface = interfaces[0]
        
        # Ensure .temp directory exists
        Path('.temp').mkdir(exist_ok=True)
        
        # Prepare cache data
        cache_filename = node_type.replace('_', '-') + '_data'
        cache_data = {
            'node_type': node_type,
            'ast': ast_data,
            'main_interface': main_interface
        }
        
        # Prepare output
        result = {
            'content': cache_data,
            'cache_path': f'.temp/{cache_filename}_ast.json',
            'parsed_node': {
                'node_type': node_type,
                'interface': main_interface,
                'all_interfaces': interfaces,
                'types': ast_data.get('types', []),
                'enums': ast_data.get('enums', []),
                'total_definitions': len(interfaces) + len(ast_data.get('types', [])) + len(ast_data.get('enums', []))
            }
        }
  
  # Save cache to file using DB node
  - label: Save Cache
    type: db
    position: {x: 900, y: 200}
    props:
      operation: write
      sub_type: file
      file: "{cache_data.cache_path}"
      serialize_json: true
      
  # Return the parsed interface data  
  - label: End
    type: endpoint
    position: {x: 1100, y: 200}
    props:
      save_to_file: false
      
connections:
  - from: Start
    to: Parse Input
    
  - from: Parse Input
    to: Load TS Source
    label: data
    
  - from: Load TS Source
    to: Parse TypeScript AST
    label: source
    
  - from: Parse TypeScript AST
    to: Format Data
    label: ast_data
    
  - from: Parse Input
    to: Format Data
    label: node_info
    
  - from: Format Data
    to: Save Cache
    label: cache_data
    
  - from: Format Data
    to: End
    label: parsed_node
    
  - from: Save Cache
    to: End