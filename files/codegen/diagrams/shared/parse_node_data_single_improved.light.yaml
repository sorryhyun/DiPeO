# Parse Single Node Data File (Improved with typescript_ast)
# Uses typescript_ast node directly instead of code_job with subprocess

version: light

nodes:
  - label: Start
    type: start
    position: {x: 50, y: 200}
    
  # Parse input to get node type and file path
  - label: Parse Input
    type: code_job
    position: {x: 150, y: 200}
    props:
      language: python
      code: |
        def main(inputs):
            """Parse input to extract node type and file path."""
            # Check if we have a default value in inputs (common case)
            if 'default' in inputs:
                default_data = inputs['default']
                if isinstance(default_data, dict):
                    node_type = default_data.get('node_type')
                    file_path = default_data.get('file_path')
                else:
                    # If default is a string, use it as node_type
                    node_type = default_data
                    file_path = None
            else:
                # Direct inputs
                node_type = inputs.get('node_type')
                file_path = inputs.get('file_path')
            
            if not node_type:
                raise ValueError(f"node_type not provided in input. Got: {inputs}")
            
            # Convert underscore to hyphen for cache filename
            cache_filename = node_type.replace('_', '-') + '_data'
            
            # Also create the file name with hyphens
            file_name = node_type.replace('_', '-') + '.data.ts'
            
            return {
                "data": {
                    "node_type": node_type,
                    "file_name": file_name,
                    "file_path": file_path,
                    "cache_filename": cache_filename
                },
                "node_info": {
                    "node_type": node_type,
                    "cache_filename": cache_filename
                }
            }
  
  # Load the TypeScript source file
  - label: Load TS Source
    type: db
    position: {x: 350, y: 200}
    props:
      operation: read
      sub_type: file
      source_details: dipeo/models/src/node-data/{data.file_name}
      
  # Parse TypeScript using native typescript_ast node
  - label: Parse TypeScript AST
    type: typescript_ast
    position: {x: 550, y: 200}
    props:
      extractPatterns: ["interface", "type", "enum", "const"]
      includeJSDoc: true
      parseMode: module
      outputFormat: for_codegen
        
  # Format result and save cache
  - label: Format and Save
    type: code_job
    position: {x: 750, y: 200}
    props:
      language: python
      code: |
        def main(inputs):
            """Format the AST result for saving and output."""
            # Debug what we're receiving
            print(f"[Format and Save] Received inputs keys: {inputs.keys()}")
            print(f"[Format and Save] ast_data type: {type(inputs.get('ast_data'))}")
            
            ast_data = inputs.get('ast_data')
            # If ast_data is a string (JSON), parse it
            if isinstance(ast_data, str):
                import json
                try:
                    ast_data = json.loads(ast_data)
                except:
                    ast_data = {}
            elif not ast_data:
                ast_data = {}
                
            node_info = inputs.get('node_info', {})
            
            node_type = node_info.get('node_type', 'unknown')
            cache_filename = node_info.get('cache_filename', node_type)
            
            # Extract main interface
            interfaces = ast_data.get('interfaces', [])
            main_interface = None
            if interfaces:
                # Find the main interface
                for interface in interfaces:
                    if interface.get('name', '').lower().replace('nodedata', '') == node_type.replace('_', ''):
                        main_interface = interface
                        break
                if not main_interface and interfaces:
                    main_interface = interfaces[0]
            
            # Prepare data for saving
            cache_data = {
                'node_type': node_type,
                'ast': ast_data,
                'main_interface': main_interface
            }
            
            import json
            import os
            from pathlib import Path
            
            # Ensure .temp directory exists
            Path('.temp').mkdir(exist_ok=True)
            
            # Save the cache file
            cache_path = f'.temp/{cache_filename}_ast.json'
            with open(cache_path, 'w') as f:
                json.dump(cache_data, f, indent=2)
            
            print(f"[Format and Save] Saved AST cache to {cache_path}")
            
            return {
                'parsed_node': {
                    'node_type': node_type,
                    'interface': main_interface,
                    'all_interfaces': interfaces,
                    'types': ast_data.get('types', []),
                    'enums': ast_data.get('enums', []),
                    'total_definitions': ast_data.get('total_definitions', 0)
                }
            }
        
  # Return the parsed interface data  
  - label: End
    type: endpoint
    position: {x: 950, y: 200}
    props:
      save_to_file: false
      
connections:
  - from: Start
    to: Parse Input
    
  - from: Parse Input
    to: Load TS Source
    label: data
    content_type: object
    
  - from: Load TS Source
    to: Parse TypeScript AST
    label: source
    
  - from: Parse TypeScript AST
    to: Format and Save
    label: ast_data
    
  - from: Parse Input
    to: Format and Save
    label: node_info
    
  - from: Format and Save
    to: End
    label: parsed_node