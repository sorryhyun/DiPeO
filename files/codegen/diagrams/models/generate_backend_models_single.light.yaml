# Backend Single Node Generation from TypeScript - Simplified with template_job
# Generates Pydantic model and static node from TypeScript specifications

version: light

nodes:
  # Start node
  - label: Start
    type: start
    position: {x: 50, y: 100}

  # Parse input to handle both direct variables and nested inputs
  - label: Parse Input
    type: code_job
    position: {x: 50, y: 150}
    props:
      language: python
      code: |
        # Handle both direct input (from CLI) and nested input (from sub_diagram)
        if "node_spec_path" in default:
            # Direct case - pass through
            result = {"node_spec_path": default["node_spec_path"]}
        elif "default" in default and isinstance(default["default"], dict) and "node_spec_path" in default["default"]:
            # Nested case from sub_diagram
            result = {"node_spec_path": default["default"]["node_spec_path"]}
        else:
            raise ValueError(f"node_spec_path not found in input: {default}")
      
  # Extract node type from input
  - label: Extract Node Type
    type: code_job
    position: {x: 200, y: 200}
    props:
      language: python
      code: |
        # Extract node type from input
        # node_spec_path comes as a dict from Parse Input
        if isinstance(node_spec_path, dict):
            node_type = node_spec_path.get('node_spec_path', 'unknown')
        else:
            node_type = node_spec_path
            
        # Keep the node type with hyphens for file loading
        # Output just the string node type for typescript_spec_parser
        result = node_type
  
  # Load cached AST data for this node spec
  - label: Load Cached AST
    type: db
    position: {x: 350, y: 200}
    props:
      operation: read
      sub_type: file
      source_details: temp/specifications/nodes/{node_type}.spec.ts.json
      serialize_json: true
      
  # Load codegen mappings
  - label: Load Codegen Mappings
    type: db
    position: {x: 350, y: 100}
    props:
      operation: read
      sub_type: file
      source_details: temp/codegen/mappings.ts.json
      serialize_json: true
      
  # Extract mappings
  - label: Extract Mappings
    type: code_job
    position: {x: 500, y: 100}
    props:
      language: python
      filePath: files/codegen/code/shared/extract_mappings.py
      functionName: main
      
  # Extract specification from AST
  - label: Extract Specification
    type: code_job
    position: {x: 500, y: 200}
    props:
      language: python
      filePath: files/codegen/code/shared/typescript_spec_parser.py
      functionName: main
      
  # Unwrap spec_data from nested structure
  - label: Unwrap Spec Data
    type: code_job
    position: {x: 600, y: 200}
    props:
      language: python
      code: |
        # The typescript_spec_parser returns {"spec_data": spec}, unwrap it
        if isinstance(spec_data, dict) and 'spec_data' in spec_data:
            result = spec_data['spec_data']
        else:
            result = spec_data

  # Extract node naming for file paths
  - label: Extract Node Naming
    type: code_job
    position: {x: 700, y: 200}
    props:
      language: python
      code: |
        # Extract node type from spec for use in file paths
        # When typescript_spec_parser returns {"spec_data": spec_data}, 
        # and it's passed with label "spec_data", we get the actual spec dict
        spec = inputs.get('spec_data', spec_data if 'spec_data' in locals() else {})
        
        # Ensure spec is a dict
        if not isinstance(spec, dict):
            raise ValueError(f"Expected dict, got {type(spec)}")
            
        # The spec will have node_type in underscore format (e.g., "api_job")
        # which is what we want for Python file names
        node_type = spec.get('nodeType', 'unknown')
        node_name = node_type.title().replace('_', '')
        
        result = {
            'node_type': node_type,
            'node_name': node_name
        }

  # Prepare context for templates
  - label: Prepare Template Context
    type: code_job
    position: {x: 700, y: 300}
    props:
      language: python
      code: |
        # Combine all data needed for templates
        # Keep node_naming as nested object for path interpolation
        context = {
            **spec_data,  # All spec fields (nodeType, displayName, fields, etc.)
            'mappings': mappings,  # Type mappings for python_type_with_context filter
            'node_naming': node_naming,  # Keep as nested object for {node_naming.node_type} interpolation
        }
        
        result = context

  # Generate backend code using template_job nodes
  - label: Generate Pydantic Model
    type: template_job
    position: {x: 900, y: 300}
    props:
      engine: jinja2
      template_path: files/codegen/templates/backend/pydantic_single_model.j2
      output_path: dipeo/diagram_generated_staged/models/{node_naming.node_type}_model.py

  - label: Generate Static Node
    type: template_job
    position: {x: 900, y: 400}
    props:
      engine: jinja2
      template_path: files/codegen/templates/backend/static_nodes.j2
      output_path: dipeo/diagram_generated_staged/nodes/{node_naming.node_type}_node.py

connections:
  # Parse input first
  - from: Start
    to: Parse Input
    
  # Load codegen mappings early (independent of node type)
  - from: Start
    to: Load Codegen Mappings
    
  # Extract node type
  - from: Parse Input
    to: Extract Node Type
    label: node_spec_path
    
  # Load the cached AST
  - from: Extract Node Type
    to: Load Cached AST
    label: node_type
    
  # Extract specification from AST
  - from: Load Cached AST
    to: Extract Specification
    label: ast_data
    
  # Pass node_type to Extract Specification
  - from: Extract Node Type
    to: Extract Specification
    label: node_type
    
  # Unwrap the spec data
  - from: Extract Specification
    to: Unwrap Spec Data
    label: spec_data
    
  # Pass unwrapped spec to extract node naming
  - from: Unwrap Spec Data
    to: Extract Node Naming
    label: spec_data
    
  # Pass mappings from Load Codegen Mappings to Extract Mappings
  - from: Load Codegen Mappings
    to: Extract Mappings
    
  # Prepare template context with all data
  - from: Unwrap Spec Data
    to: Prepare Template Context
    label: spec_data
  - from: Extract Mappings
    to: Prepare Template Context
    label: mappings
  - from: Extract Node Naming
    to: Prepare Template Context
    label: node_naming
  
  # Pass context to template_job nodes (no label = auto unwrap)
  - from: Prepare Template Context
    to: Generate Pydantic Model
  - from: Prepare Template Context
    to: Generate Static Node