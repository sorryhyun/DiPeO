"""Generate Python static node classes from extracted data."""

from datetime import datetime
from typing import Dict, List, Any


def generate_python_code(static_nodes_data: dict) -> str:
    """Generate Python code for static node classes"""
    node_classes = static_nodes_data.get('node_classes', [])
    now = static_nodes_data.get('now', datetime.now().isoformat())
    
    lines = []
    
    # Header
    lines.append('"""')
    lines.append('Auto-generated static node types from domain models.')
    lines.append('DO NOT EDIT THIS FILE DIRECTLY.')
    lines.append(f'Generated at: {now}')
    lines.append('Generated by: domain model static nodes generation')
    lines.append('"""')
    lines.append('')
    lines.append('from dataclasses import dataclass, field')
    lines.append('from typing import Dict, Any, Optional, List, Union, Literal')
    lines.append('')
    lines.append('from dipeo.diagram_generated.domain_models import (')
    lines.append('    Vec2, NodeID, PersonID, MemorySettings, ToolConfig')
    lines.append(')')
    lines.append('from dipeo.diagram_generated.enums import (')
    lines.append('    NodeType, HookTriggerMode, SupportedLanguage, HttpMethod,')
    lines.append('    DBBlockSubType, NotionOperation, HookType, DiagramFormat')
    lines.append(')')
    lines.append('')
    lines.append('')
    
    # Base class
    lines.append('@dataclass(frozen=True)')
    lines.append('class BaseExecutableNode:')
    lines.append('    """Base class for all executable node types."""')
    lines.append('    # Required fields only - no defaults in base class')
    lines.append('    id: NodeID')
    lines.append('    position: Vec2')
    lines.append('    ')
    lines.append('    def to_dict(self) -> Dict[str, Any]:')
    lines.append('        """Convert node to dictionary representation."""')
    lines.append('        result = {')
    lines.append('            "id": self.id,')
    lines.append('            "position": {"x": self.position.x, "y": self.position.y}')
    lines.append('        }')
    lines.append('        # Subclasses should extend this')
    lines.append('        return result')
    lines.append('')
    lines.append('')
    
    # Generate node classes
    for node_class in node_classes:
        lines.append('@dataclass(frozen=True)')
        lines.append(f'class {node_class["class_name"]}(BaseExecutableNode):')
        
        # When inheriting from a dataclass with default values,
        # all fields must have defaults in Python dataclasses.
        # But we can work around this by putting all fields without defaults first
        
        # First, add all required fields (those without defaults)
        required_fields = [f for f in node_class['fields'] if not f.get('has_default')]
        for field in required_fields:
            py_type = field["py_type"]
            field_def = f'    {field["py_name"]}: {py_type} = field()'
            lines.append(field_def)
        
        # Then add the type field with its default
        lines.append(f'    type: NodeType = field(default=NodeType.{node_class["node_type"].upper()}, init=False)')
        
        # Add base optional fields
        lines.append('    label: str = ""')
        lines.append('    flipped: bool = False')
        lines.append('    metadata: Optional[Dict[str, Any]] = None')
        
        # Finally, add node-specific optional fields (those with defaults)
        optional_fields = [f for f in node_class['fields'] if f.get('has_default')]
        for field in optional_fields:
            py_type = field["py_type"]
            
            # Check if field has None as default and needs Optional wrapping
            if field["default_value"] == "None":
                # Check if the type already has Optional
                if not py_type.startswith('Optional['):
                    py_type = f'Optional[{py_type}]'
            
            field_def = f'    {field["py_name"]}: {py_type} = {field["default_value"]}'
            lines.append(field_def)
        
        lines.append('')
        lines.append('    def to_dict(self) -> Dict[str, Any]:')
        lines.append('        """Convert node to dictionary representation."""')
        lines.append('        data = super().to_dict()')
        lines.append('        data["type"] = self.type.value')
        lines.append('        data["label"] = self.label')
        lines.append('        data["flipped"] = self.flipped')
        lines.append('        if self.metadata:')
        lines.append('            data["metadata"] = self.metadata')
        
        # Enum fields that need .value
        enum_fields = {
            'method': 'HttpMethod',
            'language': 'SupportedLanguage', 
            'sub_type': 'DBBlockSubType',
            'hook_type': 'HookType',
            'operation': 'NotionOperation',
            'trigger_mode': 'HookTriggerMode',
            'diagram_format': 'DiagramFormat'
        }
        
        for field in node_class['fields']:
            field_name = field["py_name"]
            ts_name = field["ts_name"]
            
            if ts_name in enum_fields:
                lines.append(f'        data["{ts_name}"] = self.{field_name}.value if self.{field_name} else None')
            else:
                lines.append(f'        data["{ts_name}"] = self.{field_name}')
        
        lines.append('        return data')
        lines.append('')
        lines.append('')
    
    # PersonBatchJobNode alias
    lines.append('@dataclass(frozen=True)')
    lines.append('class PersonBatchJobNode(PersonJobNode):')
    lines.append('    """Person batch job node - same as PersonJobNode but with different type."""')
    lines.append('    type: NodeType = field(default=NodeType.PERSON_BATCH_JOB, init=False)')
    lines.append('')
    lines.append('')
    
    # Union type - include PersonBatchJobNode
    lines.append('ExecutableNode = Union[')
    for i, node_class in enumerate(node_classes):
        lines.append(f'    {node_class["class_name"]},')
    lines.append('    PersonBatchJobNode')  # Add PersonBatchJobNode to the union
    lines.append(']')
    lines.append('')
    lines.append('')
    
    # Factory function
    lines.append('def create_executable_node(')
    lines.append('    node_type: NodeType,')
    lines.append('    node_id: NodeID,')
    lines.append('    position: Vec2,')
    lines.append('    label: str = "",')
    lines.append('    data: Optional[Dict[str, Any]] = None,')
    lines.append('    flipped: bool = False,')
    lines.append('    metadata: Optional[Dict[str, Any]] = None')
    lines.append(') -> ExecutableNode:')
    lines.append('    """Factory function to create typed executable nodes from diagram data."""')
    lines.append('    data = data or {}')
    lines.append('    ')
    
    # Generate factory cases
    for node_class in node_classes:
        lines.append(f'    if node_type == NodeType.{node_class["node_type"].upper()}:')
        lines.append(f'        return {node_class["class_name"]}(')
        lines.append('            id=node_id,')
        lines.append('            position=position,')
        lines.append('            label=label,')
        lines.append('            flipped=flipped,')
        lines.append('            metadata=metadata,')
        
        for field in node_class['fields']:
            if field.get('special_handling'):
                lines.append(f'            {field["py_name"]}={field["special_handling"]},')
            elif field.get('has_default') and not field.get('is_field_default'):
                lines.append(f'            {field["py_name"]}=data.get("{field["ts_name"]}", {field["default_value"]}),')
            else:
                lines.append(f'            {field["py_name"]}=data.get("{field["ts_name"]}"),')
        
        lines.append('        )')
        lines.append('    ')
    
    # Special case for PersonBatchJobNode - it's an alias that inherits from PersonJobNode
    lines.append('    if node_type == NodeType.PERSON_BATCH_JOB:')
    lines.append('        return PersonBatchJobNode(')
    lines.append('            id=node_id,')
    lines.append('            position=position,')
    lines.append('            label=label,')
    lines.append('            flipped=flipped,')
    lines.append('            metadata=metadata,')
    # Use the same fields as PersonJobNode
    person_job_fields = next((nc['fields'] for nc in node_classes if nc['node_type'] == 'person_job'), [])
    
    for field in person_job_fields:
        if field.get('special_handling'):
            lines.append(f'            {field["py_name"]}={field["special_handling"]},')
        elif field.get('has_default') and not field.get('is_field_default'):
            lines.append(f'            {field["py_name"]}=data.get("{field["ts_name"]}", {field["default_value"]}),')
        else:
            lines.append(f'            {field["py_name"]}=data.get("{field["ts_name"]}"),')
    lines.append('        )')
    lines.append('    ')
    
    lines.append('    raise ValueError(f"Unknown node type: {node_type}")')
    
    return '\n'.join(lines)


def generate_static_nodes_summary(static_nodes_data: dict) -> dict:
    """Generate summary for static nodes generation"""
    node_classes = static_nodes_data.get('node_classes', [])
    
    print(f"\n=== Static Nodes Generation Complete ===")
    print(f"Generated {len(node_classes)} node classes:")
    for nc in node_classes:
        print(f"  - {nc['class_name']}")
    print(f"\nOutput written to: dipeo/diagram_generated/generated_nodes.py")
    print(f"Timestamp: {datetime.now().isoformat()}")
    
    return {
        'status': 'success',
        'message': 'Static nodes generated successfully',
        'node_classes_count': len(node_classes)
    }


def main(inputs: dict) -> dict:
    """Main entry point for static nodes code generation"""
    static_nodes_data = inputs.get('static_nodes_data', {})
    return {'generated_code': generate_python_code(static_nodes_data)}