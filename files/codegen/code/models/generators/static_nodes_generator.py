"""Generate Python static node classes from extracted data."""

from datetime import datetime
from typing import Dict, List, Any


def generate_python_code(static_nodes_data: dict) -> str:
    """Generate Python code for static node classes"""
    node_classes = static_nodes_data.get('node_classes', [])
    now = static_nodes_data.get('now', datetime.now().isoformat())
    
    lines = []
    
    # Header
    lines.append('"""')
    lines.append('Auto-generated static node types from domain models.')
    lines.append('DO NOT EDIT THIS FILE DIRECTLY.')
    lines.append(f'Generated at: {now}')
    lines.append('Generated by: domain model static nodes generation')
    lines.append('"""')
    lines.append('')
    lines.append('from dataclasses import dataclass, field')
    lines.append('from typing import Dict, Any, Optional, List, Union, Literal')
    lines.append('')
    lines.append('from dipeo.models.models import (')
    lines.append('    NodeType, Vec2, NodeID, PersonID, MemoryConfig, MemorySettings, ToolConfig,')
    lines.append('    HookTriggerMode, SupportedLanguage, HttpMethod, DBBlockSubType,')
    lines.append('    NotionOperation, HookType, PersonLLMConfig, LLMService, DiagramFormat')
    lines.append(')')
    lines.append('')
    lines.append('')
    
    # Base class
    lines.append('@dataclass(frozen=True)')
    lines.append('class BaseExecutableNode:')
    lines.append('    """Base class for all executable node types."""')
    lines.append('    id: NodeID')
    lines.append('    type: NodeType')
    lines.append('    position: Vec2')
    lines.append('    label: str = ""')
    lines.append('    flipped: bool = False')
    lines.append('    metadata: Optional[Dict[str, Any]] = None')
    lines.append('    ')
    lines.append('    def to_dict(self) -> Dict[str, Any]:')
    lines.append('        """Convert node to dictionary representation."""')
    lines.append('        result = {')
    lines.append('            "id": self.id,')
    lines.append('            "type": self.type.value,')
    lines.append('            "position": {"x": self.position.x, "y": self.position.y},')
    lines.append('            "label": self.label,')
    lines.append('            "flipped": self.flipped')
    lines.append('        }')
    lines.append('        if self.metadata:')
    lines.append('            result["metadata"] = self.metadata')
    lines.append('        return result')
    lines.append('')
    lines.append('')
    
    # Generate node classes
    for node_class in node_classes:
        lines.append('@dataclass(frozen=True)')
        lines.append(f'class {node_class["class_name"]}(BaseExecutableNode):')
        lines.append(f'    type: NodeType = field(default=NodeType.{node_class["node_type"]}, init=False)')
        
        # Add fields
        for field in node_class['fields']:
            field_def = f'    {field["py_name"]}: {field["py_type"]}'
            if field.get('has_default'):
                field_def += f' = {field["default_value"]}'
            lines.append(field_def)
        
        lines.append('')
        lines.append('    def to_dict(self) -> Dict[str, Any]:')
        lines.append('        """Convert node to dictionary representation."""')
        lines.append('        data = super().to_dict()')
        
        for field in node_class['fields']:
            lines.append(f'        data["{field["ts_name"]}"] = self.{field["py_name"]}')
        
        lines.append('        return data')
        lines.append('')
        lines.append('')
    
    # PersonBatchJobNode alias
    lines.append('@dataclass(frozen=True)')
    lines.append('class PersonBatchJobNode(PersonJobNode):')
    lines.append('    """Person batch job node - same as PersonJobNode but with different type."""')
    lines.append('    type: NodeType = field(default=NodeType.person_batch_job, init=False)')
    lines.append('')
    lines.append('')
    
    # Union type
    lines.append('ExecutableNode = Union[')
    for i, node_class in enumerate(node_classes):
        comma = ',' if i < len(node_classes) - 1 else ''
        lines.append(f'    {node_class["class_name"]}{comma}')
    lines.append(']')
    lines.append('')
    lines.append('')
    
    # Factory function
    lines.append('def create_executable_node(')
    lines.append('    node_type: NodeType,')
    lines.append('    node_id: NodeID,')
    lines.append('    position: Vec2,')
    lines.append('    label: str = "",')
    lines.append('    data: Optional[Dict[str, Any]] = None,')
    lines.append('    flipped: bool = False,')
    lines.append('    metadata: Optional[Dict[str, Any]] = None')
    lines.append(') -> ExecutableNode:')
    lines.append('    """Factory function to create typed executable nodes from diagram data."""')
    lines.append('    data = data or {}')
    lines.append('    ')
    
    # Generate factory cases
    for node_class in node_classes:
        lines.append(f'    if node_type == NodeType.{node_class["node_type"]}:')
        lines.append(f'        return {node_class["class_name"]}(')
        lines.append('            id=node_id,')
        lines.append('            position=position,')
        lines.append('            label=label,')
        lines.append('            flipped=flipped,')
        lines.append('            metadata=metadata,')
        
        for field in node_class['fields']:
            if field.get('special_handling'):
                lines.append(f'            {field["py_name"]}={field["special_handling"]},')
            elif field.get('has_default') and not field.get('is_field_default'):
                lines.append(f'            {field["py_name"]}=data.get("{field["ts_name"]}", {field["default_value"]}),')
            else:
                lines.append(f'            {field["py_name"]}=data.get("{field["ts_name"]}"),')
        
        lines.append('        )')
        lines.append('    ')
    
    # Special case for PersonBatchJobNode
    lines.append('    if node_type == NodeType.person_batch_job:')
    lines.append('        return PersonBatchJobNode(')
    lines.append('            id=node_id,')
    lines.append('            position=position,')
    lines.append('            label=label,')
    lines.append('            flipped=flipped,')
    lines.append('            metadata=metadata,')
    lines.append('            person_id=data.get("person"),')
    lines.append('            first_only_prompt=data.get("first_only_prompt", ""),')
    lines.append('            default_prompt=data.get("default_prompt"),')
    lines.append('            max_iteration=data.get("max_iteration", 1),')
    lines.append('            memory_config=MemoryConfig(**data.get("memory_config")) if data.get("memory_config") else None,')
    lines.append('            memory_settings=MemorySettings(**data.get("memory_settings")) if data.get("memory_settings") else None,')
    lines.append('            tools=[ToolConfig(**tool) if isinstance(tool, dict) else tool for tool in data.get("tools", [])] if data.get("tools") else None')
    lines.append('        )')
    lines.append('    ')
    
    lines.append('    raise ValueError(f"Unknown node type: {node_type}")')
    
    return '\n'.join(lines)


def generate_static_nodes_summary(static_nodes_data: dict) -> dict:
    """Generate summary for static nodes generation"""
    node_classes = static_nodes_data.get('node_classes', [])
    
    print(f"\n=== Static Nodes Generation Complete ===")
    print(f"Generated {len(node_classes)} node classes:")
    for nc in node_classes:
        print(f"  - {nc['class_name']}")
    print(f"\nOutput written to: dipeo/diagram_generated/generated_nodes.py")
    print(f"Timestamp: {datetime.now().isoformat()}")
    
    return {
        'status': 'success',
        'message': 'Static nodes generated successfully',
        'node_classes_count': len(node_classes)
    }


def main(inputs: dict) -> dict:
    """Main entry point for static nodes code generation"""
    static_nodes_data = inputs.get('static_nodes_data', {})
    return {'generated_code': generate_python_code(static_nodes_data)}