"""Generate Python static node classes from extracted data."""

from datetime import datetime
from typing import Dict, List, Any


def generate_python_code(static_nodes_data: dict) -> str:
    """Generate Python code for static node classes"""
    node_classes = static_nodes_data.get('node_classes', [])
    now = static_nodes_data.get('now', datetime.now().isoformat())
    
    lines = []
    
    # Header
    lines.append('"""')
    lines.append('Auto-generated static node types from domain models.')
    lines.append('DO NOT EDIT THIS FILE DIRECTLY.')
    lines.append(f'Generated at: {now}')
    lines.append('Generated by: domain model static nodes generation')
    lines.append('"""')
    lines.append('')
    lines.append('from dataclasses import dataclass, field')
    lines.append('from typing import Dict, Any, Optional, List, Union, Literal')
    lines.append('')
    lines.append('from dipeo.models.models import (')
    lines.append('    NodeType, Vec2, NodeID, PersonID, MemorySettings, ToolConfig,')
    lines.append('    HookTriggerMode, SupportedLanguage, HttpMethod, DBBlockSubType,')
    lines.append('    NotionOperation, HookType, DiagramFormat')
    lines.append(')')
    lines.append('')
    lines.append('')
    
    # Base class
    lines.append('@dataclass(frozen=True)')
    lines.append('class BaseExecutableNode:')
    lines.append('    """Base class for all executable node types."""')
    lines.append('    id: NodeID')
    lines.append('    type: NodeType')
    lines.append('    position: Vec2')
    lines.append('    label: str = ""')
    lines.append('    flipped: bool = False')
    lines.append('    metadata: Optional[Dict[str, Any]] = None')
    lines.append('    ')
    lines.append('    def to_dict(self) -> Dict[str, Any]:')
    lines.append('        """Convert node to dictionary representation."""')
    lines.append('        result = {')
    lines.append('            "id": self.id,')
    lines.append('            "type": self.type.value,')
    lines.append('            "position": {"x": self.position.x, "y": self.position.y},')
    lines.append('            "label": self.label,')
    lines.append('            "flipped": self.flipped')
    lines.append('        }')
    lines.append('        if self.metadata:')
    lines.append('            result["metadata"] = self.metadata')
    lines.append('        return result')
    lines.append('')
    lines.append('')
    
    # Generate node classes
    for node_class in node_classes:
        lines.append('@dataclass(frozen=True)')
        lines.append(f'class {node_class["class_name"]}(BaseExecutableNode):')
        lines.append(f'    type: NodeType = field(default=NodeType.{node_class["node_type"]}, init=False)')
        
        # When inheriting from a dataclass with default values,
        # all fields must have defaults in Python dataclasses.
        # So we need to give all required fields a special marker default
        
        # Add fields
        for field in node_class['fields']:
            py_type = field["py_type"]
            
            # Check if field has None as default and needs Optional wrapping
            if field.get('has_default') and field["default_value"] == "None":
                # Check if the type already has Optional
                if not py_type.startswith('Optional['):
                    py_type = f'Optional[{py_type}]'
            
            field_def = f'    {field["py_name"]}: {py_type}'
            
            # All fields need defaults because base class has defaults
            if field.get('has_default'):
                field_def += f' = {field["default_value"]}'
            else:
                # For required fields, use field() with no default
                # This preserves the required nature while satisfying dataclass rules
                field_def += ' = field()'
                
            lines.append(field_def)
        
        lines.append('')
        lines.append('    def to_dict(self) -> Dict[str, Any]:')
        lines.append('        """Convert node to dictionary representation."""')
        lines.append('        data = super().to_dict()')
        
        # Enum fields that need .value
        enum_fields = {
            'method': 'HttpMethod',
            'language': 'SupportedLanguage', 
            'sub_type': 'DBBlockSubType',
            'hook_type': 'HookType',
            'operation': 'NotionOperation',
            'trigger_mode': 'HookTriggerMode',
            'diagram_format': 'DiagramFormat'
        }
        
        for field in node_class['fields']:
            field_name = field["py_name"]
            ts_name = field["ts_name"]
            
            if ts_name in enum_fields:
                lines.append(f'        data["{ts_name}"] = self.{field_name}.value if self.{field_name} else None')
            else:
                lines.append(f'        data["{ts_name}"] = self.{field_name}')
        
        lines.append('        return data')
        lines.append('')
        lines.append('')
    
    # PersonBatchJobNode alias
    lines.append('@dataclass(frozen=True)')
    lines.append('class PersonBatchJobNode(PersonJobNode):')
    lines.append('    """Person batch job node - same as PersonJobNode but with different type."""')
    lines.append('    type: NodeType = field(default=NodeType.person_batch_job, init=False)')
    lines.append('')
    lines.append('')
    
    # Union type - include PersonBatchJobNode
    lines.append('ExecutableNode = Union[')
    for i, node_class in enumerate(node_classes):
        lines.append(f'    {node_class["class_name"]},')
    lines.append('    PersonBatchJobNode')  # Add PersonBatchJobNode to the union
    lines.append(']')
    lines.append('')
    lines.append('')
    
    # Factory function
    lines.append('def create_executable_node(')
    lines.append('    node_type: NodeType,')
    lines.append('    node_id: NodeID,')
    lines.append('    position: Vec2,')
    lines.append('    label: str = "",')
    lines.append('    data: Optional[Dict[str, Any]] = None,')
    lines.append('    flipped: bool = False,')
    lines.append('    metadata: Optional[Dict[str, Any]] = None')
    lines.append(') -> ExecutableNode:')
    lines.append('    """Factory function to create typed executable nodes from diagram data."""')
    lines.append('    data = data or {}')
    lines.append('    ')
    
    # Generate factory cases
    for node_class in node_classes:
        lines.append(f'    if node_type == NodeType.{node_class["node_type"]}:')
        lines.append(f'        return {node_class["class_name"]}(')
        lines.append('            id=node_id,')
        lines.append('            position=position,')
        lines.append('            label=label,')
        lines.append('            flipped=flipped,')
        lines.append('            metadata=metadata,')
        
        for field in node_class['fields']:
            if field.get('special_handling'):
                lines.append(f'            {field["py_name"]}={field["special_handling"]},')
            elif field.get('has_default') and not field.get('is_field_default'):
                lines.append(f'            {field["py_name"]}=data.get("{field["ts_name"]}", {field["default_value"]}),')
            else:
                lines.append(f'            {field["py_name"]}=data.get("{field["ts_name"]}"),')
        
        lines.append('        )')
        lines.append('    ')
    
    # Special case for PersonBatchJobNode - it's an alias that inherits from PersonJobNode
    lines.append('    if node_type == NodeType.person_batch_job:')
    lines.append('        return PersonBatchJobNode(')
    lines.append('            id=node_id,')
    lines.append('            position=position,')
    lines.append('            label=label,')
    lines.append('            flipped=flipped,')
    lines.append('            metadata=metadata,')
    # Use the same fields as PersonJobNode
    person_job_fields = next((nc['fields'] for nc in node_classes if nc['node_type'] == 'person_job'), [])
    
    for field in person_job_fields:
        if field.get('special_handling'):
            lines.append(f'            {field["py_name"]}={field["special_handling"]},')
        elif field.get('has_default') and not field.get('is_field_default'):
            lines.append(f'            {field["py_name"]}=data.get("{field["ts_name"]}", {field["default_value"]}),')
        else:
            lines.append(f'            {field["py_name"]}=data.get("{field["ts_name"]}"),')
    lines.append('        )')
    lines.append('    ')
    
    lines.append('    raise ValueError(f"Unknown node type: {node_type}")')
    
    return '\n'.join(lines)


def generate_static_nodes_summary(static_nodes_data: dict) -> dict:
    """Generate summary for static nodes generation"""
    node_classes = static_nodes_data.get('node_classes', [])
    
    print(f"\n=== Static Nodes Generation Complete ===")
    print(f"Generated {len(node_classes)} node classes:")
    for nc in node_classes:
        print(f"  - {nc['class_name']}")
    print(f"\nOutput written to: dipeo/diagram_generated/generated_nodes.py")
    print(f"Timestamp: {datetime.now().isoformat()}")
    
    return {
        'status': 'success',
        'message': 'Static nodes generated successfully',
        'node_classes_count': len(node_classes)
    }


def main(inputs: dict) -> dict:
    """Main entry point for static nodes code generation"""
    static_nodes_data = inputs.get('static_nodes_data', {})
    return {'generated_code': generate_python_code(static_nodes_data)}