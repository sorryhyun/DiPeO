"""
Generated Pydantic models from TypeScript definitions.
DO NOT EDIT - This file is automatically generated.
"""

# Standard library imports
{{#each model_data.imports}}
{{#if (eq this.module "typing")}}from typing import {{#each this.items}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}
{{/if}}
{{#if (eq this.module "enum")}}from enum import {{#each this.items}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}
{{/if}}
{{#if (eq this.module "datetime")}}from datetime import {{#each this.items}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}
{{/if}}
{{#if (eq this.module "re")}}from re import {{#each this.items}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}
{{/if}}
{{/each}}

# Third-party imports
from pydantic import BaseModel, Field, field_validator, model_validator
{{#each model_data.imports}}
{{#unless (or (eq this.module "typing") (eq this.module "enum") (eq this.module "datetime") (eq this.module "re") (startsWith this.module "dipeo"))}}
from {{this.module}} import {{#each this.items}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}
{{/unless}}
{{/each}}

# Local imports
{{#each model_data.imports}}
{{#if (startsWith this.module "dipeo")}}
from {{this.module}} import {{#each this.items}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}
{{/if}}
{{/each}}

# Type aliases
{{#each model_data.type_aliases}}
{{@key}} = {{this}}
{{/each}}


# Enums
{{#each model_data.models}}
{{#if (eq this.type "enum")}}
class {{this.name}}({{#each this.bases}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}):
    """{{#if this.docstring}}{{this.docstring}}{{else}}{{this.name}} enumeration.{{/if}}"""
    {{#each this.enum_values}}
    {{this.[0]}} = "{{this.[1]}}"
    {{/each}}

{{/if}}
{{/each}}

# Models
{{#each model_data.models}}
{{#if (eq this.type "class")}}
class {{this.name}}({{#each this.bases}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}):
    """{{#if this.docstring}}{{this.docstring}}{{else}}{{this.name}} model.{{/if}}"""
    {{#if this.fields}}
    # Fields
    {{#each this.fields}}
    {{this.name}}: {{#if this.required}}{{this.type}}{{else}}Optional[{{this.type}}]{{/if}}{{#if this.field_definition}} = {{this.field_definition}}{{else}}{{#unless this.required}} = None{{/unless}}{{/if}}
    {{/each}}
    {{else}}
    pass
    {{/if}}
    
    {{#if this.methods}}
    # Validators
    {{#each this.methods}}
    {{this.decorator}}
    {{#each this.body}}
    {{this}}
    {{/each}}
    
    {{/each}}
    {{/if}}
    
    {{#if (eq this.name "BaseNode")}}
    # Common model configuration
    model_config = {
        "extra": "forbid",
        "validate_assignment": True,
        "arbitrary_types_allowed": True,
    }
    {{/if}}
    
    {{#if this.fields}}
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}
    {{/if}}

{{/if}}
{{/each}}

# Helper functions
def validate_node_type(node_type: str) -> str:
    """Validate that node_type is a valid NodeType."""
    try:
        NodeType(node_type)
        return node_type
    except ValueError:
        raise ValueError(f"Invalid node type: {node_type}")


def validate_handle(handle: str) -> str:
    """Validate handle format."""
    if not handle or not isinstance(handle, str):
        raise ValueError("Handle must be a non-empty string")
    return handle


# Model registry for dynamic instantiation
MODEL_REGISTRY = {
    {{#each model_data.models}}
    {{#if (and (eq this.type "class") (endsWith this.name "Node"))}}
    "{{this.name}}": {{this.name}},
    {{/if}}
    {{/each}}
}


def create_node_model(node_type: str, data: Dict[str, Any]) -> BaseModel:
    """Create a node model instance based on node type."""
    model_name = f"{node_type.replace('_', ' ').title().replace(' ', '')}Node"
    model_class = MODEL_REGISTRY.get(model_name)
    
    if not model_class:
        raise ValueError(f"Unknown node type: {node_type}")
    
    return model_class(**data)