/**
 * Generated Zod schemas from TypeScript definitions.
 * DO NOT EDIT - This file is automatically generated.
 */

import { z } from 'zod';

// Type aliases as Zod schemas
{{#each zod_data.models}}
{{#if (eq this.type "type_alias")}}
export const {{this.name}}Schema = {{toZodSchema this.definition}};
export type {{this.name}} = z.infer<typeof {{this.name}}Schema>;
{{/if}}
{{/each}}

// Enum schemas
{{#each zod_data.models}}
{{#if (eq this.type "enum")}}
export const {{this.name}}Schema = z.enum([
  {{#each this.enum_values}}
  "{{this.[1]}}",
  {{/each}}
]);
export type {{this.name}} = z.infer<typeof {{this.name}}Schema>;

{{/if}}
{{/each}}

// Interface/Class schemas
{{#each zod_data.models}}
{{#if (eq this.type "class")}}
export const {{this.name}}Schema = z.object({
  {{#each this.fields}}
  {{this.name}}: {{toZodType this.type this.required}},
  {{/each}}
}){{#if this.strict}}.strict(){{/if}};

export type {{this.name}} = z.infer<typeof {{this.name}}Schema>;

{{/if}}
{{/each}}

// Union schemas for node types
export const NodeDataSchema = z.discriminatedUnion('type', [
  {{#each zod_data.models}}
  {{#if (endsWith this.name "NodeData")}}
  {{this.name}}Schema,
  {{/if}}
  {{/each}}
]);

export type NodeData = z.infer<typeof NodeDataSchema>;

// Helper functions
export function validateNodeData(data: unknown): NodeData {
  return NodeDataSchema.parse(data);
}

export function isValidNodeData(data: unknown): data is NodeData {
  return NodeDataSchema.safeParse(data).success;
}

// Schema registry for dynamic validation
export const SchemaRegistry = {
  {{#each zod_data.models}}
  {{this.name}}: {{this.name}}Schema,
  {{/each}}
} as const;

// Export all schemas
export {
  {{#each zod_data.models}}
  {{this.name}}Schema,
  {{/each}}
};