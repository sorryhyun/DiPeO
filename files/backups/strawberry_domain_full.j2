"""
Strawberry GraphQL domain types for DiPeO.
Auto-generated from TypeScript interfaces.

Generated at: {{ generated_at }}
"""

import strawberry
from typing import Optional, Dict, Any, List, Union
from strawberry.scalars import JSON as JSONScalar

# Import the Pydantic domain models
from dipeo.diagram_generated.domain_models import (
{%- for type in types %}
    {{ type['name'] }},
{%- endfor %}
)

# Import the Status enum for GraphQL type resolution
from dipeo.diagram_generated.enums import Status

# Import scalar types
from .scalars import (
{%- for scalar in scalars %}
    {{ scalar.name }}Scalar,
{%- endfor %}
)

# Note: HookIDScalar and TaskIDScalar are not branded types yet
# TODO: Add these as branded types in TypeScript models
from strawberry.scalars import ID
HookIDScalar = ID  # Temporary fallback
TaskIDScalar = ID  # Temporary fallback

# Import generated types that already exist
from dipeo.diagram_generated.graphql.strawberry_domain import (
    ToolConfigType,
)

# Create Strawberry types from Pydantic models
# Order matters - define types that are referenced by others first
{% for type in types %}
{% set has_custom_fields = type.get('custom_fields') and type['custom_fields']|length > 0 -%}
{% set has_field_methods = type.get('field_methods') and type['field_methods']|length > 0 -%}
{% set needs_manual = type.get('needs_manual_conversion', False) -%}
{% set use_all_fields = type.get('has_all_fields') or (not has_custom_fields and not has_field_methods and not needs_manual) -%}

{% if needs_manual -%}
# {{ type['name'] }} has fields that need manual conversion
@strawberry.type
class {{ type['name'] }}Type:
{%- for field in type.get('fields', []) %}
{%- if field.get('is_json_dict') %}
    {{ field['name'] }}: {{ 'Optional[JSONScalar]' if field['optional'] else 'JSONScalar' }}  # JsonDict converted to JSON
{%- elif field.get('is_literal') %}
    {{ field['name'] }}: {{ 'Optional[str]' if field['optional'] else 'str' }}  # Literal type
{%- elif field['name'] == 'id' %}
{%- if field['type'] == 'str' %}
    id: {{ 'Optional[str]' if field['optional'] else 'str' }}{{ ' = None' if field['optional'] else '' }}
{%- elif field['type'].endswith('ID') %}
    {%- if field['optional'] and not field['type'].startswith('Optional[') %}
    id: Optional[{{ field['type'] }}Scalar] = None
    {%- else %}
    id: {{ field['type'] }}Scalar{{ ' = None' if field['type'].startswith('Optional[') else '' }}
    {%- endif %}
{%- else %}
    {%- if field['optional'] and not field['type'].startswith('Optional[') %}
    id: Optional[{{ field['type'] }}] = None
    {%- else %}
    id: {{ field['type'] }}{{ ' = None' if field['type'].startswith('Optional[') else '' }}
    {%- endif %}
{%- endif %}
{%- elif field['type'].startswith('List[Domain') %}
    {{ field['name'] }}: list[{{ field['type'].replace('List[', '').replace(']', '') }}Type]
{%- elif field['type'].startswith('Domain') %}
    {{ field['name'] }}: {{ field['type'] }}Type
{%- elif field['type'] == 'Vec2' %}
    {{ field['name'] }}: Vec2Type
{%- elif field['type'] == 'PersonLLMConfig' %}
    {{ field['name'] }}: PersonLLMConfigType
{%- elif field['type'] == 'DiagramMetadata' %}
    {{ field['name'] }}: {{ 'Optional[DiagramMetadataType]' if field['optional'] else 'DiagramMetadataType' }}
{%- elif field['type'] == 'ExecutionMetrics' %}
    {{ field['name'] }}: {{ 'Optional[ExecutionMetricsType]' if field['optional'] else 'ExecutionMetricsType' }}
{%- elif field['type'] == 'LLMUsage' %}
    {{ field['name'] }}: LLMUsageType
{%- elif field['type'].startswith('dict[str,') %}
    {{ field['name'] }}: JSONScalar  # {{ field['type'] }} as JSON
{%- elif field['type'].startswith('list[str]') %}
    {{ field['name'] }}: list[str]
{%- elif field['type'].startswith('list[list[str]]') %}
    {{ field['name'] }}: {{ 'Optional[' + field['type'] + ']' if field['optional'] else field['type'] }}{{ ' = None' if field['optional'] else '' }}
{%- elif field['type'].startswith('list[Bottleneck]') %}
    {{ field['name'] }}: Optional[List[BottleneckType]] = None
{%- elif field['type'].startswith('List[Message]') or field['type'] == 'list[Message]' %}
    {{ field['name'] }}: List[MessageType]
{%- elif field['type'].startswith('List[ConversationMetadata]') or field['type'] == 'list[ConversationMetadata]' %}
    {{ field['name'] }}: List[ConversationMetadataType]
{%- elif field['type'] == 'ConversationMetadata' %}
    {{ field['name'] }}: {{ 'Optional[ConversationMetadataType]' if field['optional'] else 'ConversationMetadataType' }}{{ ' = None' if field['optional'] else '' }}
{%- elif field['type'].endswith('ID') %}
    {{ field['name'] }}: {{ 'Optional[' + field['type'] + 'Scalar]' if field['optional'] else field['type'] + 'Scalar' }}{{ ' = None' if field['optional'] else '' }}
{%- elif field['type'].startswith('Optional[') and field['type'][9:-1].endswith('ID') %}
    {{ field['name'] }}: Optional[{{ field['type'][9:-1] }}Scalar] = None
{%- elif field['type'].startswith('Union[PersonID') %}
    {{ field['name'] }}: Union[PersonIDScalar, str]{{ ' = None' if field['optional'] else '' }}
{%- elif field['type'] == 'NodeType' %}
    {{ field['name'] }}: str  # NodeType enum value
{%- elif field['type'] == 'ContentType' or field['type'] == 'Optional[ContentType]' %}
    {{ field['name'] }}: {{ 'Optional[str]' if field['optional'] or 'Optional[' in field['type'] else 'str' }}{{ ' = None' if field['optional'] or 'Optional[' in field['type'] else '' }}  # ContentType enum value
{%- elif field['type'] == 'EventType' %}
    {{ field['name'] }}: str  # EventType enum value
{%- elif field['type'] == 'Status' %}
    {{ field['name'] }}: str  # Status enum value
{%- elif field['type'].startswith('list[') and field['type'].endswith('Type]') %}
    {{ field['name'] }}: {{ 'Optional[' + field['type'] + ']' if field['optional'] else field['type'] }}{{ ' = None' if field['optional'] else '' }}
{%- elif field['type'].startswith('Dict[str,') or field['type'].startswith('dict[str,') %}
    {%- if 'JSONScalar' in field['type'] or 'JsonDict' in field['type'] %}
    {{ field['name'] }}: {{ 'Optional[JSONScalar]' if field['optional'] else 'JSONScalar' }}{{ ' = None' if field['optional'] else '' }}  # {{ field['type'] }}
    {%- else %}
    {{ field['name'] }}: JSONScalar{{ ' = None' if field['optional'] else '' }}  # {{ field['type'] }} as JSON
    {%- endif %}
{%- else %}
    {%- if field['optional'] and not field['type'].startswith('Optional[') %}
    {{ field['name'] }}: Optional[{{ field['type'] }}]{{ ' = None' }}
    {%- else %}
    {{ field['name'] }}: {{ field['type'] }}{{ ' = None' if field['optional'] or field['type'].startswith('Optional[') else '' }}
{%- endif %}
{%- endif %}
{%- endfor %}

    @staticmethod
    def from_pydantic(obj: {{ type['name'] }}) -> "{{ type['name'] }}Type":
        """Convert from Pydantic model"""
{%- if type['name'] == 'DomainNode' %}
        # Vec2Type is a pydantic type, use its from_pydantic method
        position = Vec2Type.from_pydantic(obj.position) if hasattr(Vec2Type, 'from_pydantic') else Vec2Type(x=obj.position.x, y=obj.position.y)
        return DomainNodeType(
            id=obj.id,
            type=str(obj.type.value) if hasattr(obj.type, 'value') else str(obj.type),
            position=position,
            data=obj.data  # Will be serialized as JSON
        )
{%- elif type['name'] == 'ExecutionState' %}
        # LLMUsageType and ExecutionMetricsType use pydantic decorator, so pass the object directly
        llm_usage = LLMUsageType.from_pydantic(obj.llm_usage) if hasattr(LLMUsageType, 'from_pydantic') else obj.llm_usage
        metrics = None
        if obj.metrics:
            metrics = ExecutionMetricsType.from_pydantic(obj.metrics) if hasattr(ExecutionMetricsType, 'from_pydantic') else obj.metrics

        # Convert node_states dict to JSON-serializable format
        node_states_dict = {}
        if obj.node_states:
            for node_id, node_state in obj.node_states.items():
                if hasattr(node_state, 'model_dump'):
                    node_states_dict[node_id] = node_state.model_dump()
                else:
                    node_states_dict[node_id] = node_state

        # Convert node_outputs dict to JSON-serializable format
        node_outputs_dict = {}
        if obj.node_outputs:
            for node_id, node_output in obj.node_outputs.items():
                if hasattr(node_output, 'model_dump'):
                    node_outputs_dict[node_id] = node_output.model_dump()
                else:
                    node_outputs_dict[node_id] = node_output

        return ExecutionStateType(
            id=obj.id,
            status=str(obj.status.value) if hasattr(obj.status, 'value') else str(obj.status),
            diagram_id=obj.diagram_id,
            started_at=obj.started_at,
            ended_at=obj.ended_at,
            node_states=node_states_dict,  # Now JSON-serializable
            node_outputs=node_outputs_dict,  # Now JSON-serializable
            llm_usage=llm_usage,
            error=obj.error,
            variables=obj.variables,
            metadata=obj.metadata,
            duration_seconds=obj.duration_seconds,
            is_active=getattr(obj, 'is_active', None),
            exec_counts=obj.exec_counts if obj.exec_counts else {},  # Will be serialized as JSON
            executed_nodes=obj.executed_nodes,
            metrics=metrics
        )
{%- elif type['name'] == 'ExecutionMetrics' %}
        bottlenecks = None
        if obj.bottlenecks:
            bottlenecks = [BottleneckType.from_pydantic(b) if hasattr(BottleneckType, 'from_pydantic') else b for b in obj.bottlenecks]

        return ExecutionMetricsType(
            execution_id=obj.execution_id,
            start_time=obj.start_time,
            end_time=obj.end_time,
            total_duration_ms=obj.total_duration_ms,
            node_metrics=obj.node_metrics,  # Will be serialized as JSON
            critical_path=obj.critical_path,
            parallelizable_groups=obj.parallelizable_groups,
            bottlenecks=bottlenecks,
            total_llm_tokens=getattr(obj, 'total_llm_tokens', None),
            total_llm_calls=getattr(obj, 'total_llm_calls', None)
        )
{%- elif type['name'] == 'DomainArrow' %}
        return DomainArrowType(
            id=obj.id,
            source=obj.source,
            target=obj.target,
            content_type=str(obj.content_type.value) if obj.content_type and hasattr(obj.content_type, 'value') else str(obj.content_type) if obj.content_type else None,
            label=obj.label,
            packing=obj.packing,
            execution_priority=obj.execution_priority,
            data=obj.data if hasattr(obj, 'data') else None
        )
{%- elif type['name'] == 'DomainPerson' %}
        return DomainPersonType(
            id=obj.id,
            label=obj.label,
            llm_config=PersonLLMConfigType.from_pydantic(obj.llm_config),
            type=obj.type
        )
{%- elif type['name'] == 'Conversation' %}
        return ConversationType(
            messages=[MessageType.from_pydantic(m) for m in obj.messages] if obj.messages else [],
            metadata=ConversationMetadataType.from_pydantic(obj.metadata) if obj.metadata and hasattr(ConversationMetadataType, 'from_pydantic') else obj.metadata
        )
{%- elif type['name'] == 'DomainDiagram' %}
        return DomainDiagramType(
            nodes=[DomainNodeType.from_pydantic(n) for n in obj.nodes],
            handles=[DomainHandleType.from_pydantic(h) if hasattr(DomainHandleType, 'from_pydantic') else h for h in obj.handles] if obj.handles else [],
            arrows=[DomainArrowType.from_pydantic(a) for a in obj.arrows],
            persons=[DomainPersonType.from_pydantic(p) for p in obj.persons],
            metadata=DiagramMetadataType.from_pydantic(obj.metadata) if obj.metadata and hasattr(DiagramMetadataType, 'from_pydantic') else obj.metadata
        )
{%- else %}
        # Generic conversion for other types
        return {{ type['name'] }}Type(
{%- for field in type.get('fields', []) %}
            {{ field['name'] }}=obj.{{ field['name'] }}{{ ',' if not loop.last else '' }}
{%- endfor %}
        )
{%- endif %}
{%- elif use_all_fields -%}
@strawberry.experimental.pydantic.type({{ type['name'] }}, all_fields=True)
class {{ type['name'] }}Type:
{%- if has_field_methods %}
{%- for method in type.get('field_methods', []) %}
    @strawberry.field
    def {{ method['name'] }}(self) -> {{ method['return_type'] }}:
        """{{ method.get('description', '') }}"""
{%- if method['name'] == "type" and type['name'] == "DomainNode" %}
        # Return the enum value (lowercase) instead of the enum name
        node_type = self.type
        return node_type.value if node_type else ''
{%- elif method.name == "type" and type.name == "DomainPerson" %}
        return "person"
{%- elif method.name == "data" %}
{%- if method.is_optional %}
        return self.data if hasattr(self, 'data') else None
{%- else %}
        return self.data if hasattr(self, 'data') else {}
{%- endif %}
{%- elif method.name == "output" %}
        return self.output if hasattr(self, 'output') else None
{%- elif method.name == "variables" %}
{%- if method.is_optional %}
        return self.variables if hasattr(self, 'variables') else None
{%- else %}
        return self.variables if hasattr(self, 'variables') else {}
{%- endif %}
{%- elif method.name == "node_states" %}
        if hasattr(self, 'node_states') and self.node_states:
            # Convert NodeState objects to dicts
            return {k: v.model_dump() if hasattr(v, 'model_dump') else v
                    for k, v in self.node_states.items()}
        return {}
{%- elif method.name == "node_outputs" %}
        if hasattr(self, 'node_outputs') and self.node_outputs:
            # Convert SerializedNodeOutput objects to dicts for GraphQL
            result = {}
            for key, output in self.node_outputs.items():
                if hasattr(output, 'model_dump'):
                    result[key] = output.model_dump()
                else:
                    result[key] = output
            return result
        return {}
{%- elif method.name == "exec_counts" %}
        return self.exec_counts if hasattr(self, 'exec_counts') else {}
{%- elif method.name == "metrics" %}
        return self.metrics if hasattr(self, 'metrics') else None
{%- elif method.name == "node_metrics" %}
        return self.node_metrics if hasattr(self, 'node_metrics') else {}
{%- elif method.name == "nodeCount" %}
        return len(self.nodes) if hasattr(self, 'nodes') else 0
{%- elif method.name == "arrowCount" %}
        return len(self.arrows) if hasattr(self, 'arrows') else 0
{%- endif %}
{%- endfor %}
{%- else %}
    pass
{%- endif %}
{%- else %}
@strawberry.experimental.pydantic.type({{ type['name'] }})
class {{ type['name'] }}Type:
{%- for field in type.get('custom_fields', []) %}
{%- if field.get('is_auto') %}
    {{ field['name'] }}: strawberry.auto
{%- elif field.get('is_enum') %}
    {{ field['name'] }}: {{ field['type'] }}  # Explicitly specify the enum type
{%- elif field.get('is_optional') %}
    {{ field['name'] }}: {{ field['type'] | ensure_optional }} = {{ field.get('default', 'None') }}
{%- else %}
    {{ field['name'] }}: {{ field['type'] }}
{%- endif %}
{%- endfor %}

{%- for method in type.get('field_methods', []) %}
    @strawberry.field
    def {{ method['name'] }}(self) -> {{ method['return_type'] }}:
        """{{ method.get('description', '') }}"""
{%- if method['name'] == "type" and type['name'] == "DomainNode" %}
        # Return the enum value (lowercase) instead of the enum name
        node_type = self.type
        return node_type.value if node_type else ''
{%- elif method.name == "type" and type.name == "DomainPerson" %}
        return "person"
{%- elif method.name == "data" %}
{%- if method.is_optional %}
        return self.data if hasattr(self, 'data') else None
{%- else %}
        return self.data if hasattr(self, 'data') else {}
{%- endif %}
{%- elif method.name == "output" %}
        return self.output if hasattr(self, 'output') else None
{%- elif method.name == "variables" %}
{%- if method.is_optional %}
        return self.variables if hasattr(self, 'variables') else None
{%- else %}
        return self.variables if hasattr(self, 'variables') else {}
{%- endif %}
{%- elif method.name == "node_states" %}
        if hasattr(self, 'node_states') and self.node_states:
            # Convert NodeState objects to dicts
            return {k: v.model_dump() if hasattr(v, 'model_dump') else v
                    for k, v in self.node_states.items()}
        return {}
{%- elif method.name == "node_outputs" %}
        if hasattr(self, 'node_outputs') and self.node_outputs:
            # Convert SerializedNodeOutput objects to dicts for GraphQL
            result = {}
            for key, output in self.node_outputs.items():
                if hasattr(output, 'model_dump'):
                    result[key] = output.model_dump()
                else:
                    result[key] = output
            return result
        return {}
{%- elif method.name == "exec_counts" %}
        return self.exec_counts if hasattr(self, 'exec_counts') else {}
{%- elif method.name == "metrics" %}
        return self.metrics if hasattr(self, 'metrics') else None
{%- elif method.name == "node_metrics" %}
        return self.node_metrics if hasattr(self, 'node_metrics') else {}
{%- elif method.name == "nodeCount" %}
        return len(self.nodes) if hasattr(self, 'nodes') else 0
{%- elif method.name == "arrowCount" %}
        return len(self.arrows) if hasattr(self, 'arrows') else 0
{%- endif %}
{%- endfor %}
{%- endif %}
{% endfor %}
# Subscription-specific types (not from Pydantic models)
@strawberry.type
class ExecutionUpdate:
    """Real-time execution update."""

    execution_id: str
    event_type: str
    data: JSONScalar
    timestamp: str

# Alias for backward compatibility
SerializedNodeOutputType = SerializedEnvelopeType

# Export all types
__all__ = [
{%- for type in types %}
    '{{ type.name }}Type',
{%- endfor %}
    'ExecutionUpdate',  # For subscriptions
    'SerializedNodeOutputType',  # Alias
    'ToolConfigType',  # Re-exported from generated code
]
