version: light
nodes:
- label: Start Watch
  type: start
  position: {x: 100, y: 300}
  props:
    trigger_mode: manual
    custom_data:
      watch_interval: 5
    output_data_structure:
      watch_interval: number

- label: Monitor Specifications
  type: code_job
  position: {x: 300, y: 300}
  props:
    code_type: python
    code: |
      import os
      import json
      import time
      import hashlib
      from datetime import datetime
      
      # Get watch interval from input
      watch_interval = inputs.get('watch_interval', 5)
      
      # Directory to monitor
      spec_dir = 'files/specifications/nodes'
      
      # Cache file to store checksums
      cache_file = '.spec_checksums.json'
      
      # Load previous checksums
      if os.path.exists(cache_file):
          with open(cache_file, 'r') as f:
              previous_checksums = json.load(f)
      else:
          previous_checksums = {}
      
      # Current checksums
      current_checksums = {}
      changed_specs = []
      
      # Check all spec files
      if os.path.exists(spec_dir):
          for filename in os.listdir(spec_dir):
              if filename.endswith('.json'):
                  filepath = os.path.join(spec_dir, filename)
                  with open(filepath, 'rb') as f:
                      content = f.read()
                      checksum = hashlib.md5(content).hexdigest()
                      current_checksums[filename] = checksum
                      
                      # Check if file has changed
                      if filename not in previous_checksums or previous_checksums[filename] != checksum:
                          changed_specs.append(filepath)
      
      # Save current checksums
      with open(cache_file, 'w') as f:
          json.dump(current_checksums, f)
      
      # Return results
      result = {
          'changed_specs': changed_specs,
          'timestamp': datetime.now().isoformat(),
          'total_specs': len(current_checksums),
          'changes_detected': len(changed_specs) > 0
      }
      
      return result
    functionName: monitor_specs

- label: Check for Changes
  type: condition
  position: {x: 500, y: 300}
  props:
    condition: "{{changes_detected}}"

- label: Trigger Code Generation
  type: code_job
  position: {x: 700, y: 200}
  props:
    code_type: bash
    code: |
      # For each changed spec, run the code generation
      for spec in {{#each changed_specs}}"{{this}}" {{/each}}; do
        echo "Regenerating code for: $spec"
        dipeo run codegen/node_ui_codegen --light --vars "node_spec_path=$spec" --no-browser
      done
    functionName: trigger_codegen

- label: Report No Changes
  type: person_job
  position: {x: 700, y: 400}
  props:
    person: Person 1
    default_prompt: |
      No changes detected in node specifications at {{timestamp}}.
      Total specifications monitored: {{total_specs}}
      
      Waiting {{watch_interval}} seconds before next check...
    max_iteration: 1

- label: Wait
  type: code_job
  position: {x: 900, y: 300}
  props:
    code_type: python
    code: |
      import time
      time.sleep(inputs.get('watch_interval', 5))
      return {'continue': True}
    functionName: wait

- label: Continue Loop
  type: endpoint
  position: {x: 1100, y: 300}
  props:
    save_to_file: false

connections:
- from: Start Watch
  to: Monitor Specifications
  content_type: object
  label: config

- from: Monitor Specifications
  to: Check for Changes
  content_type: object

- from: Check for Changes
  to: Trigger Code Generation
  content_type: object
  condition_outcome: true

- from: Check for Changes
  to: Report No Changes
  content_type: object
  condition_outcome: false

- from: Trigger Code Generation
  to: Wait
  content_type: object

- from: Report No Changes
  to: Wait
  content_type: object

- from: Start Watch
  to: Wait
  content_type: object
  label: config

- from: Wait
  to: Continue Loop
  content_type: object

persons:
  Person 1:
    service: openai
    model: gpt-4.1-nano
    api_key_id: APIKEY_52609F
