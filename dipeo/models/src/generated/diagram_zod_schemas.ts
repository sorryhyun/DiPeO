/**
 * Generated Zod schemas from TypeScript definitions.
 * DO NOT EDIT - This file is automatically generated.
 */

import { z } from 'zod';

// Type aliases as Zod schemas

// Enum schemas
export const LLMServiceSchema = z.enum([
  "openai",
  "anthropic",
  "google",
  "bedrock",
  "vertex",
  "deepseek",
]);
export type LLMService = z.infer<typeof LLMServiceSchema>;

export const APIServiceTypeSchema = z.enum([
  "openai",
  "anthropic",
  "google",
  "gemini",
  "bedrock",
  "vertex",
  "deepseek",
  "notion",
  "google_search",
  "slack",
  "github",
  "jira",
]);
export type APIServiceType = z.infer<typeof APIServiceTypeSchema>;

export const NotionOperationSchema = z.enum([
  "create_page",
  "update_page",
  "read_page",
  "delete_page",
  "create_database",
  "query_database",
  "update_database",
]);
export type NotionOperation = z.infer<typeof NotionOperationSchema>;

export const ToolTypeSchema = z.enum([
  "web_search",
  "web_search_preview",
  "image_generation",
]);
export type ToolType = z.infer<typeof ToolTypeSchema>;

export const ExecutionStatusSchema = z.enum([
  "PENDING",
  "RUNNING",
  "PAUSED",
  "COMPLETED",
  "FAILED",
  "ABORTED",
  "SKIPPED",
]);
export type ExecutionStatus = z.infer<typeof ExecutionStatusSchema>;

export const NodeExecutionStatusSchema = z.enum([
  "PENDING",
  "RUNNING",
  "PAUSED",
  "COMPLETED",
  "FAILED",
  "ABORTED",
  "SKIPPED",
  "MAXITER_REACHED",
]);
export type NodeExecutionStatus = z.infer<typeof NodeExecutionStatusSchema>;

export const EventTypeSchema = z.enum([
  "EXECUTION_STATUS_CHANGED",
  "NODE_STATUS_CHANGED",
  "NODE_PROGRESS",
  "INTERACTIVE_PROMPT",
  "INTERACTIVE_RESPONSE",
  "EXECUTION_ERROR",
  "EXECUTION_UPDATE",
]);
export type EventType = z.infer<typeof EventTypeSchema>;

export const NodeTypeSchema = z.enum([
  "start",
  "person_job",
  "condition",
  "job",
  "code_job",
  "api_job",
  "endpoint",
  "db",
  "user_response",
  "notion",
  "person_batch_job",
  "hook",
  "template_job",
  "json_schema_validator",
  "typescript_ast",
  "sub_diagram",
]);
export type NodeType = z.infer<typeof NodeTypeSchema>;

export const HandleDirectionSchema = z.enum([
  "input",
  "output",
]);
export type HandleDirection = z.infer<typeof HandleDirectionSchema>;

export const HandleLabelSchema = z.enum([
  "default",
  "first",
  "condtrue",
  "condfalse",
  "success",
  "error",
]);
export type HandleLabel = z.infer<typeof HandleLabelSchema>;

export const DataTypeSchema = z.enum([
  "any",
  "string",
  "number",
  "boolean",
  "object",
  "array",
]);
export type DataType = z.infer<typeof DataTypeSchema>;

export const ForgettingModeSchema = z.enum([
  "no_forget",
  "on_every_turn",
  "upon_request",
]);
export type ForgettingMode = z.infer<typeof ForgettingModeSchema>;

export const MemoryViewSchema = z.enum([
  "all_involved",
  "sent_by_me",
  "sent_to_me",
  "system_and_me",
  "conversation_pairs",
  "all_messages",
]);
export type MemoryView = z.infer<typeof MemoryViewSchema>;

export const DiagramFormatSchema = z.enum([
  "native",
  "light",
  "readable",
]);
export type DiagramFormat = z.infer<typeof DiagramFormatSchema>;

export const DBBlockSubTypeSchema = z.enum([
  "fixed_prompt",
  "file",
  "code",
  "api_tool",
]);
export type DBBlockSubType = z.infer<typeof DBBlockSubTypeSchema>;

export const ContentTypeSchema = z.enum([
  "raw_text",
  "conversation_state",
  "object",
]);
export type ContentType = z.infer<typeof ContentTypeSchema>;

export const SupportedLanguageSchema = z.enum([
  "python",
  "typescript",
  "bash",
  "shell",
]);
export type SupportedLanguage = z.infer<typeof SupportedLanguageSchema>;

export const HttpMethodSchema = z.enum([
  "GET",
  "POST",
  "PUT",
  "DELETE",
  "PATCH",
]);
export type HttpMethod = z.infer<typeof HttpMethodSchema>;

export const HookTypeSchema = z.enum([
  "shell",
  "webhook",
  "python",
  "file",
]);
export type HookType = z.infer<typeof HookTypeSchema>;

export const HookTriggerModeSchema = z.enum([
  "manual",
  "hook",
]);
export type HookTriggerMode = z.infer<typeof HookTriggerModeSchema>;


// Interface/Class schemas
export const GraphQLDomainPersonTypeSchema = z.object({
  id: z.string(),
  label: z.string(),
  llm_config: PersonLLMConfigSchema,
  type: z.string(),
});

export type GraphQLDomainPersonType = z.infer<typeof GraphQLDomainPersonTypeSchema>;

export const StoreDiagramSchema = z.object({
  nodes: z.record(z.string(), DomainNodeSchema),
  handles: z.record(z.string(), DomainHandleSchema),
  arrows: z.record(z.string(), DomainArrowSchema),
  persons: z.record(z.string(), DomainPersonSchema),
  metadata: z.any(),
});

export type StoreDiagram = z.infer<typeof StoreDiagramSchema>;

export const ToolConfigSchema = z.object({
  type: ToolTypeSchema,
  enabled: z.boolean().optional(),
  config: z.any(),
});

export type ToolConfig = z.infer<typeof ToolConfigSchema>;

export const WebSearchResultSchema = z.object({
  url: z.string(),
  title: z.string(),
  snippet: z.string(),
  score: z.number().optional(),
});

export type WebSearchResult = z.infer<typeof WebSearchResultSchema>;

export const ImageGenerationResultSchema = z.object({
  image_data: z.string(),
  format: z.string(),
  width: z.number().optional(),
  height: z.number().optional(),
});

export type ImageGenerationResult = z.infer<typeof ImageGenerationResultSchema>;

export const ToolOutputSchema = z.object({
  type: ToolTypeSchema,
  result: z.any(),
  raw_response: z.any(),
});

export type ToolOutput = z.infer<typeof ToolOutputSchema>;

export const ChatResultSchema = z.object({
  text: z.string(),
  token_usage: z.any(),
  raw_response: z.any(),
  tool_outputs: z.record(z.string(), z.any()).optional(),
});

export type ChatResult = z.infer<typeof ChatResultSchema>;

export const LLMRequestOptionsSchema = z.object({
  temperature: z.number().optional(),
  max_tokens: z.number().optional(),
  top_p: z.number().optional(),
  n: z.number().optional(),
  tools: z.record(z.string(), z.any()).optional(),
  response_format: z.any(),
});

export type LLMRequestOptions = z.infer<typeof LLMRequestOptionsSchema>;

export const TokenUsageSchema = z.object({
  input: z.number(),
  output: z.number(),
  cached: z.number().optional(),
  total: z.number().optional(),
});

export type TokenUsage = z.infer<typeof TokenUsageSchema>;

export const NodeStateSchema = z.object({
  status: NodeExecutionStatusSchema,
  started_at: z.string().optional(),
  ended_at: z.string().optional(),
  error: z.string().optional(),
  token_usage: z.any(),
  output: z.any(),
});

export type NodeState = z.infer<typeof NodeStateSchema>;

export const ExecutionStateSchema = z.object({
  id: ExecutionIDSchema,
  status: ExecutionStatusSchema,
  diagram_id: z.any(),
  started_at: z.string(),
  ended_at: z.string().optional(),
  node_states: z.record(z.string(), NodeStateSchema),
  node_outputs: z.record(z.string(), z.record(z.string(), z.any())),
  token_usage: TokenUsageSchema,
  error: z.string().optional(),
  variables: z.any(),
  duration_seconds: z.number().optional(),
  is_active: z.boolean().optional(),
  exec_counts: z.record(z.string(), z.number()),
  executed_nodes: z.record(z.string(), z.any()),
});

export type ExecutionState = z.infer<typeof ExecutionStateSchema>;

export const ExecutionOptionsSchema = z.object({
  mode: z.union([z.literal("normal"), z.literal("debug"), z.literal("monitor"), z.null()]),
  timeout: z.number().optional(),
  variables: z.any(),
  debug: z.boolean().optional(),
});

export type ExecutionOptions = z.infer<typeof ExecutionOptionsSchema>;

export const InteractivePromptDataSchema = z.object({
  node_id: NodeIDSchema,
  prompt: z.string(),
  timeout: z.number().optional(),
  default_value: z.string().optional(),
});

export type InteractivePromptData = z.infer<typeof InteractivePromptDataSchema>;

export const InteractiveResponseSchema = z.object({
  node_id: NodeIDSchema,
  response: z.string(),
  timestamp: z.string(),
});

export type InteractiveResponse = z.infer<typeof InteractiveResponseSchema>;

export const ExecutionUpdateSchema = z.object({
  type: EventTypeSchema,
  execution_id: ExecutionIDSchema,
  node_id: z.any(),
  status: NodeExecutionStatusSchema.optional(),
  result: z.any(),
  error: z.string().optional(),
  timestamp: z.string().optional(),
  total_tokens: z.number().optional(),
  node_type: z.string().optional(),
  tokens: z.number().optional(),
  data: z.any(),
});

export type ExecutionUpdate = z.infer<typeof ExecutionUpdateSchema>;

export const NodeDefinitionSchema = z.object({
  type: z.string(),
  node_schema: z.any(),
  handler: z.any(),
  requires_services: z.record(z.string(), z.any()).optional(),
  description: z.string().optional(),
});

export type NodeDefinition = z.infer<typeof NodeDefinitionSchema>;

export const Vec2Schema = z.object({
  x: z.number(),
  y: z.number(),
});

export type Vec2 = z.infer<typeof Vec2Schema>;

export const DomainHandleSchema = z.object({
  id: HandleIDSchema,
  node_id: NodeIDSchema,
  label: HandleLabelSchema,
  direction: HandleDirectionSchema,
  data_type: DataTypeSchema,
  position: z.string().optional(),
});

export type DomainHandle = z.infer<typeof DomainHandleSchema>;

export const DomainNodeSchema = z.object({
  id: NodeIDSchema,
  type: NodeTypeSchema,
  position: Vec2Schema,
  data: z.record(z.string(), z.any()),
});

export type DomainNode = z.infer<typeof DomainNodeSchema>;

export const DomainArrowSchema = z.object({
  id: ArrowIDSchema,
  source: HandleIDSchema,
  target: HandleIDSchema,
  content_type: ContentTypeSchema.optional(),
  label: z.string().optional(),
  data: z.any(),
});

export type DomainArrow = z.infer<typeof DomainArrowSchema>;

export const MemoryConfigSchema = z.object({
  forget_mode: ForgettingModeSchema.optional(),
  max_messages: z.number().optional(),
  temperature: z.number().optional(),
});

export type MemoryConfig = z.infer<typeof MemoryConfigSchema>;

export const MemorySettingsSchema = z.object({
  view: MemoryViewSchema,
  max_messages: z.number().optional(),
  preserve_system: z.boolean().optional(),
});

export type MemorySettings = z.infer<typeof MemorySettingsSchema>;

export const PersonLLMConfigSchema = z.object({
  service: LLMServiceSchema,
  model: z.string(),
  api_key_id: ApiKeyIDSchema,
  system_prompt: z.string().optional(),
});

export type PersonLLMConfig = z.infer<typeof PersonLLMConfigSchema>;

export const DomainPersonSchema = z.object({
  id: PersonIDSchema,
  label: z.string(),
  llm_config: PersonLLMConfigSchema,
  type: z.literal("person"),
});

export type DomainPerson = z.infer<typeof DomainPersonSchema>;

export const DomainApiKeySchema = z.object({
  id: ApiKeyIDSchema,
  label: z.string(),
  service: APIServiceTypeSchema,
  key: z.string().optional(),
});

export type DomainApiKey = z.infer<typeof DomainApiKeySchema>;

export const DiagramMetadataSchema = z.object({
  id: z.any(),
  name: z.string().optional(),
  description: z.string().optional(),
  version: z.string(),
  created: z.string(),
  modified: z.string(),
  author: z.string().optional(),
  tags: z.record(z.string(), z.any()).optional(),
});

export type DiagramMetadata = z.infer<typeof DiagramMetadataSchema>;

export const DomainDiagramSchema = z.object({
  nodes: z.record(z.string(), z.any()),
  handles: z.record(z.string(), z.any()),
  arrows: z.record(z.string(), z.any()),
  persons: z.record(z.string(), z.any()),
  metadata: z.any(),
});

export type DomainDiagram = z.infer<typeof DomainDiagramSchema>;

export const BaseNodeDataSchema = z.object({
  label: z.string(),
  flipped: z.boolean().optional(),
});

export type BaseNodeData = z.infer<typeof BaseNodeDataSchema>;

export const StartNodeDataSchema = z.object({
  custom_data: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])),
  output_data_structure: z.record(z.string(), z.string()),
  trigger_mode: HookTriggerModeSchema.optional(),
  hook_event: z.string().optional(),
  hook_filters: z.any(),
});

export type StartNodeData = z.infer<typeof StartNodeDataSchema>;

export const ConditionNodeDataSchema = z.object({
  condition_type: z.string(),
  expression: z.string().optional(),
  node_indices: z.record(z.string(), z.any()).optional(),
});

export type ConditionNodeData = z.infer<typeof ConditionNodeDataSchema>;

export const PersonJobNodeDataSchema = z.object({
  person: z.any(),
  first_only_prompt: z.string(),
  default_prompt: z.string().optional(),
  max_iteration: z.number(),
  memory_config: z.any(),
  memory_settings: MemorySettingsSchema.optional(),
  tools: z.record(z.string(), z.any()).optional(),
});

export type PersonJobNodeData = z.infer<typeof PersonJobNodeDataSchema>;

export const EndpointNodeDataSchema = z.object({
  save_to_file: z.boolean(),
  file_name: z.string().optional(),
});

export type EndpointNodeData = z.infer<typeof EndpointNodeDataSchema>;

export const DBNodeDataSchema = z.object({
  file: z.string().optional(),
  collection: z.string().optional(),
  sub_type: DBBlockSubTypeSchema,
  operation: z.string(),
  query: z.string().optional(),
  data: z.any(),
});

export type DBNodeData = z.infer<typeof DBNodeDataSchema>;

export const JobNodeDataSchema = z.object({
  code_type: SupportedLanguageSchema,
  code: z.string(),
});

export type JobNodeData = z.infer<typeof JobNodeDataSchema>;

export const CodeJobNodeDataSchema = z.object({
  language: SupportedLanguageSchema,
  filePath: z.string(),
  functionName: z.string().optional(),
  timeout: z.number().optional(),
});

export type CodeJobNodeData = z.infer<typeof CodeJobNodeDataSchema>;

export const ApiJobNodeDataSchema = z.object({
  url: z.string(),
  method: HttpMethodSchema,
  headers: z.any(),
  params: z.any(),
  body: z.any(),
  timeout: z.number().optional(),
  auth_type: z.union([z.literal("none"), z.literal("bearer"), z.literal("basic"), z.literal("api_key"), z.null()]),
  auth_config: z.any(),
});

export type ApiJobNodeData = z.infer<typeof ApiJobNodeDataSchema>;

export const UserResponseNodeDataSchema = z.object({
  prompt: z.string(),
  timeout: z.number(),
});

export type UserResponseNodeData = z.infer<typeof UserResponseNodeDataSchema>;

export const NotionNodeDataSchema = z.object({
  operation: NotionOperationSchema,
  page_id: z.string().optional(),
  database_id: z.string().optional(),
});

export type NotionNodeData = z.infer<typeof NotionNodeDataSchema>;

export const HookNodeDataSchema = z.object({
  hook_type: HookTypeSchema,
  config: z.union([{ command?: stringSchema, undefined; args?: {}Schema, undefined; env?: any; cwd?: stringSchema, undefined; url?: stringSchema, undefined; method?: HttpMethodSchema, undefined; headers?: any; script?: stringSchema, undefined; function_name?: stringSchema, undefined; file_path?: stringSchema, undefined; format?: "json"Schema, z.literal("yaml"), z.literal("text"), undefined; }Schema]),
  timeout: z.number().optional(),
  retry_count: z.number().optional(),
  retry_delay: z.number().optional(),
});

export type HookNodeData = z.infer<typeof HookNodeDataSchema>;

export const TemplateJobNodeDataSchema = z.object({
  template_path: z.string().optional(),
  template_content: z.string().optional(),
  output_path: z.string().optional(),
  variables: z.any(),
  engine: z.union([z.literal("internal"), z.literal("jinja2"), z.literal("handlebars"), z.null()]),
});

export type TemplateJobNodeData = z.infer<typeof TemplateJobNodeDataSchema>;

export const ShellJobNodeDataSchema = z.object({
  command: z.string(),
  args: z.record(z.string(), z.any()).optional(),
  cwd: z.string().optional(),
  env: z.any(),
  timeout: z.number().optional(),
  capture_output: z.boolean().optional(),
  shell: z.boolean().optional(),
});

export type ShellJobNodeData = z.infer<typeof ShellJobNodeDataSchema>;

export const JsonSchemaValidatorNodeDataSchema = z.object({
  schema_path: z.string().optional(),
  schema: z.any(),
  data_path: z.string().optional(),
  strict_mode: z.boolean().optional(),
  error_on_extra: z.boolean().optional(),
});

export type JsonSchemaValidatorNodeData = z.infer<typeof JsonSchemaValidatorNodeDataSchema>;

export const TypescriptAstNodeDataSchema = z.object({
  source: z.string().optional(),
  extractPatterns: z.record(z.string(), z.any()).optional(),
  includeJSDoc: z.boolean().optional(),
  parseMode: z.union([z.literal("module"), z.literal("script"), z.null()]),
});

export type TypescriptAstNodeData = z.infer<typeof TypescriptAstNodeDataSchema>;

export const SubDiagramNodeDataSchema = z.object({
  diagram_name: z.string().optional(),
  diagram_data: z.any(),
  input_mapping: z.any(),
  output_mapping: z.any(),
  timeout: z.number().optional(),
  wait_for_completion: z.boolean().optional(),
  isolate_conversation: z.boolean().optional(),
});

export type SubDiagramNodeData = z.infer<typeof SubDiagramNodeDataSchema>;

export const MessageSchema = z.object({
  id: z.string().optional(),
  from_person_id: z.any(),
  to_person_id: PersonIDSchema,
  content: z.string(),
  timestamp: z.string().optional(),
  token_count: z.number().optional(),
  message_type: z.union([z.literal("person_to_person"), z.literal("system_to_person"), z.literal("person_to_system")]),
  metadata: z.any(),
});

export type Message = z.infer<typeof MessageSchema>;

export const ConversationMetadataSchema = z.object({
  started_at: z.string(),
  last_message_at: z.string(),
  total_tokens: z.number(),
  message_count: z.number(),
  context_resets: z.number(),
});

export type ConversationMetadata = z.infer<typeof ConversationMetadataSchema>;

export const ConversationSchema = z.object({
  messages: z.record(z.string(), z.any()),
  metadata: ConversationMetadataSchema.optional(),
});

export type Conversation = z.infer<typeof ConversationSchema>;

export const MemoryStateSchema = z.object({
  visible_messages: z.number(),
  has_more: z.boolean().optional(),
  config: z.any(),
});

export type MemoryState = z.infer<typeof MemoryStateSchema>;

export const SubDiagramNodeDataSchema = z.object({
  diagram_name: z.string().optional(),
  diagram_data: z.any(),
  input_mapping: z.any(),
  output_mapping: z.any(),
  timeout: z.number().optional(),
  wait_for_completion: z.boolean().optional(),
  isolate_conversation: z.boolean().optional(),
});

export type SubDiagramNodeData = z.infer<typeof SubDiagramNodeDataSchema>;

export const HookNodeDataSchema = z.object({
  hook_type: HookTypeSchema,
  command: z.string().optional(),
  url: z.string().optional(),
  timeout: z.number().optional(),
  retry_count: z.number().optional(),
});

export type HookNodeData = z.infer<typeof HookNodeDataSchema>;

export const TypescriptAstNodeDataSchema = z.object({
  source: z.string().optional(),
  extractPatterns: z.record(z.string(), z.any()).optional(),
  includeJSDoc: z.boolean().optional(),
  parseMode: z.union([z.literal("module"), z.literal("script"), z.null()]),
});

export type TypescriptAstNodeData = z.infer<typeof TypescriptAstNodeDataSchema>;


// Union schemas for node types
export const NodeDataSchema = z.discriminatedUnion('type', [
  BaseNodeDataSchema,
  StartNodeDataSchema,
  ConditionNodeDataSchema,
  PersonJobNodeDataSchema,
  EndpointNodeDataSchema,
  DBNodeDataSchema,
  JobNodeDataSchema,
  CodeJobNodeDataSchema,
  ApiJobNodeDataSchema,
  UserResponseNodeDataSchema,
  NotionNodeDataSchema,
  HookNodeDataSchema,
  TemplateJobNodeDataSchema,
  ShellJobNodeDataSchema,
  JsonSchemaValidatorNodeDataSchema,
  TypescriptAstNodeDataSchema,
  SubDiagramNodeDataSchema,
  SubDiagramNodeDataSchema,
  HookNodeDataSchema,
  TypescriptAstNodeDataSchema,
]);

export type NodeData = z.infer<typeof NodeDataSchema>;

// Helper functions
export function validateNodeData(data: unknown): NodeData {
  return NodeDataSchema.parse(data);
}

export function isValidNodeData(data: unknown): data is NodeData {
  return NodeDataSchema.safeParse(data).success;
}

// Schema registry for dynamic validation
export const SchemaRegistry = {
  LLMService: LLMServiceSchema,
  APIServiceType: APIServiceTypeSchema,
  NotionOperation: NotionOperationSchema,
  ToolType: ToolTypeSchema,
  ExecutionStatus: ExecutionStatusSchema,
  NodeExecutionStatus: NodeExecutionStatusSchema,
  EventType: EventTypeSchema,
  NodeType: NodeTypeSchema,
  HandleDirection: HandleDirectionSchema,
  HandleLabel: HandleLabelSchema,
  DataType: DataTypeSchema,
  ForgettingMode: ForgettingModeSchema,
  MemoryView: MemoryViewSchema,
  DiagramFormat: DiagramFormatSchema,
  DBBlockSubType: DBBlockSubTypeSchema,
  ContentType: ContentTypeSchema,
  SupportedLanguage: SupportedLanguageSchema,
  HttpMethod: HttpMethodSchema,
  HookType: HookTypeSchema,
  HookTriggerMode: HookTriggerModeSchema,
  GraphQLDomainPersonType: GraphQLDomainPersonTypeSchema,
  StoreDiagram: StoreDiagramSchema,
  ToolConfig: ToolConfigSchema,
  WebSearchResult: WebSearchResultSchema,
  ImageGenerationResult: ImageGenerationResultSchema,
  ToolOutput: ToolOutputSchema,
  ChatResult: ChatResultSchema,
  LLMRequestOptions: LLMRequestOptionsSchema,
  TokenUsage: TokenUsageSchema,
  NodeState: NodeStateSchema,
  ExecutionState: ExecutionStateSchema,
  ExecutionOptions: ExecutionOptionsSchema,
  InteractivePromptData: InteractivePromptDataSchema,
  InteractiveResponse: InteractiveResponseSchema,
  ExecutionUpdate: ExecutionUpdateSchema,
  NodeDefinition: NodeDefinitionSchema,
  Vec2: Vec2Schema,
  DomainHandle: DomainHandleSchema,
  DomainNode: DomainNodeSchema,
  DomainArrow: DomainArrowSchema,
  MemoryConfig: MemoryConfigSchema,
  MemorySettings: MemorySettingsSchema,
  PersonLLMConfig: PersonLLMConfigSchema,
  DomainPerson: DomainPersonSchema,
  DomainApiKey: DomainApiKeySchema,
  DiagramMetadata: DiagramMetadataSchema,
  DomainDiagram: DomainDiagramSchema,
  BaseNodeData: BaseNodeDataSchema,
  StartNodeData: StartNodeDataSchema,
  ConditionNodeData: ConditionNodeDataSchema,
  PersonJobNodeData: PersonJobNodeDataSchema,
  EndpointNodeData: EndpointNodeDataSchema,
  DBNodeData: DBNodeDataSchema,
  JobNodeData: JobNodeDataSchema,
  CodeJobNodeData: CodeJobNodeDataSchema,
  ApiJobNodeData: ApiJobNodeDataSchema,
  UserResponseNodeData: UserResponseNodeDataSchema,
  NotionNodeData: NotionNodeDataSchema,
  HookNodeData: HookNodeDataSchema,
  TemplateJobNodeData: TemplateJobNodeDataSchema,
  ShellJobNodeData: ShellJobNodeDataSchema,
  JsonSchemaValidatorNodeData: JsonSchemaValidatorNodeDataSchema,
  TypescriptAstNodeData: TypescriptAstNodeDataSchema,
  SubDiagramNodeData: SubDiagramNodeDataSchema,
  Message: MessageSchema,
  ConversationMetadata: ConversationMetadataSchema,
  Conversation: ConversationSchema,
  MemoryState: MemoryStateSchema,
  SubDiagramNodeData: SubDiagramNodeDataSchema,
  HookNodeData: HookNodeDataSchema,
  TypescriptAstNodeData: TypescriptAstNodeDataSchema,
} as const;

// Export all schemas
export {
  LLMServiceSchema,
  APIServiceTypeSchema,
  NotionOperationSchema,
  ToolTypeSchema,
  ExecutionStatusSchema,
  NodeExecutionStatusSchema,
  EventTypeSchema,
  NodeTypeSchema,
  HandleDirectionSchema,
  HandleLabelSchema,
  DataTypeSchema,
  ForgettingModeSchema,
  MemoryViewSchema,
  DiagramFormatSchema,
  DBBlockSubTypeSchema,
  ContentTypeSchema,
  SupportedLanguageSchema,
  HttpMethodSchema,
  HookTypeSchema,
  HookTriggerModeSchema,
  GraphQLDomainPersonTypeSchema,
  StoreDiagramSchema,
  ToolConfigSchema,
  WebSearchResultSchema,
  ImageGenerationResultSchema,
  ToolOutputSchema,
  ChatResultSchema,
  LLMRequestOptionsSchema,
  TokenUsageSchema,
  NodeStateSchema,
  ExecutionStateSchema,
  ExecutionOptionsSchema,
  InteractivePromptDataSchema,
  InteractiveResponseSchema,
  ExecutionUpdateSchema,
  NodeDefinitionSchema,
  Vec2Schema,
  DomainHandleSchema,
  DomainNodeSchema,
  DomainArrowSchema,
  MemoryConfigSchema,
  MemorySettingsSchema,
  PersonLLMConfigSchema,
  DomainPersonSchema,
  DomainApiKeySchema,
  DiagramMetadataSchema,
  DomainDiagramSchema,
  BaseNodeDataSchema,
  StartNodeDataSchema,
  ConditionNodeDataSchema,
  PersonJobNodeDataSchema,
  EndpointNodeDataSchema,
  DBNodeDataSchema,
  JobNodeDataSchema,
  CodeJobNodeDataSchema,
  ApiJobNodeDataSchema,
  UserResponseNodeDataSchema,
  NotionNodeDataSchema,
  HookNodeDataSchema,
  TemplateJobNodeDataSchema,
  ShellJobNodeDataSchema,
  JsonSchemaValidatorNodeDataSchema,
  TypescriptAstNodeDataSchema,
  SubDiagramNodeDataSchema,
  MessageSchema,
  ConversationMetadataSchema,
  ConversationSchema,
  MemoryStateSchema,
  SubDiagramNodeDataSchema,
  HookNodeDataSchema,
  TypescriptAstNodeDataSchema,
};