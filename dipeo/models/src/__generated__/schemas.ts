/**
 * GENERATED FILE - DO NOT EDIT
 * Generated by DiPeO code generation
 * Generated at: 2025-10-04T17:03:16.886873
 *
 * Zod validation schemas for all node types.
 * These schemas are exported from @dipeo/models for use across the codebase.
 */

import { z } from 'zod';

// Node validation schemas
export const ApiJobSchema = z.object({
  url: z.string().describe("API endpoint URL"),
  method: z.any().describe("HTTP method"),
  headers: z.record(z.any()).optional().describe("HTTP headers"),
  params: z.record(z.any()).optional().describe("Query parameters"),
  body: z.record(z.any()).optional().describe("Request body"),
  timeout: z.number().optional().describe("Request timeout in seconds"),
  auth_type: z.any().optional().describe("Authentication type"),
  auth_config: z.record(z.any()).optional().describe("Authentication configuration")
});

export type ApiJobData = z.infer<typeof ApiJobSchema>;
export const CodeJobSchema = z.object({
  language: z.any().describe("Programming language"),
  filePath: z.string().optional().describe("Path to code file"),
  code: z.string().optional().describe("Inline code to execute (alternative to filePath)"),
  functionName: z.string().optional().describe("Function to execute"),
  timeout: z.number().optional().describe("Execution timeout in seconds")
});

export type CodeJobData = z.infer<typeof CodeJobSchema>;
export const ConditionSchema = z.object({
  condition_type: z.any().optional().describe("Type of condition to evaluate"),
  expression: z.string().optional().describe("Boolean expression to evaluate"),
  node_indices: z.any().optional().describe("Node indices for detect_max_iteration condition"),
  person: z.string().optional().describe("AI agent to use for decision making"),
  judge_by: z.string().optional().describe("Prompt for LLM to make a judgment"),
  judge_by_file: z.string().optional().describe("External prompt file path"),
  memorize_to: z.string().optional().describe("Memory control strategy (e.g., GOLDFISH for fresh evaluation)"),
  at_most: z.number().optional().describe("Maximum messages to keep in memory"),
  expose_index_as: z.string().optional().describe("Variable name to expose the condition node's execution count (0-based index) to downstream nodes"),
  skippable: z.boolean().optional().describe("When true, downstream nodes can execute even if this condition hasn't been evaluated yet")
});

export type ConditionData = z.infer<typeof ConditionSchema>;
export const DbSchema = z.object({
  file: z.any().optional().describe("File path or array of file paths"),
  collection: z.string().optional().describe("Database collection name"),
  sub_type: z.any().describe("Database operation type"),
  operation: z.string().describe("Operation configuration"),
  query: z.string().optional().describe("Query configuration"),
  keys: z.any().optional().describe("Single key or list of dot-separated keys to target within the JSON payload"),
  lines: z.any().optional().describe("Line selection or ranges to read (e.g., 1:120 or ['10:20'])"),
  data: z.record(z.any()).optional().describe("Data configuration"),
  serialize_json: z.boolean().optional().describe("Serialize structured data to JSON string (for backward compatibility)"),
  format: z.string().optional().describe("Data format (json, yaml, csv, text, etc.)")
});

export type DbData = z.infer<typeof DbSchema>;
export const DiffPatchSchema = z.object({
  target_path: z.string().describe("Path to the file to patch"),
  diff: z.string().describe("Unified diff content to apply"),
  format: z.any().optional().describe("Diff format type"),
  apply_mode: z.any().optional().describe("How to apply the patch"),
  backup: z.boolean().optional().describe("Create backup before patching"),
  validate_patch: z.boolean().optional().describe("Validate patch before applying"),
  backup_dir: z.string().optional().describe("Directory for backup files"),
  strip_level: z.number().min(0).max(10).optional().describe("Strip N leading path components (like patch -pN)"),
  fuzz_factor: z.number().min(0).max(100).optional().describe("Number of lines that can be ignored when matching context"),
  reject_file: z.string().optional().describe("Path to save rejected hunks"),
  ignore_whitespace: z.boolean().optional().describe("Ignore whitespace changes when matching"),
  create_missing: z.boolean().optional().describe("Create target file if it doesn't exist")
});

export type DiffPatchData = z.infer<typeof DiffPatchSchema>;
export const EndpointSchema = z.object({
  save_to_file: z.boolean().optional().describe("Save results to file"),
  file_name: z.string().optional().describe("Output filename")
});

export type EndpointData = z.infer<typeof EndpointSchema>;
export const HookSchema = z.object({
  hook_type: z.any().describe("Type of hook to execute"),
  command: z.string().optional().describe("Shell command to run (for shell hooks)"),
  url: z.string().regex(/^https?:\/\/.+/).optional().describe("Webhook URL (for HTTP hooks)"),
  timeout: z.number().min(1).max(300).optional().describe("Execution timeout in seconds"),
  retry_count: z.number().min(0).max(5).optional().describe("Number of retries on failure")
});

export type HookData = z.infer<typeof HookSchema>;
export const IntegratedApiSchema = z.object({
  provider: z.string().describe("API provider to connect to"),
  operation: z.string().describe("Operation to perform (provider-specific)"),
  resource_id: z.string().optional().describe("Resource identifier (e.g., page ID, channel ID)"),
  config: z.record(z.any()).optional().describe("Provider-specific configuration"),
  timeout: z.number().min(1).max(300).optional().describe("Request timeout in seconds"),
  max_retries: z.number().min(0).max(10).optional().describe("Maximum retry attempts")
});

export type IntegratedApiData = z.infer<typeof IntegratedApiSchema>;
export const IrBuilderSchema = z.object({
  builder_type: z.any().describe("Type of IR builder to use"),
  source_type: z.any().optional().describe("Type of source data"),
  config_path: z.string().optional().describe("Path to configuration directory"),
  output_format: z.any().optional().describe("Output format for IR"),
  cache_enabled: z.boolean().optional().describe("Enable IR caching"),
  validate_output: z.boolean().optional().describe("Validate IR structure before output")
});

export type IrBuilderData = z.infer<typeof IrBuilderSchema>;
export const JsonSchemaValidatorSchema = z.object({
  schema_path: z.string().optional().describe("Path to JSON schema file"),
  json_schema: z.record(z.any()).optional().describe("Inline JSON schema"),
  data_path: z.string().optional().describe("Data Path configuration"),
  strict_mode: z.boolean().optional().describe("Strict Mode configuration"),
  error_on_extra: z.boolean().optional().describe("Error On Extra configuration")
});

export type JsonSchemaValidatorData = z.infer<typeof JsonSchemaValidatorSchema>;
export const PersonJobSchema = z.object({
  person: z.string().optional().describe("AI person to use"),
  first_only_prompt: z.string().optional().describe("Prompt used only on first execution"),
  first_prompt_file: z.string().optional().describe("External prompt file for first iteration only"),
  default_prompt: z.string().optional().describe("Default prompt template"),
  prompt_file: z.string().optional().describe("Path to prompt file in /files/prompts/"),
  max_iteration: z.number().describe("Maximum execution iterations"),
  memorize_to: z.string().optional().describe("Criteria used to select helpful messages for this task. Empty = memorize all. Special: 'GOLDFISH' for goldfish mode. Comma-separated for multiple criteria."),
  at_most: z.number().min(1).max(500).optional().describe("Select at most N messages to keep (system messages may be preserved in addition)."),
  ignore_person: z.string().optional().describe("Comma-separated list of person IDs whose messages should be excluded from memory selection."),
  tools: z.string().optional().describe("Tools available to the AI agent"),
  text_format: z.string().optional().describe("JSON schema or response format for structured outputs"),
  text_format_file: z.string().optional().describe("Path to Python file containing Pydantic models for structured outputs"),
  resolved_prompt: z.string().optional().describe("Pre-resolved prompt content from compile-time"),
  resolved_first_prompt: z.string().optional().describe("Pre-resolved first prompt content from compile-time"),
  batch: z.boolean().optional().describe("Enable batch mode for processing multiple items"),
  batch_input_key: z.string().optional().describe("Key containing the array to iterate over in batch mode"),
  batch_parallel: z.boolean().optional().describe("Execute batch items in parallel"),
  max_concurrent: z.number().min(1).max(100).optional().describe("Maximum concurrent executions in batch mode")
});

export type PersonJobData = z.infer<typeof PersonJobSchema>;
export const StartSchema = z.object({
  trigger_mode: z.any().optional().describe("How this start node is triggered"),
  custom_data: z.any().optional().describe("Custom data to pass when manually triggered"),
  output_data_structure: z.record(z.any()).optional().describe("Expected output data structure"),
  hook_event: z.string().optional().describe("Event name to listen for"),
  hook_filters: z.record(z.any()).optional().describe("Filters to apply to incoming events")
});

export type StartData = z.infer<typeof StartSchema>;
export const SubDiagramSchema = z.object({
  diagram_name: z.string().optional().describe("Name of the diagram to execute (e.g., 'workflow/process')"),
  diagram_data: z.record(z.any()).optional().describe("Inline diagram data (alternative to diagram_name)"),
  input_mapping: z.record(z.any()).optional().describe("Map node inputs to sub-diagram variables"),
  output_mapping: z.record(z.any()).optional().describe("Map sub-diagram outputs to node outputs"),
  timeout: z.number().min(1).max(3600).optional().describe("Execution timeout in seconds"),
  wait_for_completion: z.boolean().optional().describe("Whether to wait for sub-diagram completion"),
  isolate_conversation: z.boolean().optional().describe("Create isolated conversation context for sub-diagram"),
  ignoreIfSub: z.boolean().optional().describe("Skip execution if this diagram is being run as a sub-diagram"),
  diagram_format: z.any().optional().describe("Format of the diagram file (yaml, json, or light)"),
  batch: z.boolean().optional().describe("Execute sub-diagram in batch mode for multiple inputs"),
  batch_input_key: z.string().optional().describe("Key in inputs containing the array of items for batch processing"),
  batch_parallel: z.boolean().optional().describe("Execute batch items in parallel")
});

export type SubDiagramData = z.infer<typeof SubDiagramSchema>;
export const TemplateJobSchema = z.object({
  template_path: z.string().optional().describe("Path to template file"),
  template_content: z.string().optional().describe("Inline template content"),
  output_path: z.string().optional().describe("Output file path"),
  variables: z.record(z.any()).optional().describe("Variables configuration"),
  engine: z.any().optional().describe("Template engine to use"),
  preprocessor: z.string().optional().describe("Preprocessor function to apply before templating")
});

export type TemplateJobData = z.infer<typeof TemplateJobSchema>;
export const TypescriptAstSchema = z.object({
  source: z.string().optional().describe("TypeScript source code to parse"),
  extractPatterns: z.any().optional().describe("Patterns to extract from the AST"),
  includeJSDoc: z.boolean().optional().describe("Include JSDoc comments in the extracted data"),
  parseMode: z.any().optional().describe("TypeScript parsing mode"),
  transformEnums: z.boolean().optional().describe("Transform enum definitions to a simpler format"),
  flattenOutput: z.boolean().optional().describe("Flatten the output structure for easier consumption"),
  outputFormat: z.any().optional().describe("Output format for the parsed data"),
  batch: z.boolean().optional().describe("Enable batch processing mode"),
  batchInputKey: z.string().optional().describe("Key to extract batch items from input")
});

export type TypescriptAstData = z.infer<typeof TypescriptAstSchema>;
export const UserResponseSchema = z.object({
  prompt: z.string().describe("Question to ask the user"),
  timeout: z.number().optional().describe("Response timeout in seconds")
});

export type UserResponseData = z.infer<typeof UserResponseSchema>;

// Export all schemas as a registry
export const nodeSchemas = {
  api_job: ApiJobSchema,
  code_job: CodeJobSchema,
  condition: ConditionSchema,
  db: DbSchema,
  diff_patch: DiffPatchSchema,
  endpoint: EndpointSchema,
  hook: HookSchema,
  integrated_api: IntegratedApiSchema,
  ir_builder: IrBuilderSchema,
  json_schema_validator: JsonSchemaValidatorSchema,
  person_job: PersonJobSchema,
  start: StartSchema,
  sub_diagram: SubDiagramSchema,
  template_job: TemplateJobSchema,
  typescript_ast: TypescriptAstSchema,
  user_response: UserResponseSchema
} as const;

// Type for node type keys
export type NodeSchemaKey = keyof typeof nodeSchemas;

// Export validation helper
export function validateNodeData<T extends NodeSchemaKey>(
  nodeType: T,
  data: unknown
): z.infer<typeof nodeSchemas[T]> {
  return nodeSchemas[nodeType].parse(data);
}

// Safe validation that returns result instead of throwing
export function safeValidateNodeData<T extends NodeSchemaKey>(
  nodeType: T,
  data: unknown
): z.SafeParseReturnType<unknown, z.infer<typeof nodeSchemas[T]>> {
  return nodeSchemas[nodeType].safeParse(data);
}

// Get schema for a node type
export function getNodeSchema(nodeType: NodeSchemaKey) {
  return nodeSchemas[nodeType];
}
