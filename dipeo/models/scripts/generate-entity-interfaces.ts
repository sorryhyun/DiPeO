/**
 * Generate TypeScript interfaces from entity definitions
 * These interfaces will be processed by generate-schema.ts to create Python models
 */

import { EntityDefinition } from '../src/entity-config';
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Generate TypeScript interface for an entity
 */
export function generateEntityInterface(entity: EntityDefinition): string {
  const lines: string[] = [];
  
  // Add header comment
  lines.push(`/**`);
  lines.push(` * Domain model for ${entity.name}`);
  lines.push(` * Auto-generated from entity definition`);
  lines.push(` */`);
  
  // Generate main interface
  lines.push(`export interface ${entity.name} {`);
  
  // Add fields
  for (const [fieldName, field] of Object.entries(entity.fields)) {
    const optional = field.nullable || !field.required ? '?' : '';
    const nullUnion = field.nullable ? ' | null' : '';
    
    // Map field types to TypeScript types
    let tsType: string;
    if (field.type === 'Date') {
      tsType = 'string'; // ISO date string for JSON serialization
    } else if (field.type === 'JSON') {
      tsType = 'Record<string, any>';
    } else {
      tsType = field.type;
    }
    
    lines.push(`  ${fieldName}${optional}: ${tsType}${nullUnion};`);
  }
  
  lines.push(`}`);
  lines.push('');
  
  // Generate input types if needed
  if (entity.operations.create && typeof entity.operations.create === 'object') {
    lines.push(`export interface Create${entity.name}Input {`);
    for (const fieldName of entity.operations.create.input) {
      const field = entity.fields[fieldName];
      
      // Check if it's a relation field (e.g., ownerId -> owner relation)
      let relationField = null;
      if (!field && fieldName.endsWith('Id')) {
        const relationName = fieldName.slice(0, -2); // Remove 'Id' suffix
        const relation = entity.relations?.[relationName];
        if (relation) {
          relationField = relation;
        }
      }
      
      if (!field && !relationField) continue;
      
      if (field) {
        const optional = !field.required ? '?' : '';
        let tsType: string;
        if (field.type === 'Date') {
          tsType = 'string';
        } else if (field.type === 'JSON') {
          tsType = 'Record<string, any>';
        } else {
          tsType = field.type;
        }
        lines.push(`  ${fieldName}${optional}: ${tsType};`);
      } else if (relationField) {
        // Handle relation field
        const optional = !relationField.required ? '?' : '';
        const tsType = `${relationField.type}ID`;
        lines.push(`  ${fieldName}${optional}: ${tsType};`);
      }
    }
    lines.push(`}`);
    lines.push('');
  }
  
  if (entity.operations.update && typeof entity.operations.update === 'object') {
    lines.push(`export interface Update${entity.name}Input {`);
    lines.push(`  id: ${entity.name}ID;`);
    
    const updateConfig = entity.operations.update;
    for (const fieldName of updateConfig.input) {
      const field = entity.fields[fieldName];
      
      // Check if it's a relation field (e.g., ownerId -> owner relation)
      let relationField = null;
      if (!field && fieldName.endsWith('Id')) {
        const relationName = fieldName.slice(0, -2); // Remove 'Id' suffix
        const relation = entity.relations?.[relationName];
        if (relation) {
          relationField = relation;
        }
      }
      
      if (!field && !relationField) continue;
      
      if (field) {
        // Update operations are usually partial
        const optional = updateConfig.partial ? '?' : (!field.required ? '?' : '');
        let tsType: string;
        if (field.type === 'Date') {
          tsType = 'string';
        } else if (field.type === 'JSON') {
          tsType = 'Record<string, any>';
        } else {
          tsType = field.type;
        }
        lines.push(`  ${fieldName}${optional}: ${tsType};`);
      } else if (relationField) {
        // Handle relation field - always optional in updates
        const tsType = `${relationField.type}ID`;
        lines.push(`  ${fieldName}?: ${tsType};`);
      }
    }
    lines.push(`}`);
    lines.push('');
  }
  
  // Generate result type
  lines.push(`export interface ${entity.name}Result {`);
  lines.push(`  success: boolean;`);
  lines.push(`  message?: string;`);
  lines.push(`  error?: string;`);
  lines.push(`  ${entity.name.toLowerCase()}?: ${entity.name};`);
  lines.push(`}`);
  
  return lines.join('\n');
}

/**
 * Generate a single TypeScript file with all entity interfaces
 */
export async function generateEntityInterfacesFile(
  entities: EntityDefinition[],
  outputPath: string
): Promise<void> {
  const lines: string[] = [];
  
  // Add header
  lines.push(`/**`);
  lines.push(` * Auto-generated entity interfaces`);
  lines.push(` * DO NOT EDIT THIS FILE DIRECTLY`);
  lines.push(` */`);
  lines.push('');
  
  // Import branded types if needed
  const brandedTypes = new Set<string>();
  for (const entity of entities) {
    // Check fields for branded types
    for (const field of Object.values(entity.fields)) {
      if (field.type.endsWith('ID')) {
        brandedTypes.add(field.type);
      }
    }
    
    // Check relations for branded types
    if (entity.relations) {
      for (const relation of Object.values(entity.relations)) {
        const relationIdType = `${relation.type}ID`;
        brandedTypes.add(relationIdType);
      }
    }
  }
  
  if (brandedTypes.size > 0) {
    lines.push(`// Import branded types`);
    for (const type of brandedTypes) {
      lines.push(`export type ${type} = string & { readonly __brand: '${type}' };`);
    }
    lines.push('');
  }
  
  // Generate interfaces for each entity
  for (const entity of entities) {
    lines.push(generateEntityInterface(entity));
    lines.push('');
  }
  
  // Write file
  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, lines.join('\n'), 'utf-8');
  
  console.log(`âœ… Generated entity interfaces: ${outputPath}`);
}

// Export for use in main generator
export { generateEntityInterfacesFile as generateEntityInterfaces };