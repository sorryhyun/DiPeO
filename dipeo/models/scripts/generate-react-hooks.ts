/**
 * React Hooks Generator
 * Generates React hooks for GraphQL operations from entity definitions
 */

import { EntityDefinition } from '../src/entity-config';
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Generate all hooks for an entity
 */
export async function generateHooks(entity: EntityDefinition): Promise<string> {
  const imports = generateImports(entity);
  const hooks: string[] = [];
  
  // Generate individual operation hooks
  if (entity.operations.create) {
    hooks.push(generateCreateHook(entity));
  }
  
  if (entity.operations.update) {
    hooks.push(generateUpdateHook(entity));
  }
  
  if (entity.operations.delete) {
    hooks.push(generateDeleteHook(entity));
  }
  
  // Generate query hooks are typically generated by GraphQL codegen
  // But we'll add references here
  hooks.push(generateQueryHookExports(entity));
  
  // Generate the composite operations hook
  hooks.push(generateOperationsHook(entity));
  
  return `/**
 * Auto-generated React hooks for ${entity.name} operations
 * Do not edit this file directly. It is generated from the entity definition.
 */

${imports}

${hooks.join('\n\n')}
`;
}

/**
 * Generate imports
 */
function generateImports(entity: EntityDefinition): string {
  const imports = [
    `import { createEntityMutation } from '@/core/graphql/createEntityMutation';`,
    `import { createResponseHandler } from '@/core/graphql/createResponseHandler';`,
    `import {`,
    `  useGet${entity.plural}Query,`,
    `  useGet${entity.name}Query,`,
  ];
  
  if (entity.operations.create) {
    imports.push(`  useCreate${entity.name}Mutation,`);
    imports.push(`  Create${entity.name}Document,`);
  }
  
  if (entity.operations.update) {
    imports.push(`  useUpdate${entity.name}Mutation,`);
    imports.push(`  Update${entity.name}Document,`);
  }
  
  if (entity.operations.delete) {
    imports.push(`  useDelete${entity.name}Mutation,`);
    imports.push(`  Delete${entity.name}Document,`);
  }
  
  imports.push(`  Get${entity.plural}Document,`);
  imports.push(`} from '@/__generated__/graphql';`);
  imports.push(`import type {`);
  imports.push(`  ${entity.name},`);
  imports.push(`  Create${entity.name}Input,`);
  imports.push(`  Update${entity.name}Input,`);
  imports.push(`} from '@/__generated__/graphql';`);
  
  return imports.join('\n');
}

/**
 * Generate create mutation hook
 */
function generateCreateHook(entity: EntityDefinition): string {
  const hookName = `useCreate${entity.name}`;
  
  return `/**
 * Hook for creating a new ${entity.name}
 * @generated
 */
export const ${hookName} = createEntityMutation({
  entityName: '${entity.name}',
  entityNamePlural: '${entity.plural}',
  document: Create${entity.name}Document,
  successMessage: (data) => data?.create${entity.name}.message || '${entity.name} created successfully',
  errorMessage: (data) => data?.create${entity.name}.error || 'Failed to create ${entity.name}',
  options: {
    refetchQueries: [
      { query: Get${entity.plural}Document }
    ],
    awaitRefetchQueries: true,
    update: (cache, { data }) => {
      if (!data?.create${entity.name}.success || !data.create${entity.name}.${entity.name.toLowerCase()}) {
        return;
      }
      
      // Update the list cache
      try {
        const existingData = cache.readQuery({ 
          query: Get${entity.plural}Document 
        });
        
        if (existingData?.${entity.plural}) {
          cache.writeQuery({
            query: Get${entity.plural}Document,
            data: {
              ${entity.plural}: [...existingData.${entity.plural}, data.create${entity.name}.${entity.name.toLowerCase()}]
            }
          });
        }
      } catch (e) {
        // Cache might not exist yet
      }
    }
  }
});`;
}

/**
 * Generate update mutation hook
 */
function generateUpdateHook(entity: EntityDefinition): string {
  const hookName = `useUpdate${entity.name}`;
  
  return `/**
 * Hook for updating an existing ${entity.name}
 * @generated
 */
export const ${hookName} = createEntityMutation({
  entityName: '${entity.name}',
  entityNamePlural: '${entity.plural}',
  document: Update${entity.name}Document,
  successMessage: (data) => data?.update${entity.name}.message || '${entity.name} updated successfully',
  errorMessage: (data) => data?.update${entity.name}.error || 'Failed to update ${entity.name}',
  options: {
    refetchQueries: [
      { query: Get${entity.plural}Document }
    ],
    optimisticResponse: ({ id, input }) => ({
      update${entity.name}: {
        __typename: '${entity.name}Result',
        success: true,
        ${entity.name.toLowerCase()}: {
          __typename: '${entity.name}',
          id,
          ...input,
          updatedAt: new Date().toISOString()
        },
        message: 'Updating...',
        error: null
      }
    })
  }
});`;
}

/**
 * Generate delete mutation hook
 */
function generateDeleteHook(entity: EntityDefinition): string {
  const hookName = `useDelete${entity.name}`;
  
  return `/**
 * Hook for deleting a ${entity.name}
 * @generated
 */
export const ${hookName} = createEntityMutation({
  entityName: '${entity.name}',
  entityNamePlural: '${entity.plural}',
  document: Delete${entity.name}Document,
  successMessage: (data) => data?.delete${entity.name}.message || '${entity.name} deleted successfully',
  errorMessage: (data) => data?.delete${entity.name}.error || 'Failed to delete ${entity.name}',
  options: {
    refetchQueries: [
      { query: Get${entity.plural}Document }
    ],
    update: (cache, { data }) => {
      if (!data?.delete${entity.name}.success || !data.delete${entity.name}.deleted_id) {
        return;
      }
      
      // Remove from cache
      cache.evict({
        id: cache.identify({ __typename: '${entity.name}', id: data.delete${entity.name}.deleted_id })
      });
      cache.gc();
    }
  }
});`;
}

/**
 * Generate exports for query hooks (generated by GraphQL codegen)
 */
function generateQueryHookExports(entity: EntityDefinition): string {
  return `// Query hooks are generated by GraphQL codegen
export { useGet${entity.plural}Query, useGet${entity.name}Query } from '@/__generated__/graphql';`;
}

/**
 * Generate composite operations hook
 */
function generateOperationsHook(entity: EntityDefinition): string {
  const { name, plural, operations } = entity;
  
  return `/**
 * Composite hook for all ${name} operations
 * Provides a unified interface for CRUD operations with loading states
 * @generated
 */
export const use${name}Operations = () => {
  // Queries
  const {
    data: listData,
    loading: loadingList,
    error: listError,
    refetch: refetchList
  } = useGet${plural}Query({
    fetchPolicy: 'cache-and-network',
    notifyOnNetworkStatusChange: true
  });
  
  // Mutations
${operations.create ? `  const [create${name}Mutation, { loading: creating }] = useCreate${name}Mutation();` : ''}
${operations.update ? `  const [update${name}Mutation, { loading: updating }] = useUpdate${name}Mutation();` : ''}
${operations.delete ? `  const [delete${name}Mutation, { loading: deleting }] = useDelete${name}Mutation();` : ''}
  
  // Operation handlers with error handling
  const handlers = {
${operations.create ? `    create: async (input: Create${name}Input) => {
      try {
        const result = await create${name}Mutation({
          variables: { input }
        });
        return result.data?.create${name};
      } catch (error) {
        console.error('Failed to create ${name}:', error);
        throw error;
      }
    },` : ''}
    
${operations.update ? `    update: async (id: string, input: Update${name}Input) => {
      try {
        const result = await update${name}Mutation({
          variables: { id, input }
        });
        return result.data?.update${name};
      } catch (error) {
        console.error('Failed to update ${name}:', error);
        throw error;
      }
    },` : ''}
    
${operations.delete ? `    delete: async (id: string) => {
      try {
        const result = await delete${name}Mutation({
          variables: { id }
        });
        return result.data?.delete${name};
      } catch (error) {
        console.error('Failed to delete ${name}:', error);
        throw error;
      }
    },` : ''}
    
    refetch: refetchList
  };
  
  return {
    // Data
    ${plural}: listData?.${plural} || [],
    
    // Loading states
    loading: loadingList,
${operations.create ? '    creating,' : ''}
${operations.update ? '    updating,' : ''}
${operations.delete ? '    deleting,' : ''}
    
    // Error states
    error: listError,
    
    // Operations
    ...handlers,
    
    // Computed properties
    isEmpty: !loadingList && (!listData?.${plural} || listData.${plural}.length === 0),
    count: listData?.${plural}?.length || 0
  };
};

/**
 * Hook for single ${name} operations
 * @generated
 */
export const use${name} = (id: string) => {
  const {
    data,
    loading,
    error,
    refetch
  } = useGet${name}Query({
    variables: { id },
    skip: !id,
    fetchPolicy: 'cache-and-network'
  });
  
${operations.update ? `  const [update${name}Mutation, { loading: updating }] = useUpdate${name}Mutation();` : ''}
${operations.delete ? `  const [delete${name}Mutation, { loading: deleting }] = useDelete${name}Mutation();` : ''}
  
  const handlers = {
${operations.update ? `    update: async (input: Update${name}Input) => {
      if (!id) return;
      try {
        const result = await update${name}Mutation({
          variables: { id, input }
        });
        return result.data?.update${name};
      } catch (error) {
        console.error('Failed to update ${name}:', error);
        throw error;
      }
    },` : ''}
    
${operations.delete ? `    delete: async () => {
      if (!id) return;
      try {
        const result = await delete${name}Mutation({
          variables: { id }
        });
        return result.data?.delete${name};
      } catch (error) {
        console.error('Failed to delete ${name}:', error);
        throw error;
      }
    },` : ''}
    
    refetch
  };
  
  return {
    // Data
    ${name.toLowerCase()}: data?.${name.toLowerCase()} || null,
    
    // Loading states
    loading,
${operations.update ? '    updating,' : ''}
${operations.delete ? '    deleting,' : ''}
    
    // Error states
    error,
    
    // Operations
    ...handlers,
    
    // Computed properties
    exists: !loading && !!data?.${name.toLowerCase()}
  };
};`;
}

/**
 * Generate GraphQL documents for the entity
 */
export async function generateGraphQLDocuments(entity: EntityDefinition): Promise<string> {
  const documents: string[] = [];
  
  // Fragments
  documents.push(generateFragment(entity));
  
  // Queries
  if (entity.operations.get) {
    documents.push(generateGetQuery(entity));
  }
  if (entity.operations.list) {
    documents.push(generateListQuery(entity));
  }
  
  // Mutations
  if (entity.operations.create) {
    documents.push(generateCreateMutation(entity));
  }
  if (entity.operations.update) {
    documents.push(generateUpdateMutation(entity));
  }
  if (entity.operations.delete) {
    documents.push(generateDeleteMutation(entity));
  }
  
  return documents.join('\n\n');
}

/**
 * Generate GraphQL fragment
 */
function generateFragment(entity: EntityDefinition): string {
  const fields = Object.entries(entity.fields)
    .filter(([_, config]) => !config.generated || ['id', 'createdAt', 'updatedAt'].includes(_))
    .map(([name]) => name);
    
  return `# Auto-generated GraphQL documents for ${entity.name}

fragment ${entity.name}Fields on ${entity.name} {
  ${fields.join('\n  ')}
}`;
}

/**
 * Generate get query document
 */
function generateGetQuery(entity: EntityDefinition): string {
  return `query Get${entity.name}($id: ID!) {
  ${entity.name.toLowerCase()}(id: $id) {
    ...${entity.name}Fields
  }
}`;
}

/**
 * Generate list query document
 */
function generateListQuery(entity: EntityDefinition): string {
  const config = typeof entity.operations.list === 'object' ? entity.operations.list : {};
  const params: string[] = [];
  
  if (config.pagination) {
    params.push('$page: Int = 1');
    params.push(`$pageSize: Int = ${config.defaultPageSize || 20}`);
  }
  
  if (config.filters) {
    config.filters.forEach(filter => {
      params.push(`$filter${filter.charAt(0).toUpperCase() + filter.slice(1)}: String`);
    });
  }
  
  if (config.sortable) {
    params.push('$sortBy: String');
    params.push('$sortOrder: String = "asc"');
  }
  
  return `query Get${entity.plural}${params.length ? `(${params.join(', ')})` : ''} {
  ${entity.plural}${params.length ? '(' : ''}${
    config.pagination ? 'page: $page, pageSize: $pageSize' : ''
  }${config.filters ? config.filters.map(f => `, filter${f.charAt(0).toUpperCase() + f.slice(1)}: $filter${f.charAt(0).toUpperCase() + f.slice(1)}`).join('') : ''}${
    config.sortable ? ', sortBy: $sortBy, sortOrder: $sortOrder' : ''
  }${params.length ? ')' : ''} {
    ...${entity.name}Fields
  }
}`;
}

/**
 * Generate create mutation document
 */
function generateCreateMutation(entity: EntityDefinition): string {
  return `mutation Create${entity.name}($input: Create${entity.name}Input!) {
  create${entity.name}(input: $input) {
    success
    message
    error
    ${entity.name.toLowerCase()} {
      ...${entity.name}Fields
    }
  }
}`;
}

/**
 * Generate update mutation document
 */
function generateUpdateMutation(entity: EntityDefinition): string {
  return `mutation Update${entity.name}($id: ID!, $input: Update${entity.name}Input!) {
  update${entity.name}(id: $id, input: $input) {
    success
    message
    error
    ${entity.name.toLowerCase()} {
      ...${entity.name}Fields
    }
  }
}`;
}

/**
 * Generate delete mutation document
 */
function generateDeleteMutation(entity: EntityDefinition): string {
  return `mutation Delete${entity.name}($id: ID!) {
  delete${entity.name}(id: $id) {
    success
    message
    error
    deletedId
  }
}`;
}