"""
Generated Pydantic models from TypeScript definitions.
DO NOT EDIT - This file is automatically generated.
"""

# Standard library imports
from typing import Any, Dict, Literal, Optional, Union
from enum import Enum

# Third-party imports
from pydantic import BaseModel, Field, field_validator, model_validator
from pydantic import BaseModel, Field

# Local imports
from dipeo.models import ApiKeyID, ArrowID, DiagramID, ExecutionID, ExecutionStatus, HandleID, LLMService, NodeExecutionStatus, NodeID, NodeType, PersonID

# Type aliases
PersonMemoryMessage = Message
PersonMemoryState = MemoryState
PersonMemoryConfig = MemoryConfig
PersonBatchJobNodeData = PersonJobNodeData
LLMService = Any
APIServiceType = Any
NotionOperation = Any
ToolType = Any
ExecutionStatus = Any
NodeExecutionStatus = Any
EventType = Any
NodeType = Any
HandleDirection = Any
HandleLabel = Any
DataType = Any
ForgettingMode = Any
MemoryView = Any
DiagramFormat = Any
DBBlockSubType = Any
ContentType = Any
SupportedLanguage = Any
HttpMethod = Any
HookType = Any
HookTriggerMode = Any
GraphQLDomainPersonType = Any
StoreDiagram = Any
ToolConfig = Any
WebSearchResult = Any
ImageGenerationResult = Any
ToolOutput = Any
ChatResult = Any
LLMRequestOptions = Any
TokenUsage = Any
NodeState = Any
ExecutionState = Any
ExecutionOptions = Any
InteractivePromptData = Any
InteractiveResponse = Any
ExecutionUpdate = Any
NodeDefinition = Any
Vec2 = Any
DomainHandle = Any
DomainNode = Any
DomainArrow = Any
MemoryConfig = Any
MemorySettings = Any
PersonLLMConfig = Any
DomainPerson = Any
DomainApiKey = Any
DiagramMetadata = Any
DomainDiagram = Any
BaseNodeData = Any
StartNodeData = Any
ConditionNodeData = Any
PersonJobNodeData = Any
EndpointNodeData = Any
DBNodeData = Any
JobNodeData = Any
CodeJobNodeData = Any
ApiJobNodeData = Any
UserResponseNodeData = Any
NotionNodeData = Any
HookNodeData = Any
TemplateJobNodeData = Any
ShellJobNodeData = Any
JsonSchemaValidatorNodeData = Any
TypescriptAstNodeData = Any
SubDiagramNodeData = Any
Message = Any
ConversationMetadata = Any
Conversation = Any
MemoryState = Any
NodeData = Any


# Enums
class LLMService(str, Enum):
    """LLMService enumeration."""
    OPENAI = "openai"
    ANTHROPIC = "anthropic"
    GOOGLE = "google"
    BEDROCK = "bedrock"
    VERTEX = "vertex"
    DEEPSEEK = "deepseek"

class APIServiceType(str, Enum):
    """APIServiceType enumeration."""
    OPENAI = "openai"
    ANTHROPIC = "anthropic"
    GOOGLE = "google"
    GEMINI = "gemini"
    BEDROCK = "bedrock"
    VERTEX = "vertex"
    DEEPSEEK = "deepseek"
    NOTION = "notion"
    GOOGLE_SEARCH = "google_search"
    SLACK = "slack"
    GITHUB = "github"
    JIRA = "jira"

class NotionOperation(str, Enum):
    """NotionOperation enumeration."""
    CREATE_PAGE = "create_page"
    UPDATE_PAGE = "update_page"
    READ_PAGE = "read_page"
    DELETE_PAGE = "delete_page"
    CREATE_DATABASE = "create_database"
    QUERY_DATABASE = "query_database"
    UPDATE_DATABASE = "update_database"

class ToolType(str, Enum):
    """ToolType enumeration."""
    WEB_SEARCH = "web_search"
    WEB_SEARCH_PREVIEW = "web_search_preview"
    IMAGE_GENERATION = "image_generation"

class ExecutionStatus(str, Enum):
    """ExecutionStatus enumeration."""
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    PAUSED = "PAUSED"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    ABORTED = "ABORTED"
    SKIPPED = "SKIPPED"

class NodeExecutionStatus(str, Enum):
    """NodeExecutionStatus enumeration."""
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    PAUSED = "PAUSED"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    ABORTED = "ABORTED"
    SKIPPED = "SKIPPED"
    MAXITER_REACHED = "MAXITER_REACHED"

class EventType(str, Enum):
    """EventType enumeration."""
    EXECUTION_STATUS_CHANGED = "EXECUTION_STATUS_CHANGED"
    NODE_STATUS_CHANGED = "NODE_STATUS_CHANGED"
    NODE_PROGRESS = "NODE_PROGRESS"
    INTERACTIVE_PROMPT = "INTERACTIVE_PROMPT"
    INTERACTIVE_RESPONSE = "INTERACTIVE_RESPONSE"
    EXECUTION_ERROR = "EXECUTION_ERROR"
    EXECUTION_UPDATE = "EXECUTION_UPDATE"

class NodeType(str, Enum):
    """NodeType enumeration."""
    START = "start"
    PERSON_JOB = "person_job"
    CONDITION = "condition"
    JOB = "job"
    CODE_JOB = "code_job"
    API_JOB = "api_job"
    ENDPOINT = "endpoint"
    DB = "db"
    USER_RESPONSE = "user_response"
    NOTION = "notion"
    PERSON_BATCH_JOB = "person_batch_job"
    HOOK = "hook"
    TEMPLATE_JOB = "template_job"
    JSON_SCHEMA_VALIDATOR = "json_schema_validator"
    TYPESCRIPT_AST = "typescript_ast"
    SUB_DIAGRAM = "sub_diagram"

class HandleDirection(str, Enum):
    """HandleDirection enumeration."""
    INPUT = "input"
    OUTPUT = "output"

class HandleLabel(str, Enum):
    """HandleLabel enumeration."""
    DEFAULT = "default"
    FIRST = "first"
    CONDITION_TRUE = "condtrue"
    CONDITION_FALSE = "condfalse"
    SUCCESS = "success"
    ERROR = "error"

class DataType(str, Enum):
    """DataType enumeration."""
    ANY = "any"
    STRING = "string"
    NUMBER = "number"
    BOOLEAN = "boolean"
    OBJECT = "object"
    ARRAY = "array"

class ForgettingMode(str, Enum):
    """ForgettingMode enumeration."""
    NO_FORGET = "no_forget"
    ON_EVERY_TURN = "on_every_turn"
    UPON_REQUEST = "upon_request"

class MemoryView(str, Enum):
    """MemoryView enumeration."""
    ALL_INVOLVED = "all_involved"
    SENT_BY_ME = "sent_by_me"
    SENT_TO_ME = "sent_to_me"
    SYSTEM_AND_ME = "system_and_me"
    CONVERSATION_PAIRS = "conversation_pairs"
    ALL_MESSAGES = "all_messages"

class DiagramFormat(str, Enum):
    """DiagramFormat enumeration."""
    NATIVE = "native"
    LIGHT = "light"
    READABLE = "readable"

class DBBlockSubType(str, Enum):
    """DBBlockSubType enumeration."""
    FIXED_PROMPT = "fixed_prompt"
    FILE = "file"
    CODE = "code"
    API_TOOL = "api_tool"

class ContentType(str, Enum):
    """ContentType enumeration."""
    RAW_TEXT = "raw_text"
    CONVERSATION_STATE = "conversation_state"
    OBJECT = "object"

class SupportedLanguage(str, Enum):
    """SupportedLanguage enumeration."""
    PYTHON = "python"
    TYPESCRIPT = "typescript"
    BASH = "bash"
    SHELL = "shell"

class HttpMethod(str, Enum):
    """HttpMethod enumeration."""
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"
    PATCH = "PATCH"

class HookType(str, Enum):
    """HookType enumeration."""
    SHELL = "shell"
    WEBHOOK = "webhook"
    PYTHON = "python"
    FILE = "file"

class HookTriggerMode(str, Enum):
    """HookTriggerMode enumeration."""
    MANUAL = "manual"
    HOOK = "hook"


# Models
class GraphQLDomainPersonType(BaseModel):
    """GraphQLDomainPersonType model."""
    # Fields
    id: str
    label: str
    llm_config: PersonLLMConfig
    type: str
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class StoreDiagram(BaseModel):
    """StoreDiagram model."""
    # Fields
    nodes: Dict[NodeID, DomainNode]
    handles: Dict[HandleID, DomainHandle]
    arrows: Dict[ArrowID, DomainArrow]
    persons: Dict[PersonID, DomainPerson]
    metadata: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class ToolConfig(BaseModel):
    """ToolConfig model."""
    # Fields
    type: ToolType
    enabled: Optional[bool] = Field(default=None)
    config: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class WebSearchResult(BaseModel):
    """WebSearchResult model."""
    # Fields
    url: str
    title: str
    snippet: str
    score: Optional[float] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class ImageGenerationResult(BaseModel):
    """ImageGenerationResult model."""
    # Fields
    image_data: str
    format: str
    width: Optional[float] = Field(default=None)
    height: Optional[float] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class ToolOutput(BaseModel):
    """ToolOutput model."""
    # Fields
    type: ToolType
    result: Any
    raw_response: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class ChatResult(BaseModel):
    """ChatResult model."""
    # Fields
    text: str
    token_usage: Optional[Any] = Field(default=None)
    raw_response: Optional[Any] = Field(default=None)
    tool_outputs: Optional[{} | null | undefined] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class LLMRequestOptions(BaseModel):
    """LLMRequestOptions model."""
    # Fields
    temperature: Optional[float] = Field(default=None)
    max_tokens: Optional[float] = Field(default=None)
    top_p: Optional[float] = Field(default=None)
    n: Optional[float] = Field(default=None)
    tools: Optional[{} | undefined] = Field(default=None)
    response_format: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class TokenUsage(BaseModel):
    """TokenUsage model."""
    # Fields
    input: float
    output: float
    cached: Optional[float] = Field(default=None)
    total: Optional[float] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class NodeState(BaseModel):
    """NodeState model."""
    # Fields
    status: NodeExecutionStatus
    started_at: Optional[str] = Field(default=None)
    ended_at: Optional[str] = Field(default=None)
    error: Optional[str] = Field(default=None)
    token_usage: Optional[Any] = Field(default=None)
    output: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class ExecutionState(BaseModel):
    """ExecutionState model."""
    # Fields
    id: ExecutionID
    status: ExecutionStatus
    diagram_id: Optional[Any] = Field(default=None)
    started_at: str
    ended_at: Optional[str] = Field(default=None)
    node_states: Dict[str, NodeState]
    node_outputs: Dict[str, Dict[str, Any]]
    token_usage: TokenUsage
    error: Optional[str] = Field(default=None)
    variables: Optional[Any] = Field(default=None)
    duration_seconds: Optional[float] = Field(default=None)
    is_active: Optional[bool] = Field(default=None)
    exec_counts: Dict[str, float]
    executed_nodes: Dict[str, Any]
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class ExecutionOptions(BaseModel):
    """ExecutionOptions model."""
    # Fields
    mode: Optional[Union[Literal["normal"], Literal["debug"], Literal["monitor"], None]] = Field(default=None)
    timeout: Optional[float] = Field(default=None)
    variables: Optional[Any] = Field(default=None)
    debug: Optional[bool] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class InteractivePromptData(BaseModel):
    """InteractivePromptData model."""
    # Fields
    node_id: NodeID
    prompt: str
    timeout: Optional[float] = Field(default=None)
    default_value: Optional[str] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class InteractiveResponse(BaseModel):
    """InteractiveResponse model."""
    # Fields
    node_id: NodeID
    response: str
    timestamp: str
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class ExecutionUpdate(BaseModel):
    """ExecutionUpdate model."""
    # Fields
    type: EventType
    execution_id: ExecutionID
    node_id: Optional[Any] = Field(default=None)
    status: Optional[NodeExecutionStatus] = Field(default=None)
    result: Optional[Any] = Field(default=None)
    error: Optional[str] = Field(default=None)
    timestamp: Optional[str] = Field(default=None)
    total_tokens: Optional[float] = Field(default=None)
    node_type: Optional[str] = Field(default=None)
    tokens: Optional[float] = Field(default=None)
    data: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class NodeDefinition(BaseModel):
    """NodeDefinition model."""
    # Fields
    type: str
    node_schema: Any
    handler: Any
    requires_services: Optional[{} | undefined] = Field(default=None)
    description: Optional[str] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class Vec2(BaseModel):
    """Vec2 model."""
    # Fields
    x: float
    y: float
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class DomainHandle(BaseModel):
    """DomainHandle model."""
    # Fields
    id: HandleID
    node_id: NodeID
    label: HandleLabel
    direction: HandleDirection
    data_type: DataType
    position: Optional[str] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class DomainNode(BaseModel):
    """DomainNode model."""
    # Fields
    id: NodeID
    type: NodeType
    position: Vec2
    data: Dict[str, Any]
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class DomainArrow(BaseModel):
    """DomainArrow model."""
    # Fields
    id: ArrowID
    source: HandleID
    target: HandleID
    content_type: Optional[ContentType] = Field(default=None)
    label: Optional[str] = Field(default=None)
    data: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class MemoryConfig(BaseModel):
    """MemoryConfig model."""
    # Fields
    forget_mode: Optional[ForgettingMode] = Field(default=None)
    max_messages: Optional[float] = Field(default=None)
    temperature: Optional[float] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class MemorySettings(BaseModel):
    """MemorySettings model."""
    # Fields
    view: MemoryView
    max_messages: Optional[float] = Field(default=None)
    preserve_system: Optional[bool] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class PersonLLMConfig(BaseModel):
    """PersonLLMConfig model."""
    # Fields
    service: LLMService
    model: str
    api_key_id: ApiKeyID
    system_prompt: Optional[str] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class DomainPerson(BaseModel):
    """DomainPerson model."""
    # Fields
    id: PersonID
    label: str
    llm_config: PersonLLMConfig
    type: Literal["person"]
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class DomainApiKey(BaseModel):
    """DomainApiKey model."""
    # Fields
    id: ApiKeyID
    label: str
    service: APIServiceType
    key: Optional[str] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class DiagramMetadata(BaseModel):
    """DiagramMetadata model."""
    # Fields
    id: Optional[Any] = Field(default=None)
    name: Optional[str] = Field(default=None)
    description: Optional[str] = Field(default=None)
    version: str
    created: str
    modified: str
    author: Optional[str] = Field(default=None)
    tags: Optional[{} | null | undefined] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class DomainDiagram(BaseModel):
    """DomainDiagram model."""
    # Fields
    nodes: Dict[str, Any]
    handles: Dict[str, Any]
    arrows: Dict[str, Any]
    persons: Dict[str, Any]
    metadata: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class BaseNodeData(BaseModel):
    """BaseNodeData model."""
    # Fields
    label: str
    flipped: Optional[bool] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class StartNodeData(BaseModel):
    """StartNodeData model."""
    # Fields
    custom_data: Dict[str, Union[str, float, bool]]
    output_data_structure: Dict[str, str]
    trigger_mode: Optional[HookTriggerMode] = Field(default=None)
    hook_event: Optional[str] = Field(default=None)
    hook_filters: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class ConditionNodeData(BaseModel):
    """ConditionNodeData model."""
    # Fields
    condition_type: str
    expression: Optional[str] = Field(default=None)
    node_indices: Optional[{} | undefined] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class PersonJobNodeData(BaseModel):
    """PersonJobNodeData model."""
    # Fields
    person: Optional[Any] = Field(default=None)
    first_only_prompt: str
    default_prompt: Optional[str] = Field(default=None)
    max_iteration: float
    memory_config: Optional[Any] = Field(default=None)
    memory_settings: Optional[MemorySettings] = Field(default=None)
    tools: Optional[{} | null | undefined] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class EndpointNodeData(BaseModel):
    """EndpointNodeData model."""
    # Fields
    save_to_file: bool
    file_name: Optional[str] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class DBNodeData(BaseModel):
    """DBNodeData model."""
    # Fields
    file: Optional[str] = Field(default=None)
    collection: Optional[str] = Field(default=None)
    sub_type: DBBlockSubType
    operation: str
    query: Optional[str] = Field(default=None)
    data: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class JobNodeData(BaseModel):
    """JobNodeData model."""
    # Fields
    code_type: SupportedLanguage
    code: str
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class CodeJobNodeData(BaseModel):
    """CodeJobNodeData model."""
    # Fields
    language: SupportedLanguage
    filePath: str
    functionName: Optional[str] = Field(default=None)
    timeout: Optional[float] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class ApiJobNodeData(BaseModel):
    """ApiJobNodeData model."""
    # Fields
    url: str
    method: HttpMethod
    headers: Optional[Any] = Field(default=None)
    params: Optional[Any] = Field(default=None)
    body: Optional[Any] = Field(default=None)
    timeout: Optional[float] = Field(default=None)
    auth_type: Optional[Union[Literal["none"], Literal["bearer"], Literal["basic"], Literal["api_key"], None]] = Field(default=None)
    auth_config: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class UserResponseNodeData(BaseModel):
    """UserResponseNodeData model."""
    # Fields
    prompt: str
    timeout: float
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class NotionNodeData(BaseModel):
    """NotionNodeData model."""
    # Fields
    operation: NotionOperation
    page_id: Optional[str] = Field(default=None)
    database_id: Optional[str] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class HookNodeData(BaseModel):
    """HookNodeData model."""
    # Fields
    hook_type: HookType
    config: Dict[str, Any]
    timeout: Optional[float] = Field(default=None)
    retry_count: Optional[float] = Field(default=None)
    retry_delay: Optional[float] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class TemplateJobNodeData(BaseModel):
    """TemplateJobNodeData model."""
    # Fields
    template_path: Optional[str] = Field(default=None)
    template_content: Optional[str] = Field(default=None)
    output_path: Optional[str] = Field(default=None)
    variables: Optional[Any] = Field(default=None)
    engine: Optional[Union[Literal["internal"], Literal["jinja2"], Literal["handlebars"], None]] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class ShellJobNodeData(BaseModel):
    """ShellJobNodeData model."""
    # Fields
    command: str
    args: Optional[{} | undefined] = Field(default=None)
    cwd: Optional[str] = Field(default=None)
    env: Optional[Any] = Field(default=None)
    timeout: Optional[float] = Field(default=None)
    capture_output: Optional[bool] = Field(default=None)
    shell: Optional[bool] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class JsonSchemaValidatorNodeData(BaseModel):
    """JsonSchemaValidatorNodeData model."""
    # Fields
    schema_path: Optional[str] = Field(default=None)
    schema: Optional[Any] = Field(default=None)
    data_path: Optional[str] = Field(default=None)
    strict_mode: Optional[bool] = Field(default=None)
    error_on_extra: Optional[bool] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class TypescriptAstNodeData(BaseModel):
    """TypescriptAstNodeData model."""
    # Fields
    source: Optional[str] = Field(default=None)
    extractPatterns: Optional[{} | undefined] = Field(default=None)
    includeJSDoc: Optional[bool] = Field(default=None)
    parseMode: Optional[Union[Literal["module"], Literal["script"], None]] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class SubDiagramNodeData(BaseModel):
    """SubDiagramNodeData model."""
    # Fields
    diagram_name: Optional[str] = Field(default=None)
    diagram_data: Optional[Any] = Field(default=None)
    input_mapping: Optional[Any] = Field(default=None)
    output_mapping: Optional[Any] = Field(default=None)
    timeout: Optional[float] = Field(default=None)
    wait_for_completion: Optional[bool] = Field(default=None)
    isolate_conversation: Optional[bool] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class Message(BaseModel):
    """Message model."""
    # Fields
    id: Optional[str] = Field(default=None)
    from_person_id: Any
    to_person_id: PersonID
    content: str
    timestamp: Optional[str] = Field(default=None)
    token_count: Optional[float] = Field(default=None)
    message_type: Union[Literal["person_to_person"], Literal["system_to_person"], Literal["person_to_system"]]
    metadata: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class ConversationMetadata(BaseModel):
    """ConversationMetadata model."""
    # Fields
    started_at: str
    last_message_at: str
    total_tokens: float
    message_count: float
    context_resets: float
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class Conversation(BaseModel):
    """Conversation model."""
    # Fields
    messages: Dict[str, Any]
    metadata: Optional[ConversationMetadata] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class MemoryState(BaseModel):
    """MemoryState model."""
    # Fields
    visible_messages: float
    has_more: Optional[bool] = Field(default=None)
    config: Optional[Any] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class SubDiagramNodeData(BaseModel):
    """SubDiagramNodeData model."""
    # Fields
    diagram_name: Optional[str] = Field(default=None)
    diagram_data: Optional[Any] = Field(default=None)
    input_mapping: Optional[Any] = Field(default=None)
    output_mapping: Optional[Any] = Field(default=None)
    timeout: Optional[float] = Field(default=None)
    wait_for_completion: Optional[bool] = Field(default=None)
    isolate_conversation: Optional[bool] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class HookNodeData(BaseModel):
    """HookNodeData model."""
    # Fields
    hook_type: HookType
    command: Optional[str] = Field(default=None)
    url: Optional[str] = Field(default=None)
    timeout: Optional[float] = Field(default=None)
    retry_count: Optional[float] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}

class TypescriptAstNodeData(BaseModel):
    """TypescriptAstNodeData model."""
    # Fields
    source: Optional[str]
    extractPatterns: Optional[{} | undefined] = Field(default=None)
    includeJSDoc: Optional[bool] = Field(default=None)
    parseMode: Optional[Union[Literal["module"], Literal["script"], None]] = Field(default=None)
    
    
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Override dict to handle custom serialization."""
        # Remove None values for cleaner output
        data = super().dict(**kwargs)
        return {k: v for k, v in data.items() if v is not None}


# Helper functions
def validate_node_type(node_type: str) -> str:
    """Validate that node_type is a valid NodeType."""
    try:
        NodeType(node_type)
        return node_type
    except ValueError:
        raise ValueError(f"Invalid node type: {node_type}")


def validate_handle(handle: str) -> str:
    """Validate handle format."""
    if not handle or not isinstance(handle, str):
        raise ValueError("Handle must be a non-empty string")
    return handle


# Model registry for dynamic instantiation
MODEL_REGISTRY = {
    "DomainNode": DomainNode,
}


def create_node_model(node_type: str, data: Dict[str, Any]) -> BaseModel:
    """Create a node model instance based on node type."""
    model_name = f"{node_type.replace('_', ' ').title().replace(' ', '')}Node"
    model_class = MODEL_REGISTRY.get(model_name)
    
    if not model_class:
        raise ValueError(f"Unknown node type: {node_type}")
    
    return model_class(**data)