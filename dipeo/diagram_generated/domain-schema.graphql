# Generated GraphQL Schema from Domain Models
# Generated at: 2025-07-27T18:02:39.257460
# DO NOT EDIT - This file is auto-generated from TypeScript domain models

# ============================================================================
# Scalars
# ============================================================================

"""Unique identifier for node"""
scalar NodeID

"""Unique identifier for arrow"""
scalar ArrowID

"""Unique identifier for handle"""
scalar HandleID

"""Unique identifier for person"""
scalar PersonID

"""Unique identifier for apikey"""
scalar ApiKeyID

"""Unique identifier for diagram"""
scalar DiagramID

"""Unique identifier for execution"""
scalar ExecutionID

"""Arbitrary JSON value"""
scalar JSONScalar

# ============================================================================
# Enums
# ============================================================================

enum LLMService {
  OPENAI
  ANTHROPIC
  GOOGLE
  AZURE
}

enum APIServiceType {
  OPENAI
  ANTHROPIC
  GOOGLE
  AZURE
  CUSTOM
}

# ============================================================================
# Types
# ============================================================================
type Vec2 {
  x: Float!
  y: Float!
}
type DomainHandle {
  id: HandleID!
  node_id: NodeID!
  label: HandleLabel!
  direction: HandleDirection!
  data_type: DataType!
  position: String
}
type DomainNode {
  id: NodeID!
  type: NodeType!
  position: Vec2!
  data: JSONScalar!
}
type DomainArrow {
  id: ArrowID!
  source: HandleID!
  target: HandleID!
  content_type: ContentType
  label: String
  data: JSONScalar
}
type MemorySettings {
  view: MemoryView!
  max_messages: Float
  preserve_system: Boolean
}
type PersonLLMConfig {
  service: LLMService!
  model: String!
  api_key_id: ApiKeyID!
  system_prompt: String
}
type DomainPerson {
  id: PersonID!
  label: String!
  llm_config: PersonLLMConfig!
  type: String!
}
type DomainApiKey {
  id: ApiKeyID!
  label: String!
  service: APIServiceType!
  key: String
}
type DiagramMetadata {
  id: DiagramID
  name: String
  description: String
  version: String!
  created: String!
  modified: String!
  author: String
  tags: [String]
}
type DomainDiagram {
  nodes: [DomainNode]!
  handles: [DomainHandle]!
  arrows: [DomainArrow]!
  persons: [DomainPerson]!
  metadata: DiagramMetadata
}
type BaseNodeData {
  label: String!
  flipped: Boolean
}
type TokenUsage {
  input: Float!
  output: Float!
  cached: Float
  total: Float
}
type NodeState {
  status: NodeExecutionStatus!
  started_at: String
  ended_at: String
  error: String
  token_usage: TokenUsage
  output: JSONScalar
}
type ExecutionState {
  id: ExecutionID!
  status: ExecutionStatus!
  diagram_id: DiagramID
  started_at: String!
  ended_at: String
  node_states: JSONScalar!
  node_outputs: JSONScalar!
  token_usage: TokenUsage!
  error: String
  variables: JSONScalar
  duration_seconds: Float
  is_active: Boolean
  exec_counts: JSONScalar!
  executed_nodes: [String]!
}
type ExecutionOptions {
  mode: String
  timeout: Float
  variables: JSONScalar
  debug: Boolean
}
type InteractivePromptData {
  node_id: NodeID!
  prompt: String!
  timeout: Float
  default_value: String
}
type InteractiveResponse {
  node_id: NodeID!
  response: String!
  timestamp: String!
}
type NodeDefinition {
  type: String!
  node_schema: JSONScalar!
  handler: JSONScalar!
  requires_services: [String]
  description: String
}

"""Base message interface for conversations
Used by both execution (PersonMemory) and person domains"""
type Message {
  id: String
  from_person_id: String!
  to_person_id: PersonID!
  content: String!
  timestamp: String
  token_count: Float
  message_type: String!
  metadata: JSONScalar
}
type ConversationMetadata {
  started_at: String!
  last_message_at: String!
  total_tokens: Float!
  message_count: Float!
  context_resets: Float!
}
type Conversation {
  messages: [Message]!
  metadata: ConversationMetadata
}

# ============================================================================
# Input Types
# ============================================================================
input ExecutionUpdate {
  type: EventType!
  execution_id: ExecutionID!
  node_id: NodeID = null
  status: NodeExecutionStatus = null
  result: JSONScalar = null
  error: String = null
  timestamp: String = null
  total_tokens: Float = null
  node_type: String = null
  tokens: Float = null
  data: JSONScalar = null
}

# ============================================================================
# Node Data Union (for generic node data field)
# ============================================================================

"""
Union type for all possible node data configurations.
In practice, DiPeO uses JSONScalar for the data field, but this union
documents all possible node data types.
"""
union NodeData = BaseNodeData