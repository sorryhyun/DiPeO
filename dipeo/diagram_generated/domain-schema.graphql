







# Generated GraphQL Schema from Domain Models
# Generated at: 2025-08-09T16:53:10.376699
# DO NOT EDIT - Generated by DiPeO

# ============================================================================
# Scalars
# ============================================================================

"""Unique identifier for node"""
scalar NodeID

"""Unique identifier for arrow"""
scalar ArrowID

"""Unique identifier for handle"""
scalar HandleID

"""Unique identifier for person"""
scalar PersonID

"""Unique identifier for apikey"""
scalar ApiKeyID

"""Unique identifier for diagram"""
scalar DiagramID

"""Unique identifier for execution"""
scalar ExecutionID

"""Arbitrary JSON value"""
scalar JSONScalar

# ============================================================================
# Enums
# ============================================================================

# ============================================================================
# Types
# ============================================================================
type Vec2 {
  x: Int!
  y: Int!
}
type DomainHandle {
  id: ID!
  node_id: ID!
  label: HandleLabel!
  direction: HandleDirection!
  data_type: DataType!
  position: String
}
type DomainNode {
  id: ID!
  type: NodeType!
  position: Vec2!
  data: JSONScalar!
}
type DomainArrow {
  id: ID!
  source: ID!
  target: ID!
  content_type: ContentType
  label: String
  data: JSONScalar
}
type MemorySettings {
  view: MemoryView!
  max_messages: Float
  preserve_system: Boolean
}
type PersonLLMConfig {
  service: LLMService!
  model: String!
  api_key_id: ID!
  system_prompt: String
  prompt_file: String
}
type DomainPerson {
  id: ID!
  label: String!
  llm_config: PersonLLMConfig!
  type: String!
}
type DomainApiKey {
  id: ID!
  label: String!
  service: APIServiceType!
  key: String
}
type DiagramMetadata {
  id: ID
  name: String
  description: String
  version: String!
  created: String!
  modified: String!
  author: String
  tags: [String]
  format: String
}
type DomainDiagram {
  nodes: [DomainNode]!
  handles: [DomainHandle]!
  arrows: [DomainArrow]!
  persons: [DomainPerson]!
  metadata: DiagramMetadata
}
type TokenUsage {
  input: Int!
  output: Int!
  cached: Int
  total: Int
}
type NodeState {
  status: Status!
  started_at: String
  ended_at: String
  error: String
  token_usage: TokenUsage
  output: JSONScalar
}
type NodeMetrics {
  node_id: String!
  node_type: String!
  start_time: Float!
  end_time: Float
  duration_ms: Float
  memory_usage: Float
  token_usage: TokenUsage
  error: String
  dependencies: [String]
}
type ExecutionMetrics {
  execution_id: ID!
  start_time: Float!
  end_time: Float
  total_duration_ms: Float
  node_metrics: JSONScalar!
  critical_path: [String]
  parallelizable_groups: [[String]]
  bottlenecks: Array<{
    node_id: string;
    node_type: string;
    duration_ms: number;
    percentage: number;
  }>
}
type ExecutionState {
  id: ID!
  status: Status!
  diagram_id: ID
  started_at: String!
  ended_at: String
  node_states: JSONScalar!
  node_outputs: JSONScalar!
  token_usage: TokenUsage!
  error: String
  variables: JSONScalar
  duration_seconds: Float
  is_active: Boolean
  exec_counts: JSONScalar!
  executed_nodes: [String]!
  metrics: ExecutionMetrics
}
type ExecutionOptions {
  mode: String
  timeout: Int
  variables: JSONScalar
  debug: Boolean
}
type InteractivePromptData {
  node_id: ID!
  prompt: String!
  timeout: Int
  default_value: String
}
type InteractiveResponse {
  node_id: ID!
  response: String!
  timestamp: String!
}
type NodeDefinition {
  type: String!
  node_schema: JSONScalar!
  handler: JSONScalar!
  requires_services: [String]
  description: String
}

"""Base message interface for conversations
Used by both execution (PersonMemory) and person domains"""
type Message {
  id: String
  from_person_id: String!
  to_person_id: ID!
  content: String!
  timestamp: String
  token_count: Float
  message_type: String!
  metadata: JSONScalar
}
type ConversationMetadata {
  started_at: String!
  last_message_at: String!
  total_tokens: Float!
  message_count: Float!
  context_resets: Float!
}
type Conversation {
  messages: [Message]!
  metadata: ConversationMetadata
}
type ApiJobNodeData {
  url: String!
  method: HttpMethod!
  headers: JSONScalar
  params: JSONScalar
  body: JSONScalar
  timeout: Int
  auth_type: AuthType
  auth_config: JSONScalar
}

"""Configuration data for CodeJob nodes that execute code"""
type CodeJobNodeData {
  language: SupportedLanguage!
  filePath: String
  code: String
  functionName: String
  timeout: Int
}

"""Configuration data for Condition nodes that handle conditional branching"""
type ConditionNodeData {
  condition_type: ConditionType
  expression: String
  node_indices: [String]
}

"""Configuration data for DB nodes that handle file system operations"""
type DBNodeData {
  file: [String]
  collection: String
  sub_type: DBBlockSubType!
  operation: String!
  query: String
  data: JSONScalar
  serialize_json: Boolean
  glob: Boolean
  format: String
}
type EndpointNodeData {
  save_to_file: Boolean!
  file_name: String
}
type HookNodeData {
  hook_type: HookType!
  command: String
  args: [String]
  env: JSONScalar
  cwd: String
  url: String
  method: HttpMethod
  headers: JSONScalar
  script: String
  function_name: String
  file_path: String
  format: String
  timeout: Int
  retry_count: Float
  retry_delay: Float
}
type IntegratedApiNodeData {
  provider: APIServiceType!
  operation: String!
  config: JSONScalar
  resource_id: String
  timeout: Int
  max_retries: Float
}
type JsonSchemaValidatorNodeData {
  schema_path: String
  json_schema: JSONScalar
  data_path: String
  strict_mode: Boolean
  error_on_extra: Boolean
}

"""Configuration data for PersonJob nodes that execute LLM agents"""
type PersonJobNodeData {
  person: ID
  first_only_prompt: String!
  first_prompt_file: String
  default_prompt: String
  prompt_file: String
  max_iteration: Float!
  memory_profile: MemoryProfile
  memory_settings: MemorySettings
  tools: ToolSelection
  text_format: String
  text_format_file: String
  batch: Boolean
  batch_input_key: String
  batch_parallel: Boolean
  max_concurrent: Float
}
type StartNodeData {
  trigger_mode: HookTriggerMode!
  custom_data: JSONScalar
  output_data_structure: JSONScalar
  hook_event: String
  hook_filters: JSONScalar
}

"""Configuration data for SubDiagram nodes that execute other diagrams"""
type SubDiagramNodeData {
  diagram_name: String
  diagram_format: DiagramFormat
  diagram_data: JSONScalar
  batch: Boolean
  batch_input_key: String
  batch_parallel: Boolean
  ignoreIfSub: Boolean
}
type TemplateJobNodeData {
  template_path: String
  template_content: String
  output_path: String
  variables: JSONScalar
  engine: TemplateEngine
}
type TypescriptAstNodeData {
  source: String
  extractPatterns: [String]
  includeJSDoc: Boolean
  parseMode: String
}
type UserResponseNodeData {
  prompt: String!
  timeout: Int!
}
type ToolConfig {
  type: ToolType!
  enabled: Boolean
  config: JSONScalar
}
type WebSearchResult {
  url: String!
  title: String!
  snippet: String!
  score: Float
}
type ImageGenerationResult {
  image_data: String!
  format: String!
  width: Int
  height: Int
}
type ToolOutput {
  type: ToolType!
  result: String!
  raw_response: JSONScalar
}
type ChatResult {
  text: String!
  token_usage: TokenUsage
  raw_response: JSONScalar
  tool_outputs: [ToolOutput]
}
type LLMRequestOptions {
  temperature: Float
  max_tokens: Float
  top_p: Float
  n: Float
  tools: [ToolConfig]
  response_format: JSONScalar
}

# ============================================================================
# Input Types
# ============================================================================
input ExecutionUpdate {
  type: EventType!
  execution_id: ID!
  node_id: ID = null
  status: Status = null
  result: JSONScalar = null
  error: String = null
  timestamp: String = null
  total_tokens: Float = null
  node_type: String = null
  tokens: Float = null
  data: JSONScalar = null
}

# ============================================================================
# Node Data Union (for generic node data field)
# ============================================================================

"""
Union type for all possible node data configurations.
In practice, DiPeO uses JSONScalar for the data field, but this union
documents all possible node data types.
"""
union NodeData = ApiJobNodeData | CodeJobNodeData | ConditionNodeData | DBNodeData | EndpointNodeData | HookNodeData | IntegratedApiNodeData | JsonSchemaValidatorNodeData | PersonJobNodeData | StartNodeData | SubDiagramNodeData | TemplateJobNodeData | TypescriptAstNodeData | UserResponseNodeData