







#!/usr/bin/env python3
# __generated__ by DiPeO
"""
Auto-generated Python models from TypeScript domain models.
DO NOT EDIT THIS FILE DIRECTLY - Modify TypeScript sources and regenerate.
"""
from __future__ import annotations

from enum import Enum, auto
from typing import Any, Dict, List, Literal, Optional, Union, NewType
from pydantic import BaseModel, Field, ConfigDict

from dipeo.core.type_defs import JsonValue, JsonDict, JsonList, JsonPrimitive
from .enums import *
from .integrations import *


ApiKeyID = NewType('ApiKeyID', str)
ArrowID = NewType('ArrowID', str)
DiagramID = NewType('DiagramID', str)
ExecutionID = NewType('ExecutionID', str)
HandleID = NewType('HandleID', str)
HookID = NewType('HookID', str)
NodeID = NewType('NodeID', str)
PersonID = NewType('PersonID', str)
TaskID = NewType('TaskID', str)





class Vec2(BaseModel):
    """Vec2 model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    x: int
    y: int


class DomainHandle(BaseModel):
    """DomainHandle model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    id: HandleID
    node_id: NodeID
    label: HandleLabel
    direction: HandleDirection
    data_type: DataType
    position: Optional[Union[str, None]] = Field(default=None)


class DomainNode(BaseModel):
    """DomainNode model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    id: NodeID
    type: NodeType
    position: Vec2
    data: JsonDict


class DomainArrow(BaseModel):
    """DomainArrow model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    id: ArrowID
    source: HandleID
    target: HandleID
    content_type: Optional[Union[ContentType, None]] = Field(default=None)
    label: Optional[Union[str, None]] = Field(default=None)
    data: Optional[Dict[str, Any]] = Field(default=None)


class MemorySettings(BaseModel):
    """MemorySettings model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    view: MemoryView
    max_messages: Optional[Union[float, None]] = Field(default=None)
    preserve_system: Optional[bool] = Field(default=None)


class PersonLLMConfig(BaseModel):
    """PersonLLMConfig model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    service: LLMService
    model: str
    api_key_id: ApiKeyID
    system_prompt: Optional[Union[str, None]] = Field(default=None)
    prompt_file: Optional[Union[str, None]] = Field(default=None)


class DomainPerson(BaseModel):
    """DomainPerson model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    id: PersonID
    label: str
    llm_config: PersonLLMConfig
    type: Literal['person']


class DomainApiKey(BaseModel):
    """DomainApiKey model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    id: ApiKeyID
    label: str
    service: APIServiceType
    key: Optional[str] = Field(default=None)


class DiagramMetadata(BaseModel):
    """DiagramMetadata model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    id: Optional[Union[DiagramID, None]] = Field(default=None)
    name: Optional[Union[str, None]] = Field(default=None)
    description: Optional[Union[str, None]] = Field(default=None)
    version: str
    created: str
    modified: str
    author: Optional[Union[str, None]] = Field(default=None)
    tags: Optional[Union[List[str], None]] = Field(default=None)
    format: Optional[Union[str, None]] = Field(default=None)


class DomainDiagram(BaseModel):
    """DomainDiagram model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    nodes: List[DomainNode]
    handles: List[DomainHandle]
    arrows: List[DomainArrow]
    persons: List[DomainPerson]
    metadata: Optional[Union[DiagramMetadata, None]] = Field(default=None)


class TokenUsage(BaseModel):
    """TokenUsage model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    input: int
    output: int
    cached: Optional[Union[float, None]] = Field(default=None)
    total: Optional[int] = Field(default=None)


class NodeState(BaseModel):
    """NodeState model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    status: Status
    started_at: Optional[Union[str, None]] = Field(default=None)
    ended_at: Optional[Union[str, None]] = Field(default=None)
    error: Optional[Union[str, None]] = Field(default=None)
    token_usage: Optional[Union[TokenUsage, None]] = Field(default=None)
    output: Optional[Dict[str, Any]] = Field(default=None)


class NodeMetrics(BaseModel):
    """NodeMetrics model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    node_id: str
    node_type: str
    start_time: float
    end_time: Optional[Union[float, None]] = Field(default=None)
    duration_ms: Optional[Union[float, None]] = Field(default=None)
    memory_usage: Optional[Union[float, None]] = Field(default=None)
    token_usage: Optional[Union[TokenUsage, None]] = Field(default=None)
    error: Optional[Union[str, None]] = Field(default=None)
    dependencies: Optional[List[str]] = Field(default=None)


class ExecutionMetrics(BaseModel):
    """ExecutionMetrics model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    execution_id: ExecutionID
    start_time: float
    end_time: Optional[Union[float, None]] = Field(default=None)
    total_duration_ms: Optional[Union[float, None]] = Field(default=None)
    node_metrics: Dict[str, NodeMetrics]
    critical_path: Optional[List[str]] = Field(default=None)
    parallelizable_groups: Optional[List[List[str]]] = Field(default=None)
    bottlenecks: Optional[List[Dict[str, Any]]] = Field(default=None)


class EnvelopeMeta(BaseModel):
    """EnvelopeMeta model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    node_id: Optional[str] = Field(default=None)
    token_usage: Optional[TokenUsage] = Field(default=None)
    execution_time: Optional[float] = Field(default=None)
    retry_count: Optional[float] = Field(default=None)
    error: Optional[str] = Field(default=None)
    error_type: Optional[str] = Field(default=None)
    timestamp: Optional[Union[str, float]] = Field(default=None)


class SerializedEnvelope(BaseModel):
    """SerializedEnvelope model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    envelope_format: Literal[True]
    id: str
    trace_id: str
    produced_by: str
    content_type: str
    schema_id: Optional[str] = Field(default=None)
    serialization_format: Optional[str] = Field(default=None)
    body: Any
    meta: EnvelopeMeta


class ExecutionState(BaseModel):
    """ExecutionState model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    id: ExecutionID
    status: Status
    diagram_id: Optional[Union[DiagramID, None]] = Field(default=None)
    started_at: str
    ended_at: Optional[Union[str, None]] = Field(default=None)
    node_states: Dict[str, NodeState]
    node_outputs: Dict[str, SerializedNodeOutput]
    token_usage: TokenUsage
    error: Optional[Union[str, None]] = Field(default=None)
    variables: Optional[JsonDict] = Field(default=None)
    duration_seconds: Optional[Union[float, None]] = Field(default=None)
    is_active: Optional[bool] = Field(default=None)
    exec_counts: Dict[str, float]
    executed_nodes: List[str]
    metrics: Optional[Union[ExecutionMetrics, None]] = Field(default=None)


class ExecutionOptions(BaseModel):
    """ExecutionOptions model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    mode: Optional[Union[Literal['normal'], Literal['debug'], Literal['monitor']]] = Field(default=None)
    timeout: Optional[int] = Field(default=None)
    variables: Optional[JsonDict] = Field(default=None)
    debug: Optional[bool] = Field(default=None)


class InteractivePromptData(BaseModel):
    """InteractivePromptData model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    node_id: NodeID
    prompt: str
    timeout: Optional[int] = Field(default=None)
    default_value: Optional[Union[str, None]] = Field(default=None)


class InteractiveResponse(BaseModel):
    """InteractiveResponse model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    node_id: NodeID
    response: str
    timestamp: str


class ExecutionUpdate(BaseModel):
    """ExecutionUpdate model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    type: EventType
    execution_id: ExecutionID
    node_id: Optional[NodeID] = Field(default=None)
    status: Optional[Status] = Field(default=None)
    result: Optional[JsonValue] = Field(default=None)
    error: Optional[str] = Field(default=None)
    timestamp: Optional[str] = Field(default=None)
    total_tokens: Optional[float] = Field(default=None)
    node_type: Optional[str] = Field(default=None)
    tokens: Optional[float] = Field(default=None)
    data: Optional[Dict[str, Any]] = Field(default=None)


class NodeDefinition(BaseModel):
    """NodeDefinition model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    type: str
    node_schema: Any
    handler: Any
    requires_services: Optional[List[str]] = Field(default=None)
    description: Optional[str] = Field(default=None)


class Message(BaseModel):
    """Base message interface for conversations
Used by both execution (PersonMemory) and person domains"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    id: Optional[str] = Field(default=None)
    from_person_id: Union[PersonID, Literal['system']]
    to_person_id: PersonID
    content: str
    timestamp: Optional[str] = Field(default=None)
    token_count: Optional[float] = Field(default=None)
    message_type: Union[Literal['person_to_person'], Literal['system_to_person'], Literal['person_to_system']]
    metadata: Optional[JsonDict] = Field(default=None)


class ConversationMetadata(BaseModel):
    """ConversationMetadata model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    started_at: str
    last_message_at: str
    total_tokens: float
    message_count: float
    context_resets: float


class Conversation(BaseModel):
    """Conversation model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    messages: List[Message]
    metadata: Optional[ConversationMetadata] = Field(default=None)


class ToolConfig(BaseModel):
    """ToolConfig model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    type: ToolType
    enabled: Optional[bool] = Field(default=None)
    config: Optional[Dict[str, Any]] = Field(default=None)


class WebSearchResult(BaseModel):
    """WebSearchResult model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    url: str
    title: str
    snippet: str
    score: Optional[float] = Field(default=None)


class ImageGenerationResult(BaseModel):
    """ImageGenerationResult model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    image_data: str
    format: str
    width: Optional[int] = Field(default=None)
    height: Optional[int] = Field(default=None)


class ToolOutput(BaseModel):
    """ToolOutput model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    type: ToolType
    result: Union[List[WebSearchResult], ImageGenerationResult, Any]
    raw_response: Optional[Any] = Field(default=None)


class ChatResult(BaseModel):
    """ChatResult model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    text: str
    token_usage: Optional[Union[TokenUsage, None]] = Field(default=None)
    raw_response: Optional[Union[Any, None]] = Field(default=None)
    tool_outputs: Optional[Union[List[ToolOutput], None]] = Field(default=None)


class LLMRequestOptions(BaseModel):
    """LLMRequestOptions model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    temperature: Optional[float] = Field(default=None)
    max_tokens: Optional[float] = Field(default=None)
    top_p: Optional[float] = Field(default=None)
    n: Optional[float] = Field(default=None)
    tools: Optional[List[ToolConfig]] = Field(default=None)
    response_format: Optional[Any] = Field(default=None)


class BaseNodeData(BaseModel):
    """Base node data interface that all node types extend"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    label: str
    flipped: Optional[bool] = Field(default=None)


class ApiJobNodeData(BaseNodeData):
    """ApiJobNodeData model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    url: str
    method: HttpMethod
    headers: Optional[Dict[str, str]] = Field(default=None)
    params: Optional[JsonDict] = Field(default=None)
    body: Optional[JsonValue] = Field(default=None)
    timeout: Optional[int] = Field(default=None)
    auth_type: Optional[AuthType] = Field(default=None)
    auth_config: Optional[Dict[str, str]] = Field(default=None)


class CodeJobNodeData(BaseNodeData):
    """Configuration data for CodeJob nodes that execute code"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    language: SupportedLanguage = Field(description="Programming language: python, typescript, bash, or shell")
    filePath: Optional[str] = Field(default=None, description="External code file path (e.g., \u0027files/code/processor.py\u0027)")
    code: Optional[str] = Field(default=None, description="Inline code or path to external file")
    functionName: Optional[str] = Field(default=None, description="Function to call in external file (required with filePath)")
    timeout: Optional[int] = Field(default=None, description="Execution timeout in seconds (default: 60)")


class ConditionNodeData(BaseNodeData):
    """Configuration data for Condition nodes that handle conditional branching"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    condition_type: Optional[ConditionType] = Field(default=None, description="Condition type: detect_max_iterations, nodes_executed, or custom")
    expression: Optional[str] = Field(default=None, description="Python expression for custom type (access to all variables)")
    node_indices: Optional[List[str]] = Field(default=None, description="List of node indices for nodes_executed condition type")


class DBNodeData(BaseNodeData):
    """Configuration data for DB nodes that handle file system operations"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    file: Optional[List[Union[str, str]]] = Field(default=None, description="File path(s) - single string or list for multiple files")
    collection: Optional[str] = Field(default=None, description="Database collection name (for database operations)")
    sub_type: DBBlockSubType = Field(description="Storage type: file or database")
    operation: str = Field(description="Operation type: read or write")
    query: Optional[str] = Field(default=None, description="Database query (for database operations)")
    data: Optional[JsonDict] = Field(default=None, description="Data to write (for write operations)")
    serialize_json: Optional[bool] = Field(default=None, description="Auto-parse JSON files when reading (default: false)")
    glob: Optional[bool] = Field(default=None, description="Enable glob pattern expansion for paths (default: false)")
    format: Optional[str] = Field(default=None, description="Data format: json, yaml, csv, text, etc.")


class EndpointNodeData(BaseNodeData):
    """EndpointNodeData model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    save_to_file: bool
    file_name: Optional[str] = Field(default=None)


class HookNodeData(BaseNodeData):
    """HookNodeData model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    hook_type: HookType
    command: Optional[str] = Field(default=None)
    args: Optional[List[str]] = Field(default=None)
    env: Optional[Dict[str, str]] = Field(default=None)
    cwd: Optional[str] = Field(default=None)
    url: Optional[str] = Field(default=None)
    method: Optional[HttpMethod] = Field(default=None)
    headers: Optional[Dict[str, str]] = Field(default=None)
    script: Optional[str] = Field(default=None)
    function_name: Optional[str] = Field(default=None)
    file_path: Optional[str] = Field(default=None)
    format: Optional[Union[Literal['json'], Literal['yaml'], Literal['text']]] = Field(default=None)
    timeout: Optional[int] = Field(default=None)
    retry_count: Optional[float] = Field(default=None)
    retry_delay: Optional[float] = Field(default=None)


class IntegratedApiNodeData(BaseNodeData):
    """IntegratedApiNodeData model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    provider: APIServiceType = Field(description="The API provider to use (e.g., notion, slack, github)")
    operation: str = Field(description="The operation to perform (provider-specific)\nThis is a string to allow dynamic operations per provider")
    config: Optional[JsonDict] = Field(default=None, description="Provider-specific configuration\nStructure depends on the selected provider and operation")
    resource_id: Optional[str] = Field(default=None, description="Optional resource ID (e.g., page_id for Notion, channel_id for Slack)")
    timeout: Optional[int] = Field(default=None, description="Request timeout in seconds")
    max_retries: Optional[float] = Field(default=None, description="Maximum number of retries for failed requests")


class JsonSchemaValidatorNodeData(BaseNodeData):
    """JsonSchemaValidatorNodeData model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    schema_path: Optional[str] = Field(default=None)
    json_schema: Optional[JsonDict] = Field(default=None)
    data_path: Optional[str] = Field(default=None)
    strict_mode: Optional[bool] = Field(default=None)
    error_on_extra: Optional[bool] = Field(default=None)


class PersonJobNodeData(BaseNodeData):
    """Configuration data for PersonJob nodes that execute LLM agents"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    person: Optional[PersonID] = Field(default=None, description="Reference to agent defined in \u0027persons\u0027 section")
    first_only_prompt: str = Field(description="Special prompt for first iteration only, supports {{variable}} syntax")
    first_prompt_file: Optional[str] = Field(default=None, description="External prompt file for first iteration only (overrides first_only_prompt)")
    default_prompt: Optional[str] = Field(default=None, description="Prompt template using {{variable}} syntax for subsequent iterations")
    prompt_file: Optional[str] = Field(default=None, description="External prompt file in files/prompts/ (overrides inline prompts)")
    max_iteration: float = Field(description="Maximum conversation turns (default: 1)")
    memory_profile: Optional[MemoryProfile] = Field(default=None, description="Memory profile: GOLDFISH (2 msgs), MINIMAL (5), FOCUSED (20), FULL (all)")
    memory_settings: Optional[Union[MemorySettings, None]] = Field(default=None, description="Advanced memory configuration when memory_profile is CUSTOM")
    tools: Optional[ToolSelection] = Field(default=None, description="LLM tools to enable (web_search_preview, etc.)")
    text_format: Optional[str] = Field(default=None, description="Pydantic model name for structured output")
    text_format_file: Optional[str] = Field(default=None, description="External Python file with Pydantic models (overrides text_format)")
    batch: Optional[bool] = Field(default=None, description="Enable batch processing for arrays")
    batch_input_key: Optional[str] = Field(default=None, description="Array variable name for batch processing")
    batch_parallel: Optional[bool] = Field(default=None, description="Execute batch items in parallel")
    max_concurrent: Optional[float] = Field(default=None, description="Maximum concurrent batch executions")


class StartNodeData(BaseNodeData):
    """StartNodeData model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    trigger_mode: HookTriggerMode
    custom_data: Optional[Dict[str, Union[str, float, bool]]] = Field(default=None)
    output_data_structure: Optional[Dict[str, str]] = Field(default=None)
    hook_event: Optional[str] = Field(default=None)
    hook_filters: Optional[JsonDict] = Field(default=None)


class SubDiagramNodeData(BaseNodeData):
    """Configuration data for SubDiagram nodes that execute other diagrams"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    diagram_name: Optional[str] = Field(default=None, description="Path to sub-diagram file")
    diagram_format: Optional[DiagramFormat] = Field(default=None, description="Diagram format: light or native (default: light)")
    diagram_data: Optional[JsonDict] = Field(default=None, description="Pass all current variables to sub-diagram")
    batch: Optional[bool] = Field(default=None, description="Enable batch processing for arrays")
    batch_input_key: Optional[str] = Field(default=None, description="Array variable name for batch processing")
    batch_parallel: Optional[bool] = Field(default=None, description="Execute batch items in parallel")
    ignoreIfSub: Optional[bool] = Field(default=None, description="Skip if already running as sub-diagram")


class TemplateJobNodeData(BaseNodeData):
    """TemplateJobNodeData model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    template_path: Optional[str] = Field(default=None)
    template_content: Optional[str] = Field(default=None)
    output_path: Optional[str] = Field(default=None)
    variables: Optional[JsonDict] = Field(default=None)
    engine: Optional[TemplateEngine] = Field(default=None)


class TypescriptAstNodeData(BaseNodeData):
    """TypescriptAstNodeData model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    source: Optional[str] = Field(default=None)
    extractPatterns: Optional[List[str]] = Field(default=None)
    includeJSDoc: Optional[bool] = Field(default=None)
    parseMode: Optional[Union[Literal['module'], Literal['script']]] = Field(default=None)
    batch: Optional[bool] = Field(default=None)
    sources: Optional[Dict[str, str]] = Field(default=None)
    batchInputKey: Optional[str] = Field(default=None)


class UserResponseNodeData(BaseNodeData):
    """UserResponseNodeData model"""
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    
    prompt: str
    timeout: int


# Type aliases that reference models
SerializedNodeOutput = SerializedEnvelope
PersonMemoryMessage = Message
PersonBatchJobNodeData = PersonJobNodeData




def parse_handle_id(handle_id: str) -> tuple[NodeID, str, str]:
    """Parse a handle ID into its components."""
    parts = handle_id.split('_')
    if len(parts) < 3:
        raise ValueError(f"Invalid handle ID format: {handle_id}")
    
    node_id = parts[0]
    direction = parts[-1]
    label = '_'.join(parts[1:-1])
    
    return NodeID(node_id), label, direction

def create_handle_id(node_id: NodeID, label: str, direction: str) -> HandleID:
    """Create a handle ID from components."""
    return HandleID(f"{node_id}_{label}_{direction}")


# Type guard functions
def is_vec2(obj: Any) -> bool:
    """Check if object is a Vec2."""
    return isinstance(obj, Vec2)
def is_domain_handle(obj: Any) -> bool:
    """Check if object is a DomainHandle."""
    return isinstance(obj, DomainHandle)
def is_domain_node(obj: Any) -> bool:
    """Check if object is a DomainNode."""
    return isinstance(obj, DomainNode)
def is_domain_arrow(obj: Any) -> bool:
    """Check if object is a DomainArrow."""
    return isinstance(obj, DomainArrow)
def is_memory_settings(obj: Any) -> bool:
    """Check if object is a MemorySettings."""
    return isinstance(obj, MemorySettings)
def is_person_llm_config(obj: Any) -> bool:
    """Check if object is a PersonLLMConfig."""
    return isinstance(obj, PersonLLMConfig)
def is_domain_person(obj: Any) -> bool:
    """Check if object is a DomainPerson."""
    return isinstance(obj, DomainPerson)
def is_domain_api_key(obj: Any) -> bool:
    """Check if object is a DomainApiKey."""
    return isinstance(obj, DomainApiKey)
def is_diagram_metadata(obj: Any) -> bool:
    """Check if object is a DiagramMetadata."""
    return isinstance(obj, DiagramMetadata)
def is_domain_diagram(obj: Any) -> bool:
    """Check if object is a DomainDiagram."""
    return isinstance(obj, DomainDiagram)
def is_token_usage(obj: Any) -> bool:
    """Check if object is a TokenUsage."""
    return isinstance(obj, TokenUsage)
def is_node_state(obj: Any) -> bool:
    """Check if object is a NodeState."""
    return isinstance(obj, NodeState)
def is_node_metrics(obj: Any) -> bool:
    """Check if object is a NodeMetrics."""
    return isinstance(obj, NodeMetrics)
def is_execution_metrics(obj: Any) -> bool:
    """Check if object is a ExecutionMetrics."""
    return isinstance(obj, ExecutionMetrics)
def is_envelope_meta(obj: Any) -> bool:
    """Check if object is a EnvelopeMeta."""
    return isinstance(obj, EnvelopeMeta)
def is_serialized_envelope(obj: Any) -> bool:
    """Check if object is a SerializedEnvelope."""
    return isinstance(obj, SerializedEnvelope)
def is_execution_state(obj: Any) -> bool:
    """Check if object is a ExecutionState."""
    return isinstance(obj, ExecutionState)
def is_execution_options(obj: Any) -> bool:
    """Check if object is a ExecutionOptions."""
    return isinstance(obj, ExecutionOptions)
def is_interactive_prompt_data(obj: Any) -> bool:
    """Check if object is a InteractivePromptData."""
    return isinstance(obj, InteractivePromptData)
def is_interactive_response(obj: Any) -> bool:
    """Check if object is a InteractiveResponse."""
    return isinstance(obj, InteractiveResponse)
def is_execution_update(obj: Any) -> bool:
    """Check if object is a ExecutionUpdate."""
    return isinstance(obj, ExecutionUpdate)
def is_node_definition(obj: Any) -> bool:
    """Check if object is a NodeDefinition."""
    return isinstance(obj, NodeDefinition)
def is_message(obj: Any) -> bool:
    """Check if object is a Message."""
    return isinstance(obj, Message)
def is_conversation_metadata(obj: Any) -> bool:
    """Check if object is a ConversationMetadata."""
    return isinstance(obj, ConversationMetadata)
def is_conversation(obj: Any) -> bool:
    """Check if object is a Conversation."""
    return isinstance(obj, Conversation)
def is_tool_config(obj: Any) -> bool:
    """Check if object is a ToolConfig."""
    return isinstance(obj, ToolConfig)
def is_web_search_result(obj: Any) -> bool:
    """Check if object is a WebSearchResult."""
    return isinstance(obj, WebSearchResult)
def is_image_generation_result(obj: Any) -> bool:
    """Check if object is a ImageGenerationResult."""
    return isinstance(obj, ImageGenerationResult)
def is_tool_output(obj: Any) -> bool:
    """Check if object is a ToolOutput."""
    return isinstance(obj, ToolOutput)
def is_chat_result(obj: Any) -> bool:
    """Check if object is a ChatResult."""
    return isinstance(obj, ChatResult)
def is_llm_request_options(obj: Any) -> bool:
    """Check if object is a LLMRequestOptions."""
    return isinstance(obj, LLMRequestOptions)
def is_base_node_data(obj: Any) -> bool:
    """Check if object is a BaseNodeData."""
    return isinstance(obj, BaseNodeData)
def is_api_job_node_data(obj: Any) -> bool:
    """Check if object is a ApiJobNodeData."""
    return isinstance(obj, ApiJobNodeData)
def is_code_job_node_data(obj: Any) -> bool:
    """Check if object is a CodeJobNodeData."""
    return isinstance(obj, CodeJobNodeData)
def is_condition_node_data(obj: Any) -> bool:
    """Check if object is a ConditionNodeData."""
    return isinstance(obj, ConditionNodeData)
def is_db_node_data(obj: Any) -> bool:
    """Check if object is a DBNodeData."""
    return isinstance(obj, DBNodeData)
def is_endpoint_node_data(obj: Any) -> bool:
    """Check if object is a EndpointNodeData."""
    return isinstance(obj, EndpointNodeData)
def is_hook_node_data(obj: Any) -> bool:
    """Check if object is a HookNodeData."""
    return isinstance(obj, HookNodeData)
def is_integrated_api_node_data(obj: Any) -> bool:
    """Check if object is a IntegratedApiNodeData."""
    return isinstance(obj, IntegratedApiNodeData)
def is_json_schema_validator_node_data(obj: Any) -> bool:
    """Check if object is a JsonSchemaValidatorNodeData."""
    return isinstance(obj, JsonSchemaValidatorNodeData)
def is_person_job_node_data(obj: Any) -> bool:
    """Check if object is a PersonJobNodeData."""
    return isinstance(obj, PersonJobNodeData)
def is_start_node_data(obj: Any) -> bool:
    """Check if object is a StartNodeData."""
    return isinstance(obj, StartNodeData)
def is_sub_diagram_node_data(obj: Any) -> bool:
    """Check if object is a SubDiagramNodeData."""
    return isinstance(obj, SubDiagramNodeData)
def is_template_job_node_data(obj: Any) -> bool:
    """Check if object is a TemplateJobNodeData."""
    return isinstance(obj, TemplateJobNodeData)
def is_typescript_ast_node_data(obj: Any) -> bool:
    """Check if object is a TypescriptAstNodeData."""
    return isinstance(obj, TypescriptAstNodeData)
def is_user_response_node_data(obj: Any) -> bool:
    """Check if object is a UserResponseNodeData."""
    return isinstance(obj, UserResponseNodeData)


# Constants from TypeScript
PROVIDER_OPERATIONS = {"[APIServiceType.ANTHROPIC]": [], "[APIServiceType.BEDROCK]": [], "[APIServiceType.DEEPSEEK]": [], "[APIServiceType.GEMINI]": [], "[APIServiceType.GITHUB]": ["create_issue", "update_issue", "list_issues", "create_pr", "merge_pr", "get_repo_info"], "[APIServiceType.GOOGLE]": [], "[APIServiceType.GOOGLE_SEARCH]": ["search"], "[APIServiceType.JIRA]": ["create_issue", "update_issue", "search_issues", "transition_issue", "add_comment"], "[APIServiceType.NOTION]": ["create_page", "update_page", "read_page", "delete_page", "create_database", "query_database", "update_database"], "[APIServiceType.OLLAMA]": [], "[APIServiceType.OPENAI]": [], "[APIServiceType.SLACK]": ["send_message", "read_channel", "create_channel", "list_channels", "upload_file"], "[APIServiceType.VERTEX]": []}