"""
Auto-generated static node types from domain models.
DO NOT EDIT THIS FILE DIRECTLY.
Generated at: 2025-09-05T15:12:12.748214
Generated by: domain model static nodes generation
"""


from dataclasses import *
from typing import *

from .domain_models import *
from .enums import *
from .integrations import *


def _to_enum(value: Optional[str], enum_class) -> Optional[Any]:
    """Convert string value to enum instance if not None."""
    if value is None:
        return None
    if isinstance(value, enum_class):
        return value
    return enum_class(value)


@dataclass(frozen=True)
class BaseExecutableNode:
    """Base class for all executable node types."""
    # Required fields only - no defaults in base class
    id: NodeID
    position: Vec2
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        result = {
            "id": self.id,
            "position": {"x": self.position.x, "y": self.position.y}
        }
        # Subclasses should extend this
        return result


# Debug: Show all available variables
# Available variables: now: 2025-09-05T15:12:12.748214
# static_nodes_data exists: yes
# static_nodes_data type: dict
# static_nodes_data keys: ['node_classes', 'enum_fields', 'now']
# Number of classes: 14

@dataclass(frozen=True)
class ApiJobNode(BaseExecutableNode):
    # Required node-specific fields
    url: str
    method: HttpMethod
    headers: Optional[Dict[str, str]]
    params: Optional[JsonDict]
    body: Optional[JsonValue]
    timeout: Optional[int]
    auth_type: Optional[AuthType]
    auth_config: Optional[Dict[str, str]]
    # Type field with default
    type: NodeType = field(default=NodeType.API_JOB, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["url"] = self.url
        data["method"] = self.method
        data["headers"] = self.headers
        data["params"] = self.params
        data["body"] = self.body
        data["timeout"] = self.timeout
        data["auth_type"] = self.auth_type
        data["auth_config"] = self.auth_config
        return data



@dataclass(frozen=True)
class CodeJobNode(BaseExecutableNode):
    # Required node-specific fields
    language: SupportedLanguage
    filePath: Optional[str]
    code: Optional[str]
    functionName: Optional[str]
    timeout: Optional[int]
    # Type field with default
    type: NodeType = field(default=NodeType.CODE_JOB, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["language"] = self.language
        data["filePath"] = self.filePath
        data["code"] = self.code
        data["functionName"] = self.functionName
        data["timeout"] = self.timeout
        return data



@dataclass(frozen=True)
class ConditionNode(BaseExecutableNode):
    # Required node-specific fields
    expression: Optional[str]
    node_indices: Optional[List[str]]
    expose_index_as: Optional[str]
    person: Optional[PersonID]
    judge_by: Optional[str]
    judge_by_file: Optional[str]
    at_most: Optional[int]
    # Type field with default
    type: NodeType = field(default=NodeType.CONDITION, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy
    # Optional node-specific fields
    condition_type: Optional[ConditionType] = "custom"
    skippable: Optional[bool] = False
    memorize_to: Optional[str] = "GOLDFISH"

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["condition_type"] = self.condition_type
        data["expression"] = self.expression
        data["node_indices"] = self.node_indices
        data["expose_index_as"] = self.expose_index_as
        data["skippable"] = self.skippable
        data["person"] = self.person
        data["judge_by"] = self.judge_by
        data["judge_by_file"] = self.judge_by_file
        data["memorize_to"] = self.memorize_to
        data["at_most"] = self.at_most
        return data



@dataclass(frozen=True)
class DBNode(BaseExecutableNode):
    # Required node-specific fields
    file: Optional[List[Union[str, str]]]
    collection: Optional[str]
    sub_type: DBBlockSubType
    operation: str
    query: Optional[str]
    data: Optional[JsonDict]
    glob: Optional[bool]
    # Type field with default
    type: NodeType = field(default=NodeType.DB, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy
    # Optional node-specific fields
    serialize_json: Optional[bool] = False
    format: Optional[str] = "json"

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["file"] = self.file
        data["collection"] = self.collection
        data["sub_type"] = self.sub_type
        data["operation"] = self.operation
        data["query"] = self.query
        data["data"] = self.data
        data["serialize_json"] = self.serialize_json
        data["glob"] = self.glob
        data["format"] = self.format
        return data



@dataclass(frozen=True)
class EndpointNode(BaseExecutableNode):
    # Required node-specific fields
    save_to_file: bool
    file_name: Optional[str]
    # Type field with default
    type: NodeType = field(default=NodeType.ENDPOINT, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["save_to_file"] = self.save_to_file
        data["file_name"] = self.file_name
        return data



@dataclass(frozen=True)
class HookNode(BaseExecutableNode):
    # Required node-specific fields
    command: Optional[str]
    args: Optional[List[str]]
    env: Optional[Dict[str, str]]
    cwd: Optional[str]
    url: Optional[str]
    method: Optional[HttpMethod]
    headers: Optional[Dict[str, str]]
    script: Optional[str]
    function_name: Optional[str]
    file_path: Optional[str]
    format: Optional[Literal["json", "yaml", "text"]]
    retry_delay: Optional[int]
    # Type field with default
    type: NodeType = field(default=NodeType.HOOK, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy
    # Optional node-specific fields
    hook_type: HookType = "shell"
    timeout: Optional[int] = 60
    retry_count: Optional[int] = 0

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["hook_type"] = self.hook_type
        data["command"] = self.command
        data["args"] = self.args
        data["env"] = self.env
        data["cwd"] = self.cwd
        data["url"] = self.url
        data["method"] = self.method
        data["headers"] = self.headers
        data["script"] = self.script
        data["function_name"] = self.function_name
        data["file_path"] = self.file_path
        data["format"] = self.format
        data["timeout"] = self.timeout
        data["retry_count"] = self.retry_count
        data["retry_delay"] = self.retry_delay
        return data



@dataclass(frozen=True)
class IntegratedApiNode(BaseExecutableNode):
    # Required node-specific fields
    provider: str
    operation: str
    config: Optional[JsonDict]
    resource_id: Optional[str]
    timeout: Optional[int]
    max_retries: Optional[int]
    # Type field with default
    type: NodeType = field(default=NodeType.INTEGRATED_API, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["provider"] = self.provider
        data["operation"] = self.operation
        data["config"] = self.config
        data["resource_id"] = self.resource_id
        data["timeout"] = self.timeout
        data["max_retries"] = self.max_retries
        return data



@dataclass(frozen=True)
class JsonSchemaValidatorNode(BaseExecutableNode):
    # Required node-specific fields
    schema_path: Optional[str]
    json_schema: Optional[JsonDict]
    data_path: Optional[str]
    strict_mode: Optional[bool]
    error_on_extra: Optional[bool]
    # Type field with default
    type: NodeType = field(default=NodeType.JSON_SCHEMA_VALIDATOR, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["schema_path"] = self.schema_path
        data["json_schema"] = self.json_schema
        data["data_path"] = self.data_path
        data["strict_mode"] = self.strict_mode
        data["error_on_extra"] = self.error_on_extra
        return data



@dataclass(frozen=True)
class PersonJobNode(BaseExecutableNode):
    # Required node-specific fields
    person: Optional[PersonID]
    first_only_prompt: str
    first_prompt_file: Optional[str]
    default_prompt: Optional[str]
    prompt_file: Optional[str]
    memorize_to: str
    at_most: int
    text_format: Optional[str]
    text_format_file: Optional[str]
    batch: Optional[bool]
    batch_input_key: Optional[str]
    batch_parallel: Optional[bool]
    max_concurrent: Optional[int]
    # Type field with default
    type: NodeType = field(default=NodeType.PERSON_JOB, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy
    # Optional node-specific fields
    max_iteration: int = 100
    tools: Optional[ToolSelection] = "none"

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["person"] = self.person
        data["first_only_prompt"] = self.first_only_prompt
        data["first_prompt_file"] = self.first_prompt_file
        data["default_prompt"] = self.default_prompt
        data["prompt_file"] = self.prompt_file
        data["max_iteration"] = self.max_iteration
        data["memorize_to"] = self.memorize_to
        data["at_most"] = self.at_most
        data["tools"] = self.tools
        data["text_format"] = self.text_format
        data["text_format_file"] = self.text_format_file
        data["batch"] = self.batch
        data["batch_input_key"] = self.batch_input_key
        data["batch_parallel"] = self.batch_parallel
        data["max_concurrent"] = self.max_concurrent
        return data



@dataclass(frozen=True)
class StartNode(BaseExecutableNode):
    # Required node-specific fields
    custom_data: Optional[Dict[str, Union[str, float, bool]]]
    output_data_structure: Optional[Dict[str, str]]
    hook_event: Optional[str]
    hook_filters: Optional[JsonDict]
    # Type field with default
    type: NodeType = field(default=NodeType.START, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy
    # Optional node-specific fields
    trigger_mode: HookTriggerMode = "none"

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["trigger_mode"] = self.trigger_mode
        data["custom_data"] = self.custom_data
        data["output_data_structure"] = self.output_data_structure
        data["hook_event"] = self.hook_event
        data["hook_filters"] = self.hook_filters
        return data



@dataclass(frozen=True)
class SubDiagramNode(BaseExecutableNode):
    # Required node-specific fields
    diagram_name: Optional[str]
    diagram_format: Optional[DiagramFormat]
    diagram_data: Optional[JsonDict]
    passInputData: Optional[bool]
    batch_input_key: Optional[str]
    # Type field with default
    type: NodeType = field(default=NodeType.SUB_DIAGRAM, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy
    # Optional node-specific fields
    batch: Optional[bool] = False
    batch_parallel: Optional[bool] = False
    ignoreIfSub: Optional[bool] = False

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["diagram_name"] = self.diagram_name
        data["diagram_format"] = self.diagram_format
        data["diagram_data"] = self.diagram_data
        data["passInputData"] = self.passInputData
        data["batch"] = self.batch
        data["batch_input_key"] = self.batch_input_key
        data["batch_parallel"] = self.batch_parallel
        data["ignoreIfSub"] = self.ignoreIfSub
        return data



@dataclass(frozen=True)
class TemplateJobNode(BaseExecutableNode):
    # Required node-specific fields
    template_path: Optional[str]
    template_content: Optional[str]
    output_path: Optional[str]
    variables: Optional[JsonDict]
    foreach: Optional[Dict[str, Any]]
    preprocessor: Optional[TemplatePreprocessor]
    # Type field with default
    type: NodeType = field(default=NodeType.TEMPLATE_JOB, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy
    # Optional node-specific fields
    engine: Optional[TemplateEngine] = "jinja2"

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["template_path"] = self.template_path
        data["template_content"] = self.template_content
        data["output_path"] = self.output_path
        data["variables"] = self.variables
        data["engine"] = self.engine
        data["foreach"] = self.foreach
        data["preprocessor"] = self.preprocessor
        return data



@dataclass(frozen=True)
class TypescriptAstNode(BaseExecutableNode):
    # Required node-specific fields
    source: Optional[str]
    batch: Optional[bool]
    sources: Optional[Dict[str, str]]
    batchInputKey: Optional[str]
    # Type field with default
    type: NodeType = field(default=NodeType.TYPESCRIPT_AST, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy
    # Optional node-specific fields
    extractPatterns: Optional[List[str]] = field(default_factory=lambda: ['interface', 'type', 'enum'])
    includeJSDoc: Optional[bool] = False
    parseMode: Optional[Literal["module", "script"]] = "module"

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["source"] = self.source
        data["extractPatterns"] = self.extractPatterns
        data["includeJSDoc"] = self.includeJSDoc
        data["parseMode"] = self.parseMode
        data["batch"] = self.batch
        data["sources"] = self.sources
        data["batchInputKey"] = self.batchInputKey
        return data



@dataclass(frozen=True)
class UserResponseNode(BaseExecutableNode):
    # Required node-specific fields
    prompt: str
    # Type field with default
    type: NodeType = field(default=NodeType.USER_RESPONSE, init=False)
    # Base optional fields
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    # Optional execution policy fields
    join_policy: Optional[str] = None  # "all", "any", "k_of_n"
    join_k: Optional[int] = None  # For k_of_n policy
    # Optional node-specific fields
    timeout: int = 300

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["type"] = self.type.value
        data["label"] = self.label
        data["flipped"] = self.flipped
        if self.metadata:
            data["metadata"] = self.metadata
        # Include join policy if set
        if self.join_policy is not None:
            data["join_policy"] = self.join_policy
        if self.join_k is not None:
            data["join_k"] = self.join_k
        data["prompt"] = self.prompt
        data["timeout"] = self.timeout
        return data



@dataclass(frozen=True)
class PersonBatchJobNode(PersonJobNode):
    """Person batch job node - same as PersonJobNode but with different type."""
    type: NodeType = field(default=NodeType.PERSON_BATCH_JOB, init=False)


ExecutableNode = Union[
    ApiJobNode,
    CodeJobNode,
    ConditionNode,
    DBNode,
    EndpointNode,
    HookNode,
    IntegratedApiNode,
    JsonSchemaValidatorNode,
    PersonJobNode,
    StartNode,
    SubDiagramNode,
    TemplateJobNode,
    TypescriptAstNode,
    UserResponseNode,
    PersonBatchJobNode
]


def create_executable_node(
    node_type: NodeType,
    node_id: NodeID,
    position: Vec2,
    label: str = "",
    data: Optional[Dict[str, Any]] = None,
    flipped: bool = False,
    metadata: Optional[Dict[str, Any]] = None
) -> ExecutableNode:
    """Factory function to create typed executable nodes from diagram data."""
    data = data or {}

    if node_type == NodeType.API_JOB:
        return ApiJobNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            url=data.get("url"),
            method=data.get("method"),
            headers=data.get("headers"),
            params=data.get("params"),
            body=data.get("body"),
            timeout=data.get("timeout"),
            auth_type=data.get("auth_type"),
            auth_config=data.get("auth_config"),
        )
    

    if node_type == NodeType.CODE_JOB:
        return CodeJobNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            language=data.get("language"),
            filePath=data.get("filePath"),
            code=data.get("code"),
            functionName=data.get("functionName"),
            timeout=data.get("timeout"),
        )
    

    if node_type == NodeType.CONDITION:
        return ConditionNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            condition_type=data.get("condition_type", "custom"),
            expression=data.get("expression"),
            node_indices=data.get("node_indices"),
            expose_index_as=data.get("expose_index_as"),
            skippable=data.get("skippable", False),
            person=data.get("person"),
            judge_by=data.get("judge_by"),
            judge_by_file=data.get("judge_by_file"),
            memorize_to=data.get("memorize_to", "GOLDFISH"),
            at_most=data.get("at_most"),
        )
    

    if node_type == NodeType.DB:
        return DBNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            file=data.get("file"),
            collection=data.get("collection"),
            sub_type=data.get("sub_type"),
            operation=data.get("operation"),
            query=data.get("query"),
            data=data.get("data"),
            serialize_json=data.get("serialize_json", False),
            glob=data.get("glob"),
            format=data.get("format", "json"),
        )
    

    if node_type == NodeType.ENDPOINT:
        return EndpointNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            save_to_file=data.get("save_to_file"),
            file_name=data.get("file_name"),
        )
    

    if node_type == NodeType.HOOK:
        return HookNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            hook_type=data.get("hook_type", "shell"),
            command=data.get("command"),
            args=data.get("args"),
            env=data.get("env"),
            cwd=data.get("cwd"),
            url=data.get("url"),
            method=data.get("method"),
            headers=data.get("headers"),
            script=data.get("script"),
            function_name=data.get("function_name"),
            file_path=data.get("file_path"),
            format=data.get("format"),
            timeout=data.get("timeout", 60),
            retry_count=data.get("retry_count", 0),
            retry_delay=data.get("retry_delay"),
        )
    

    if node_type == NodeType.INTEGRATED_API:
        return IntegratedApiNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            provider=data.get("provider"),
            operation=data.get("operation"),
            config=data.get("config"),
            resource_id=data.get("resource_id"),
            timeout=data.get("timeout"),
            max_retries=data.get("max_retries"),
        )
    

    if node_type == NodeType.JSON_SCHEMA_VALIDATOR:
        return JsonSchemaValidatorNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            schema_path=data.get("schema_path"),
            json_schema=data.get("json_schema"),
            data_path=data.get("data_path"),
            strict_mode=data.get("strict_mode"),
            error_on_extra=data.get("error_on_extra"),
        )
    

    if node_type == NodeType.PERSON_JOB:
        return PersonJobNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            person=data.get("person"),
            first_only_prompt=data.get("first_only_prompt"),
            first_prompt_file=data.get("first_prompt_file"),
            default_prompt=data.get("default_prompt"),
            prompt_file=data.get("prompt_file"),
            max_iteration=data.get("max_iteration", 100),
            memorize_to=data.get("memorize_to"),
            at_most=data.get("at_most"),
            tools=data.get("tools", "none"),
            text_format=data.get("text_format"),
            text_format_file=data.get("text_format_file"),
            batch=data.get("batch"),
            batch_input_key=data.get("batch_input_key"),
            batch_parallel=data.get("batch_parallel"),
            max_concurrent=data.get("max_concurrent"),
        )
    

    if node_type == NodeType.START:
        return StartNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            trigger_mode=data.get("trigger_mode", "none"),
            custom_data=data.get("custom_data"),
            output_data_structure=data.get("output_data_structure"),
            hook_event=data.get("hook_event"),
            hook_filters=data.get("hook_filters"),
        )
    

    if node_type == NodeType.SUB_DIAGRAM:
        return SubDiagramNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            diagram_name=data.get("diagram_name"),
            diagram_format=data.get("diagram_format"),
            diagram_data=data.get("diagram_data"),
            passInputData=data.get("passInputData"),
            batch=data.get("batch", False),
            batch_input_key=data.get("batch_input_key"),
            batch_parallel=data.get("batch_parallel", False),
            ignoreIfSub=data.get("ignoreIfSub", False),
        )
    

    if node_type == NodeType.TEMPLATE_JOB:
        return TemplateJobNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            template_path=data.get("template_path"),
            template_content=data.get("template_content"),
            output_path=data.get("output_path"),
            variables=data.get("variables"),
            engine=data.get("engine", "jinja2"),
            foreach=data.get("foreach"),
            preprocessor=data.get("preprocessor"),
        )
    

    if node_type == NodeType.TYPESCRIPT_AST:
        return TypescriptAstNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            source=data.get("source"),
            extractPatterns=data.get("extractPatterns"),
            includeJSDoc=data.get("includeJSDoc", False),
            parseMode=data.get("parseMode", "module"),
            batch=data.get("batch"),
            sources=data.get("sources"),
            batchInputKey=data.get("batchInputKey"),
        )
    

    if node_type == NodeType.USER_RESPONSE:
        return UserResponseNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            prompt=data.get("prompt"),
            timeout=data.get("timeout", 300),
        )
    

    if node_type == NodeType.PERSON_BATCH_JOB:
        return PersonBatchJobNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            join_policy=data.get("join_policy"),
            join_k=data.get("join_k"),
            person=data.get("person"),
            first_only_prompt=data.get("first_only_prompt"),
            first_prompt_file=data.get("first_prompt_file"),
            default_prompt=data.get("default_prompt"),
            prompt_file=data.get("prompt_file"),
            max_iteration=data.get("max_iteration", 100),
            memorize_to=data.get("memorize_to"),
            at_most=data.get("at_most"),
            tools=data.get("tools", "none"),
            text_format=data.get("text_format"),
            text_format_file=data.get("text_format_file"),
            batch=data.get("batch"),
            batch_input_key=data.get("batch_input_key"),
            batch_parallel=data.get("batch_parallel"),
            max_concurrent=data.get("max_concurrent"),
        )
    
    raise ValueError(f"Unknown node type: {node_type}")