"""
Auto-generated static node types from domain models.
DO NOT EDIT THIS FILE DIRECTLY.
Generated by: dipeo/models/scripts/generate-static-nodes.ts
"""

from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, Union, Literal

from dipeo.models.models import (
    NodeType, Vec2, NodeID, PersonID, MemoryConfig, MemorySettings, ToolConfig,
    HookTriggerMode, SupportedLanguage, HttpMethod, DBBlockSubType,
    NotionOperation, HookType, PersonLLMConfig, LLMService, DiagramFormat
)


@dataclass(frozen=True)
class BaseExecutableNode:
    """Base class for all executable node types."""
    id: NodeID
    type: NodeType
    position: Vec2
    label: str = ""
    flipped: bool = False
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        result = {
            "id": self.id,
            "type": self.type.value,
            "position": {"x": self.position.x, "y": self.position.y},
            "label": self.label,
            "flipped": self.flipped
        }
        if self.metadata:
            result["metadata"] = self.metadata
        return result


@dataclass(frozen=True)
class StartNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.start, init=False)
    custom_data: Dict[str, Union[str, int, bool]] = field(default_factory=dict)
    output_data_structure: Dict[str, str] = field(default_factory=dict)
    trigger_mode: Optional[HookTriggerMode] = None
    hook_event: Optional[str] = None
    hook_filters: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["custom_data"] = self.custom_data
        data["output_data_structure"] = self.output_data_structure
        data["trigger_mode"] = self.trigger_mode
        data["hook_event"] = self.hook_event
        data["hook_filters"] = self.hook_filters
        return data

@dataclass(frozen=True)
class EndpointNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.endpoint, init=False)
    save_to_file: bool = False
    file_name: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["save_to_file"] = self.save_to_file
        data["file_name"] = self.file_name
        return data

@dataclass(frozen=True)
class PersonJobNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.person_job, init=False)
    person_id: Optional[PersonID] = None
    first_only_prompt: str = ""
    default_prompt: Optional[str] = None
    max_iteration: int = 1
    memory_config: Optional[MemoryConfig] = None
    memory_settings: Optional[MemorySettings] = None
    tools: Optional[List[ToolConfig]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["person"] = self.person_id
        data["first_only_prompt"] = self.first_only_prompt
        data["default_prompt"] = self.default_prompt
        data["max_iteration"] = self.max_iteration
        data["memory_config"] = self.memory_config
        data["memory_settings"] = self.memory_settings
        data["tools"] = self.tools
        return data

@dataclass(frozen=True)
class ConditionNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.condition, init=False)
    condition_type: str = ""
    expression: Optional[str] = None
    node_indices: Optional[List[str]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["condition_type"] = self.condition_type
        data["expression"] = self.expression
        data["node_indices"] = self.node_indices
        return data

@dataclass(frozen=True)
class CodeJobNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.code_job, init=False)
    language: SupportedLanguage = SupportedLanguage.python
    filePath: Optional[str] = None
    code: Optional[str] = None
    functionName: Optional[str] = None
    timeout: Optional[int] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["language"] = self.language
        data["filePath"] = self.filePath
        data["code"] = self.code
        data["functionName"] = self.functionName
        data["timeout"] = self.timeout
        return data

@dataclass(frozen=True)
class ApiJobNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.api_job, init=False)
    url: str = ""
    method: HttpMethod = HttpMethod.GET
    headers: Optional[Dict[str, str]] = None
    params: Optional[Dict[str, Any]] = None
    body: Optional[Any] = None
    timeout: Optional[int] = None
    auth_type: Optional[Literal["none", "bearer", "basic", "api_key"]] = None
    auth_config: Optional[Dict[str, str]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["url"] = self.url
        data["method"] = self.method
        data["headers"] = self.headers
        data["params"] = self.params
        data["body"] = self.body
        data["timeout"] = self.timeout
        data["auth_type"] = self.auth_type
        data["auth_config"] = self.auth_config
        return data

@dataclass(frozen=True)
class DBNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.db, init=False)
    file: Optional[str] = None
    collection: Optional[str] = None
    sub_type: DBBlockSubType = DBBlockSubType.fixed_prompt
    operation: str = ""
    query: Optional[str] = None
    data: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["file"] = self.file
        data["collection"] = self.collection
        data["sub_type"] = self.sub_type
        data["operation"] = self.operation
        data["query"] = self.query
        data["data"] = self.data
        return data

@dataclass(frozen=True)
class UserResponseNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.user_response, init=False)
    prompt: str = ""
    timeout: int = 60

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["prompt"] = self.prompt
        data["timeout"] = self.timeout
        return data

@dataclass(frozen=True)
class NotionNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.notion, init=False)
    operation: NotionOperation = NotionOperation.read_page
    page_id: Optional[str] = None
    database_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["operation"] = self.operation
        data["page_id"] = self.page_id
        data["database_id"] = self.database_id
        return data

@dataclass(frozen=True)
class HookNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.hook, init=False)
    hook_type: HookType = HookType.shell
    config: Dict[str, Any] = field(default_factory=dict)
    timeout: Optional[int] = None
    retry_count: Optional[int] = None
    retry_delay: Optional[int] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["hook_type"] = self.hook_type
        data["config"] = self.config
        data["timeout"] = self.timeout
        data["retry_count"] = self.retry_count
        data["retry_delay"] = self.retry_delay
        return data

@dataclass(frozen=True)
class TemplateJobNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.template_job, init=False)
    template_path: Optional[str] = None
    template_content: Optional[str] = None
    output_path: Optional[str] = None
    variables: Optional[Dict[str, Any]] = None
    engine: Optional[Literal["internal", "jinja2", "handlebars"]] = "internal"

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["template_path"] = self.template_path
        data["template_content"] = self.template_content
        data["output_path"] = self.output_path
        data["variables"] = self.variables
        data["engine"] = self.engine
        return data

@dataclass(frozen=True)
class JsonSchemaValidatorNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.json_schema_validator, init=False)
    schema_path: Optional[str] = None
    schema: Optional[Dict[str, Any]] = None
    data_path: Optional[str] = None
    strict_mode: Optional[bool] = False
    error_on_extra: Optional[bool] = False

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["schema_path"] = self.schema_path
        data["schema"] = self.schema
        data["data_path"] = self.data_path
        data["strict_mode"] = self.strict_mode
        data["error_on_extra"] = self.error_on_extra
        return data

@dataclass(frozen=True)
class TypescriptAstNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.typescript_ast, init=False)
    source: Optional[str] = None
    extractPatterns: Optional[List[str]] = field(default_factory=lambda: ["interface", "type", "enum"])
    includeJSDoc: Optional[bool] = False
    parseMode: Optional[Literal["module", "script"]] = "module"

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["source"] = self.source
        data["extractPatterns"] = self.extractPatterns
        data["includeJSDoc"] = self.includeJSDoc
        data["parseMode"] = self.parseMode
        return data

@dataclass(frozen=True)
class SubDiagramNode(BaseExecutableNode):
    type: NodeType = field(default=NodeType.sub_diagram, init=False)
    diagram_name: Optional[str] = None
    diagram_format: Optional[DiagramFormat] = None
    diagram_data: Optional[Dict[str, Any]] = None
    input_mapping: Optional[Dict[str, str]] = None
    output_mapping: Optional[Dict[str, str]] = None
    timeout: Optional[int] = None
    wait_for_completion: Optional[bool] = True
    isolate_conversation: Optional[bool] = False

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        data = super().to_dict()
        data["diagram_name"] = self.diagram_name
        data["diagram_format"] = self.diagram_format
        data["diagram_data"] = self.diagram_data
        data["input_mapping"] = self.input_mapping
        data["output_mapping"] = self.output_mapping
        data["timeout"] = self.timeout
        data["wait_for_completion"] = self.wait_for_completion
        data["isolate_conversation"] = self.isolate_conversation
        return data

@dataclass(frozen=True)
class PersonBatchJobNode(PersonJobNode):
    """Person batch job node - same as PersonJobNode but with different type."""
    type: NodeType = field(default=NodeType.person_batch_job, init=False)


ExecutableNode = Union[
    StartNode,
    EndpointNode,
    PersonJobNode,
    ConditionNode,
    CodeJobNode,
    ApiJobNode,
    DBNode,
    UserResponseNode,
    NotionNode,
    PersonBatchJobNode,
    HookNode
]


def create_executable_node(
    node_type: NodeType,
    node_id: NodeID,
    position: Vec2,
    label: str = "",
    data: Optional[Dict[str, Any]] = None,
    flipped: bool = False,
    metadata: Optional[Dict[str, Any]] = None
) -> ExecutableNode:
    """Factory function to create typed executable nodes from diagram data."""
    data = data or {}
    
    if node_type == NodeType.start:
        return StartNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            custom_data=data.get("custom_data"),
            output_data_structure=data.get("output_data_structure"),
            trigger_mode=data.get("trigger_mode"),
            hook_event=data.get("hook_event"),
            hook_filters=data.get("hook_filters"),
        )
    
    if node_type == NodeType.endpoint:
        return EndpointNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            save_to_file=data.get("save_to_file", False),
            file_name=data.get("file_name"),
        )
    
    if node_type == NodeType.person_job:
        return PersonJobNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            person_id=data.get("person"),
            first_only_prompt=data.get("first_only_prompt", ""),
            default_prompt=data.get("default_prompt"),
            max_iteration=data.get("max_iteration", 1),
            memory_config=MemoryConfig(**data.get("memory_config")) if data.get("memory_config") else None,
            memory_settings=MemorySettings(**data.get("memory_settings")) if data.get("memory_settings") else None,
            tools=[ToolConfig(**tool) if isinstance(tool, dict) else tool for tool in data.get("tools", [])] if data.get("tools") else None,
        )
    
    if node_type == NodeType.condition:
        return ConditionNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            condition_type=data.get("condition_type", ""),
            expression=data.get("expression"),
            node_indices=data.get("node_indices"),
        )
    
    if node_type == NodeType.code_job:
        return CodeJobNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            language=data.get("language", SupportedLanguage.python),
            filePath=data.get("filePath"),
            code=data.get("code"),
            functionName=data.get("functionName"),
            timeout=data.get("timeout"),
        )
    
    if node_type == NodeType.api_job:
        return ApiJobNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            url=data.get("url", ""),
            method=data.get("method", HttpMethod.GET),
            headers=data.get("headers"),
            params=data.get("params"),
            body=data.get("body"),
            timeout=data.get("timeout"),
            auth_type=data.get("auth_type"),
            auth_config=data.get("auth_config"),
        )
    
    if node_type == NodeType.db:
        return DBNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            file=data.get("file"),
            collection=data.get("collection"),
            sub_type=data.get("sub_type", DBBlockSubType.fixed_prompt),
            operation=data.get("operation", ""),
            query=data.get("query"),
            data=data.get("data"),
        )
    
    if node_type == NodeType.user_response:
        return UserResponseNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            prompt=data.get("prompt", ""),
            timeout=data.get("timeout", 60),
        )
    
    if node_type == NodeType.notion:
        return NotionNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            operation=data.get("operation", NotionOperation.read_page),
            page_id=data.get("page_id"),
            database_id=data.get("database_id"),
        )
    
    if node_type == NodeType.hook:
        return HookNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            hook_type=data.get("hook_type", HookType.shell),
            config=data.get("config", {}),
            timeout=data.get("timeout"),
            retry_count=data.get("retry_count"),
            retry_delay=data.get("retry_delay"),
        )
    
    if node_type == NodeType.template_job:
        return TemplateJobNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            template_path=data.get("template_path"),
            template_content=data.get("template_content"),
            output_path=data.get("output_path"),
            variables=data.get("variables"),
            engine=data.get("engine", "internal"),
        )
    
    if node_type == NodeType.json_schema_validator:
        return JsonSchemaValidatorNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            schema_path=data.get("schema_path"),
            schema=data.get("schema"),
            data_path=data.get("data_path"),
            strict_mode=data.get("strict_mode", False),
            error_on_extra=data.get("error_on_extra", False),
        )
    
    if node_type == NodeType.typescript_ast:
        return TypescriptAstNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            source=data.get("source"),
            extractPatterns=data.get("extractPatterns"),
            includeJSDoc=data.get("includeJSDoc", False),
            parseMode=data.get("parseMode", "module"),
        )
    
    if node_type == NodeType.sub_diagram:
        return SubDiagramNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            diagram_name=data.get("diagram_name"),
            diagram_format=data.get("diagram_format"),
            diagram_data=data.get("diagram_data"),
            input_mapping=data.get("input_mapping"),
            output_mapping=data.get("output_mapping"),
            timeout=data.get("timeout"),
            wait_for_completion=data.get("wait_for_completion", True),
            isolate_conversation=data.get("isolate_conversation", False),
        )
    
    if node_type == NodeType.person_batch_job:
        return PersonBatchJobNode(
            id=node_id,
            position=position,
            label=label,
            flipped=flipped,
            metadata=metadata,
            person_id=data.get("person"),
            first_only_prompt=data.get("first_only_prompt", ""),
            default_prompt=data.get("default_prompt"),
            max_iteration=data.get("max_iteration", 1),
            memory_config=MemoryConfig(**data.get("memory_config")) if data.get("memory_config") else None,
            memory_settings=MemorySettings(**data.get("memory_settings")) if data.get("memory_settings") else None,
            tools=[ToolConfig(**tool) if isinstance(tool, dict) else tool for tool in data.get("tools", [])] if data.get("tools") else None
        )
    
    raise ValueError(f"Unknown node type: {node_type}")
