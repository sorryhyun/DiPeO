#!/usr/bin/env python3
"""
Generate typed GraphQL operations for the CLI from operations.graphql
"""

import re
from pathlib import Path


def parse_graphql_file(file_path: Path) -> list[tuple[str, str, str]]:
    """Parse GraphQL operations file and extract operations."""
    with open(file_path) as f:
        content = f.read()
    
    operations = []
    
    # Split content into lines and process
    lines = content.split('\n')
    i = 0
    
    while i < len(lines):
        line = lines[i].strip()
        
        # Check for operation start
        if line.startswith(('mutation', 'subscription')):
            # Parse operation type and name
            match = re.match(r'(mutation|subscription)\s+(\w+)\s*\(([^)]*)\)', line)
            if match:
                op_type = match.group(1)
                name = match.group(2)
                variables = match.group(3).strip()
                
                # Find the opening brace
                if '{' in line:
                    start_line = i
                else:
                    # Look for opening brace in next lines
                    i += 1
                    while i < len(lines) and '{' not in lines[i]:
                        i += 1
                    start_line = i
                
                # Now collect the operation body
                brace_count = 0
                body_lines = []
                j = start_line
                
                for j in range(start_line, len(lines)):
                    current_line = lines[j]
                    
                    # Count braces
                    brace_count += current_line.count('{')
                    brace_count -= current_line.count('}')
                    
                    # Add line to body (skip the first line if it only contains the opening)
                    if j == start_line:
                        # Extract part after the first {
                        idx = current_line.find('{')
                        if idx >= 0 and idx < len(current_line) - 1:
                            body_lines.append(current_line[idx+1:])
                    else:
                        body_lines.append(current_line)
                    
                    # Check if we've closed all braces
                    if brace_count == 0:
                        # Remove the last } from the body
                        if body_lines and '}' in body_lines[-1]:
                            last_line = body_lines[-1]
                            idx = last_line.rfind('}')
                            body_lines[-1] = last_line[:idx] + last_line[idx+1:]
                        break
                
                # Construct the full operation
                body = '\n'.join(body_lines).strip()
                full_operation = f"{op_type} {name}({variables}) {{\n{body}\n}}"
                operations.append((op_type, name, full_operation))
                
                i = j + 1
                continue
        
        i += 1
    
    return operations

def extract_variable_types(variables_str: str) -> dict[str, str]:
    """Extract variable names and types from GraphQL variable declarations."""
    var_pattern = r'\$(\w+):\s*([^,)!]+)(!?)'
    variables = {}
    for match in re.finditer(var_pattern, variables_str):
        var_name = match.group(1)
        var_type = match.group(2).strip()
        is_required = bool(match.group(3))
        # Map GraphQL types to Python types
        python_type = map_graphql_to_python_type(var_type)
        if not is_required:
            python_type = f"Optional[{python_type}]"
        variables[var_name] = python_type
    return variables

def map_graphql_to_python_type(graphql_type: str) -> str:
    """Map GraphQL types to Python types."""
    type_mapping = {
        'String': 'str',
        'Int': 'int',
        'Float': 'float',
        'Boolean': 'bool',
        'ID': 'str',
        'JSONScalar': 'Dict[str, Any]',
        'ExecutionID': 'str',
        'NodeID': 'str',
        'DiagramID': 'str',
        'DiagramFormat': 'DiagramFormat',
        'NodeType': 'NodeType',
        'ExecuteDiagramInput': 'Dict[str, Any]',
        'ExecutionControlInput': 'Dict[str, Any]',
        'InteractiveResponseInput': 'Dict[str, Any]',
    }
    
    # Handle arrays
    if graphql_type.startswith('[') and graphql_type.endswith(']'):
        inner_type = graphql_type[1:-1].strip()
        return f"List[{map_graphql_to_python_type(inner_type)}]"
    
    return type_mapping.get(graphql_type, 'Any')

def generate_python_operations(operations: list[tuple[str, str, str]]) -> str:
    """Generate Python code for GraphQL operations."""
    imports = [
        "from typing import Dict, Any, List, Optional",
        "from dipeo.domain.models import NodeType, DiagramFormat, ExecutionStatus",
        "",
        '"""',
        "Auto-generated typed GraphQL operations for CLI",
        "DO NOT EDIT THIS FILE DIRECTLY",
        "Generated from: apps/cli/src/dipeo_cli/graphql/operations.graphql",
        '"""',
        "",
        "# GraphQL operation strings",
        "",
    ]
    
    code_lines = imports[:]
    
    for op_type, name, query in operations:
        # Convert operation name to UPPER_SNAKE_CASE constant
        const_name = re.sub(r'(?<!^)(?=[A-Z])', '_', name).upper()
        
        # Add the operation string as a constant
        code_lines.append(f'{const_name}_{op_type.upper()} = """')
        code_lines.append(query)
        code_lines.append('"""')
        code_lines.append('')
    
    # Add operation mapping
    code_lines.append("# Operation mapping for easy access")
    code_lines.append("OPERATIONS = {")
    for op_type, name, _ in operations:
        const_name = re.sub(r'(?<!^)(?=[A-Z])', '_', name).upper()
        code_lines.append(f'    "{name}": {const_name}_{op_type.upper()},')
    code_lines.append("}")
    code_lines.append("")
    
    # Add typed operation functions
    code_lines.append("# Typed operation functions")
    code_lines.append("")
    
    for op_type, name, query in operations:
        # Extract variables from the query
        var_match = re.search(r'\(([^)]*)\)', query)
        if var_match:
            variables = extract_variable_types(var_match.group(1))
        else:
            variables = {}
        
        # Generate function signature
        func_name = re.sub(r'(?<!^)(?=[A-Z])', '_', name).lower()
        if variables:
            params = []
            for var_name, var_type in variables.items():
                params.append(f"{var_name}: {var_type}")
            func_signature = f"def get_{func_name}_variables({', '.join(params)}) -> Dict[str, Any]:"
        else:
            func_signature = f"def get_{func_name}_variables() -> Dict[str, Any]:"
        
        code_lines.append(func_signature)
        code_lines.append(f'    """Get variables for {name} {op_type}."""')
        
        if variables:
            code_lines.append("    return {")
            for var_name in variables:
                code_lines.append(f'        "{var_name}": {var_name},')
            code_lines.append("    }")
        else:
            code_lines.append("    return {}")
        code_lines.append("")
    
    return '\n'.join(code_lines)

def main():
    # Get paths
    cli_dir = Path(__file__).parent.parent
    operations_file = cli_dir / "src" / "dipeo_cli" / "graphql" / "operations.graphql"
    output_file = cli_dir / "src" / "dipeo_cli" / "__generated__" / "graphql_operations.py"
    
    # Ensure output directory exists
    output_file.parent.mkdir(exist_ok=True)
    
    # Parse operations
    operations = parse_graphql_file(operations_file)
    
    # Generate Python code
    python_code = generate_python_operations(operations)
    
    # Write output
    with open(output_file, 'w') as f:
        f.write(python_code)
    
    print(f"Generated {output_file}")
    print(f"Found {len(operations)} operations")

if __name__ == "__main__":
    main()
