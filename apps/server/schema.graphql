enum APIServiceType {
  OPENAI
  ANTHROPIC
  GOOGLE
  GEMINI
  BEDROCK
  VERTEX
  DEEPSEEK
  OLLAMA
  CLAUDE_CODE
}

type ApiJobDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  url: String!
  method: String!
  headers: JSON
  params: JSON
  body: JSON
  timeout: String
  auth_type: String
  auth_config: JSON
}

"""Unique identifier type for apikey entities"""
scalar ApiKeyID

type ApiKeyResult {
  success: Boolean!
  message: String
  error: String
  error_type: String
  envelope: JSON
  data: DomainApiKeyType
  api_key: DomainApiKeyType @deprecated(reason: "Use 'data' field instead")
}

"""Unique identifier type for arrow entities"""
scalar ArrowID

type CliSessionResult {
  success: Boolean!
  message: String
  error: String
  error_type: String
  envelope: JSON
  data: JSON
  session_id: String
  execution_id: String
}

type CodeJobDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  language: String!
  filePath: String
  code: String
  functionName: String
  timeout: String
}

type ConditionDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  condition_type: String
  expression: String
  node_indices: String
  person: String
  judge_by: String
  judge_by_file: String
  memorize_to: String
  at_most: String
  expose_index_as: String
  skippable: String
}

enum ContentType {
  RAW_TEXT
  CONVERSATION_STATE
  OBJECT
  EMPTY
  GENERIC
  VARIABLE
  BINARY
}

input CreateApiKeyInput {
  label: String!
  service: APIServiceType!
  key: String!
}

input CreateDiagramInput {
  name: String!
  description: String = null
  author: String = null
  tags: [String!]! = []
}

input CreateNodeInput {
  type: NodeType!
  position: Vec2Input!
  data: JSON!
}

input CreatePersonInput {
  label: String!
  llm_config: PersonLLMConfigInput!
  type: String! = "user"
}

enum DataType {
  ANY
  STRING
  NUMBER
  BOOLEAN
  OBJECT
  ARRAY
}

"""Date with time (isoformat)"""
scalar DateTime

type DbDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  file: JSON
  collection: String
  sub_type: String!
  operation: String!
  query: String
  data: JSON
  serialize_json: String
  format: String
}

type DeleteResult {
  success: Boolean!
  message: String
  error: String
  error_type: String
  envelope: JSON
  data: JSON
  deleted_id: String
  deleted_count: Int
}

input DiagramFilterInput {
  name: String = null
  author: String = null
  tags: [String!] = null
  created_after: DateTime = null
  created_before: DateTime = null
}

enum DiagramFormat {
  NATIVE
  LIGHT
  READABLE
}

enum DiagramFormatGraphQL {
  NATIVE
  LIGHT
  READABLE
}

"""Unique identifier type for diagram entities"""
scalar DiagramID

type DiagramMetadataType {
  id: String
  name: String
  description: String
  version: String!
  created: String!
  modified: String!
  author: String
  tags: [String!]
  format: String
}

type DiagramResult {
  success: Boolean!
  message: String
  error: String
  error_type: String
  envelope: JSON
  data: DomainDiagramType
  diagram: DomainDiagramType @deprecated(reason: "Use 'data' field instead")
}

type DomainApiKeyType {
  id: String!
  label: String!
  service: APIServiceType!
  key: String
}

type DomainArrowType {
  data: JSON
  id: String!
  source: String!
  target: String!
  content_type: ContentType
  label: String
}

type DomainDiagramType {
  nodeCount: Int!
  arrowCount: Int!
  nodes: [DomainNodeType!]!
  handles: [DomainHandleType!]!
  arrows: [DomainArrowType!]!
  persons: [DomainPersonType!]!
  metadata: DiagramMetadataType
}

type DomainHandleType {
  id: String!
  node_id: String!
  label: HandleLabel!
  direction: HandleDirection!
  data_type: DataType!
  position: String
}

type DomainNodeType {
  type: String!
  data: JSON!
  id: String!
  position: Vec2Type!
}

type DomainPersonType {
  type: String!
  id: String!
  label: String!
  llm_config: PersonLLMConfigType!
}

type EndpointDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  save_to_file: String!
  file_name: String
}

input ExecuteDiagramInput {
  diagram_id: ID = null
  diagram_data: JSON = null
  variables: JSON = null
  debug_mode: Boolean = null
  max_iterations: Int = null
  timeout_seconds: Int = null
  use_unified_monitoring: Boolean = null
}

input ExecutionControlInput {
  execution_id: ID!
  action: String!
  reason: String = null
}

input ExecutionFilterInput {
  diagram_id: ID = null
  status: Status = null
  started_after: DateTime = null
  started_before: DateTime = null
}

"""Unique identifier type for execution entities"""
scalar ExecutionID

type ExecutionResult {
  success: Boolean!
  message: String
  error: String
  error_type: String
  envelope: JSON
  data: ExecutionStateType
  execution: ExecutionStateType @deprecated(reason: "Use 'data' field instead")
}

type ExecutionStateType {
  node_states: JSON!
  node_outputs: JSON!
  variables: JSON
  exec_counts: JSON!
  metrics: JSON
  id: String!
  status: Status!
  diagram_id: String
  started_at: String!
  ended_at: String
  llm_usage: LLMUsageType!
  error: String
  duration_seconds: Float
  is_active: Boolean
  executed_nodes: [String!]!
}

type ExecutionUpdate {
  execution_id: String!
  event_type: String!
  data: JSON!
  timestamp: String!
}

type FormatConversionResult {
  success: Boolean!
  message: String
  error: String
  error_type: String
  envelope: JSON
  data: String
  format: String
  original_format: String
}

enum HandleDirection {
  INPUT
  OUTPUT
}

"""Unique identifier type for handle entities"""
scalar HandleID

enum HandleLabel {
  DEFAULT
  FIRST
  CONDTRUE
  CONDFALSE
  SUCCESS
  ERROR
  RESULTS
}

type HookDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  hook_type: String!
  command: String
  url: String
  timeout: String
  retry_count: String
}

"""Unique identifier type for hook entities"""
scalar HookID

type IntegratedApiDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  provider: String!
  operation: String!
  resource_id: String
  config: JSON
  timeout: String
  max_retries: String
}

input InteractiveResponseInput {
  execution_id: ID!
  node_id: ID!
  response: String!
  metadata: JSON = null
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf).
"""
scalar JSON @specifiedBy(url: "https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf")

type JsonSchemaValidatorDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  schema_path: String
  schema: JSON
  data_path: String
  strict_mode: String
  error_on_extra: String
}

enum LLMService {
  OPENAI
  ANTHROPIC
  CLAUDE_CODE
  GOOGLE
  GEMINI
  BEDROCK
  VERTEX
  DEEPSEEK
  OLLAMA
}

type LLMUsageType {
  input: Int!
  output: Int!
  cached: Int
  total: Int
}

type Mutation {
  control_execution(input: ExecutionControlInput!): ExecutionResult!
  convert_diagram_format(content: String!, from_format: DiagramFormatGraphQL!, to_format: DiagramFormatGraphQL!): FormatConversionResult!
  create_api_key(input: CreateApiKeyInput!): ApiKeyResult!
  create_diagram(input: CreateDiagramInput!): DiagramResult!
  create_node(diagram_id: ID!, input: CreateNodeInput!): NodeResult!
  create_person(input: CreatePersonInput!): PersonResult!
  delete_api_key(api_key_id: ID!): DeleteResult!
  delete_diagram(diagram_id: ID!): DeleteResult!
  delete_node(diagram_id: ID!, node_id: ID!): DeleteResult!
  delete_person(person_id: ID!): DeleteResult!
  execute_diagram(input: ExecuteDiagramInput!): ExecutionResult!
  register_cli_session(input: RegisterCliSessionInput!): CliSessionResult!
  send_interactive_response(input: InteractiveResponseInput!): ExecutionResult!
  test_api_key(api_key_id: ID!): ApiKeyResult!
  unregister_cli_session(input: UnregisterCliSessionInput!): CliSessionResult!
  update_node(diagram_id: ID!, node_id: ID!, input: UpdateNodeInput!): NodeResult!
  update_node_state(input: UpdateNodeStateInput!): ExecutionResult!
  update_person(person_id: ID!, input: UpdatePersonInput!): PersonResult!
  upload_diagram(file: String!, format: DiagramFormatGraphQL!): JSON!
  upload_file(file: String!, path: String): JSON!
  validate_diagram(content: String!, format: DiagramFormatGraphQL!): JSON!
}

"""Unique identifier type for node entities"""
scalar NodeID

type NodeResult {
  success: Boolean!
  message: String
  error: String
  error_type: String
  envelope: JSON
  data: DomainNodeType
  node: DomainNodeType @deprecated(reason: "Use 'data' field instead")
}

enum NodeType {
  START
  PERSON_JOB
  CONDITION
  CODE_JOB
  API_JOB
  ENDPOINT
  DB
  USER_RESPONSE
  HOOK
  TEMPLATE_JOB
  JSON_SCHEMA_VALIDATOR
  TYPESCRIPT_AST
  SUB_DIAGRAM
  INTEGRATED_API
}

"""Unique identifier type for person entities"""
scalar PersonID

type PersonJobDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  person: String
  first_only_prompt: String!
  first_prompt_file: String
  default_prompt: String
  prompt_file: String
  max_iteration: String!
  memorize_to: String
  at_most: String
  ignore_person: String
  tools: String
  text_format: String
  text_format_file: String
  resolved_prompt: String
  resolved_first_prompt: String
  batch: String
  batch_input_key: String
  batch_parallel: String
  max_concurrent: String
}

input PersonLLMConfigInput {
  service: LLMService!
  model: String!
  api_key_id: ID!
  system_prompt: String = null
}

type PersonLLMConfigType {
  service: LLMService!
  model: String!
  api_key_id: String!
  system_prompt: String
  prompt_file: String
}

type PersonResult {
  success: Boolean!
  message: String
  error: String
  error_type: String
  envelope: JSON
  data: DomainPersonType
  person: DomainPersonType @deprecated(reason: "Use 'data' field instead")
}

type Query {
  get_active_cli_session: JSON! @deprecated(reason: "Use 'active_cli_session' instead")
  active_cli_session: JSON!
  get_api_key(api_key_id: ID!): DomainApiKeyType! @deprecated(reason: "Use 'api_key' instead")
  api_key(api_key_id: ID!): DomainApiKeyType!
  get_api_keys(service: String): JSON! @deprecated(reason: "Use 'api_keys' instead")
  api_keys(service: String): JSON!
  get_available_models(service: String!, api_key_id: ID!): JSON! @deprecated(reason: "Use 'available_models' instead")
  available_models(service: String!, api_key_id: ID!): JSON!
  get_diagram(diagram_id: ID!): DomainDiagramType! @deprecated(reason: "Use 'diagram' instead")
  diagram(diagram_id: ID!): DomainDiagramType!
  get_execution(execution_id: ID!): ExecutionStateType! @deprecated(reason: "Use 'execution' instead")
  execution(execution_id: ID!): ExecutionStateType!
  get_execution_capabilities: JSON! @deprecated(reason: "Use 'execution_capabilities' instead")
  execution_capabilities: JSON!
  get_execution_history(diagram_id: ID, limit: Int, include_metrics: Boolean): JSON! @deprecated(reason: "Use 'execution_history' instead")
  execution_history(diagram_id: ID, limit: Int, include_metrics: Boolean): JSON!
  get_execution_metrics(execution_id: ID!): JSON! @deprecated(reason: "Use 'execution_metrics' instead")
  execution_metrics(execution_id: ID!): JSON!
  get_execution_order(execution_id: ID!): JSON! @deprecated(reason: "Use 'execution_order' instead")
  execution_order(execution_id: ID!): JSON!
  get_operation_schema(provider: String!, operation: String!): JSON! @deprecated(reason: "Use 'operation_schema' instead")
  operation_schema(provider: String!, operation: String!): JSON!
  get_person(person_id: ID!): DomainPersonType! @deprecated(reason: "Use 'person' instead")
  person(person_id: ID!): DomainPersonType!
  get_prompt_file(filename: String!): JSON! @deprecated(reason: "Use 'prompt_file' instead")
  prompt_file(filename: String!): JSON!
  get_provider_operations(provider: String!): JSON! @deprecated(reason: "Use 'provider_operations' instead")
  provider_operations(provider: String!): JSON!
  get_providers: JSON! @deprecated(reason: "Use 'providers' instead")
  providers: JSON!
  get_supported_formats: JSON! @deprecated(reason: "Use 'supported_formats' instead")
  supported_formats: JSON!
  get_system_info: JSON! @deprecated(reason: "Use 'system_info' instead")
  system_info: JSON!
  health_check: JSON!
  list_conversations(person_id: ID, execution_id: ID, search: String, show_forgotten: Boolean, limit: Int, offset: Int, since: String): [JSON!]! @deprecated(reason: "Use 'conversations' instead")
  conversations(person_id: ID, execution_id: ID, search: String, show_forgotten: Boolean, limit: Int, offset: Int, since: String): [JSON!]!
  list_diagrams(filter: DiagramFilterInput, limit: Int, offset: Int): [DomainDiagramType!]! @deprecated(reason: "Use 'diagrams' instead")
  diagrams(filter: DiagramFilterInput, limit: Int, offset: Int): [DomainDiagramType!]!
  list_executions(filter: ExecutionFilterInput, limit: Int, offset: Int): [ExecutionStateType!]! @deprecated(reason: "Use 'executions' instead")
  executions(filter: ExecutionFilterInput, limit: Int, offset: Int): [ExecutionStateType!]!
  list_persons(limit: Int): [DomainPersonType!]! @deprecated(reason: "Use 'persons' instead")
  persons(limit: Int): [DomainPersonType!]!
  list_prompt_files: [JSON!]! @deprecated(reason: "Use 'prompt_files' instead")
  prompt_files: [JSON!]!
}

input RegisterCliSessionInput {
  execution_id: String!
  diagram_name: String!
  diagram_format: DiagramFormat!
  diagram_data: JSON = null
  diagram_path: String = null
}

type StartDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  trigger_mode: String
  custom_data: JSON
  output_data_structure: JSON
  hook_event: String
  hook_filters: JSON
}

enum Status {
  PENDING
  RUNNING
  PAUSED
  COMPLETED
  FAILED
  ABORTED
  SKIPPED
  MAXITER_REACHED
}

type SubDiagramDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  diagram_name: String
  diagram_data: JSON
  input_mapping: JSON
  output_mapping: JSON
  timeout: String
  wait_for_completion: String
  isolate_conversation: String
  ignoreIfSub: String
  diagram_format: String
  batch: String
  batch_input_key: String
  batch_parallel: String
}

type Subscription {
  execution_updates(execution_id: ID!): ExecutionUpdate!
}

"""Unique identifier type for task entities"""
scalar TaskID

type TemplateJobDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  template_path: String
  template_content: String
  output_path: String
  variables: JSON
  engine: String
  preprocessor: String
}

type TypescriptAstDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  source: String!
  extractPatterns: String
  includeJSDoc: String
  parseMode: String
  transformEnums: String
  flattenOutput: String
  outputFormat: String
  batch: String
  batchInputKey: String
}

input UnregisterCliSessionInput {
  execution_id: String!
}

input UpdateNodeInput {
  position: Vec2Input = null
  data: JSON = null
}

input UpdateNodeStateInput {
  execution_id: ID!
  node_id: ID!
  status: Status!
  output: JSON = null
  error: String = null
}

input UpdatePersonInput {
  label: String = null
  llm_config: PersonLLMConfigInput = null
}

type UserResponseDataType {
  id: NodeID!
  position: Vec2Type!
  label: String
  flipped: Boolean
  metadata: JSON
  prompt: String!
  timeout: String
}

input Vec2Input {
  x: Float!
  y: Float!
}

type Vec2Type {
  x: Int!
  y: Int!
}
