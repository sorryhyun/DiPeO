{
  "overview": "The core kernel provides the single source of truth for domain types, runtime configuration, cross-cutting eventing, extension hooks, dependency injection tokens and small utilities. All application sections (providers, services, hooks, pages, components) should import types and singletons from these files. The kernel is minimal but type-safe, enabling decoupled communication (EventBus), extensibility (HookRegistry), and testable service swapping (DI container).",
  "files": [
    {
      "file_path": "src/core/contracts.ts",
      "purpose": "Domain types and shared TypeScript contracts used across the app (healthcare models, API result shapes, UI helper types, auth types and app config shapes). Central single source of truth for all domain typing.",
      "exports": [
        "User, Role, Patient, Doctor, Nurse",
        "Appointment, MedicalRecord, Prescription, LabResult",
        "AuthToken, LoginRequest, ApiResult<T>, ApiError, PaginatedResponse<T>",
        "WebSocketEvent, WebSocketEventMap",
        "LoadingState, FormState, AppConfig"
      ],
      "content": "/* src/core/contracts.ts\n\nThis file centralizes domain types used throughout the app. Keep types strict and descriptive. Use discriminated unions for role-specific users and maintain stable API shapes.\n\nUsage: import { User, ApiResult } from '@/core/contracts'\n*/\n\n// Basic role enumeration\nexport type Role = 'admin' | 'doctor' | 'nurse' | 'patient' | 'guest';\n\n// Generic small ID type\nexport type ID = string;\n\n// Authentication related\nexport interface AuthToken {\n  accessToken: string;\n  refreshToken?: string;\n  expiresAt?: string; // ISO timestamp\n}\n\nexport interface LoginRequest {\n  email: string;\n  password: string;\n  remember?: boolean;\n}\n\n// User base and role-specific user models\nexport interface UserBase {\n  id: ID;\n  email: string;\n  fullName: string;\n  role: Role;\n  avatarUrl?: string;\n  createdAt: string; // ISO\n  updatedAt?: string; // ISO\n}\n\nexport interface Patient extends UserBase {\n  role: 'patient';\n  dateOfBirth?: string; // ISO\n  medicalRecordId?: ID;\n  primaryDoctorId?: ID | null;\n}\n\nexport interface Doctor extends UserBase {\n  role: 'doctor';\n  specialty?: string;\n  licenseNumber?: string;\n}\n\nexport interface Nurse extends UserBase {\n  role: 'nurse';\n  department?: string;\n}\n\nexport type User = Patient | Doctor | Nurse | (UserBase & { role: 'admin' | 'guest' });\n\n// Healthcare domain models\nexport interface Appointment {\n  id: ID;\n  patientId: ID;\n  doctorId: ID;\n  scheduledAt: string; // ISO\n  durationMins?: number;\n  location?: string;\n  status: 'scheduled' | 'cancelled' | 'completed' | 'no_show';\n  notes?: string;\n}\n\nexport interface MedicalRecord {\n  id: ID;\n  patientId: ID;\n  summary?: string;\n  allergies?: string[];\n  conditions?: string[];\n  medications?: Prescription[];\n  lastUpdated: string; // ISO\n}\n\nexport interface Prescription {\n  id: ID;\n  medication: string;\n  dose?: string;\n  frequency?: string;\n  prescribedById?: ID;\n  issuedAt?: string; // ISO\n  notes?: string;\n}\n\nexport interface LabResult {\n  id: ID;\n  patientId: ID;\n  testName: string;\n  resultValue: string;\n  unit?: string;\n  normalRange?: string;\n  collectedAt?: string; // ISO\n  reportedAt?: string; // ISO\n}\n\n// API response shapes used by services/api.ts\nexport interface ApiError {\n  code?: string | number;\n  message: string;\n  details?: Record<string, unknown> | string;\n}\n\nexport interface ApiResult<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: ApiError;\n  meta?: Record<string, unknown>;\n}\n\nexport interface PaginatedResponse<T> {\n  items: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n}\n\n// WebSocket events (if app uses sockets)\nexport type WebSocketEventType =\n  | 'appointment.updated'\n  | 'labresult.added'\n  | 'prescription.updated'\n  | 'user.notification'\n  | 'system.heartbeat';\n\nexport interface WebSocketEvent<T = any> {\n  id: string;\n  type: WebSocketEventType;\n  payload: T;\n  timestamp: string; // ISO\n}\n\nexport interface WebSocketEventMap {\n  'appointment.updated': WebSocketEvent<Appointment>;\n  'labresult.added': WebSocketEvent<LabResult>;\n  'prescription.updated': WebSocketEvent<Prescription>;\n  'user.notification': WebSocketEvent<{ title: string; body?: string }>;\n  'system.heartbeat': WebSocketEvent<null>;\n}\n\n// UI helper types\nexport type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\nexport interface FormState<V = Record<string, unknown>> {\n  values: V;\n  errors: Partial<Record<keyof V, string>>;\n  touched: Partial<Record<keyof V, boolean>>;\n  isSubmitting: boolean;\n}\n\n// App configuration shape (mirrors src/app/config.ts runtime object)\nexport interface AppConfig {\n  env: 'development' | 'staging' | 'production';\n  apiBaseUrl: string;\n  socketUrl?: string;\n  featureFlags: Record<string, boolean>;\n  development_mode: {\n    enable_mock_data: boolean;\n  };\n  appName: string;\n  version?: string;\n}\n\n// Example named exports collected above are exported by default via 'export' usage.\n"
    },
    {
      "file_path": "src/app/config.ts",
      "purpose": "Materialized runtime configuration (apiBaseUrl, env, feature flags). Exposes a typed config object read by services and providers; computes effective flags and optionally provides mock data when development_mode.enable_mock_data is enabled.",
      "exports": [
        "default AppConfig object",
        "getConfig helper",
        "isFeatureEnabled helper",
        "MOCK_USER (only exported when mock data enabled)"
      ],
      "content": "/* src/app/config.ts\n\nMaterialized runtime configuration.\n- Keep the runtime values deterministic and serializable.\n- Provide computed helpers (isDevelopment, shouldUseMockData).\n- If development_mode.enable_mock_data is true, export a MOCK_USER to make local development easier.\n\nUsage: import config, { isFeatureEnabled } from '@/app/config'\n*/\n\nimport { AppConfig, User, Role } from '@/core/contracts';\n\n// NOTE: These values are intentionally baked in for development/demo runs.\n// In a real build you'd replace these using environment interpolation (process.env or injected JSON).\n\nconst rawConfig: AppConfig = {\n  env: (process.env.NODE_ENV as AppConfig['env']) || 'development',\n  apiBaseUrl: process.env.REACT_APP_API_BASE_URL || 'https://api.example.com',\n  socketUrl: process.env.REACT_APP_SOCKET_URL || 'wss://ws.example.com',\n  featureFlags: {\n    appointments: true,\n    telehealth: false,\n    labs: true,\n    prescriptions: true,\n    experimental_new_ui: false\n  },\n  development_mode: {\n    enable_mock_data: (process.env.REACT_APP_ENABLE_MOCK === 'true') || true\n  },\n  appName: 'Health Portal',\n  version: process.env.REACT_APP_VERSION || '0.0.0-dev'\n};\n\nexport default rawConfig;\n\nexport function getConfig(): AppConfig {\n  return rawConfig;\n}\n\nexport const isDevelopment = rawConfig.env === 'development';\nexport const shouldUseMockData = !!rawConfig.development_mode?.enable_mock_data;\n\nexport function isFeatureEnabled(featureName: string): boolean {\n  return !!rawConfig.featureFlags[featureName];\n}\n\n// Provide lightweight in-memory mock user for local development when enabled.\nexport const MOCK_USER: User | null = shouldUseMockData\n  ? {\n      id: 'mock-user-1',\n      email: 'jane.doe@example.com',\n      fullName: 'Jane Doe',\n      role: 'doctor',\n      specialty: 'General Medicine',\n      createdAt: new Date().toISOString(),\n      avatarUrl: undefined\n    }\n  : null;\n\n// Export a narrow helper for tests / startup code\nexport function getMockUser(): User | null {\n  return MOCK_USER;\n}\n"
    },
    {
      "file_path": "src/core/events.ts",
      "purpose": "A lightweight typed EventBus for cross-cutting pub/sub. Used by providers, services and features to react to global changes (login/logout, route changes, notifications).",
      "exports": [
        "EventBus instance",
        "on, off, emit helpers",
        "Event types: CoreEventMap, CoreEventKey"
      ],
      "content": "/* src/core/events.ts\n\nTyped EventBus implementation.\n- Supports synchronous and asynchronous handlers (handlers may return Promise).\n- Strongly typed event map ensures payloads are correct.\n- Exports a singleton `eventBus` to be used across the app.\n\nUsage:\n  import { eventBus } from '@/core/events'\n  eventBus.on('auth.login', payload => {...})\n  eventBus.emit('auth.logout')\n*/\n\nimport { User, Appointment, WebSocketEvent } from '@/core/contracts';\n\n// Define core event keys and payloads\nexport interface CoreEventMap {\n  'auth.login': { user: User };\n  'auth.logout': { reason?: string };\n  'profile.updated': { user: User };\n  'appointment.changed': { appointment: Appointment };\n  'route.change': { pathname: string; params?: Record<string, string> };\n  'notification': { title: string; body?: string; level?: 'info' | 'warn' | 'error' };\n  'ws.event': { event: WebSocketEvent };\n}\n\nexport type CoreEventKey = keyof CoreEventMap;\n\ntype Handler<E extends CoreEventKey> = (payload: CoreEventMap[E]) => void | Promise<void>;\n\nexport class EventBus {\n  private handlers: Map<string, Set<Function>> = new Map();\n\n  on<E extends CoreEventKey>(event: E, handler: Handler<E>): () => void {\n    const existing = this.handlers.get(event as string) || new Set<Function>();\n    existing.add(handler);\n    this.handlers.set(event as string, existing);\n\n    // return unsubscribe\n    return () => this.off(event, handler as any);\n  }\n\n  off<E extends CoreEventKey>(event: E, handler?: Handler<E>): void {\n    const set = this.handlers.get(event as string);\n    if (!set) return;\n    if (!handler) {\n      set.clear();\n      return;\n    }\n    set.delete(handler as Function);\n    if (set.size === 0) this.handlers.delete(event as string);\n  }\n\n  async emit<E extends CoreEventKey>(event: E, payload: CoreEventMap[E]): Promise<void> {\n    const set = this.handlers.get(event as string);\n    if (!set) return;\n\n    // Call handlers in registration order (iteration order of Set)\n    const promises: Promise<void>[] = [];\n    for (const fn of Array.from(set.values())) {\n      try {\n        const result = (fn as Handler<E>)(payload);\n        if (result && typeof (result as Promise<void>).then === 'function') {\n          promises.push(result as Promise<void>);\n        }\n      } catch (err) {\n        // swallow errors but log; do not rethrow to keep bus robust\n        // eslint-disable-next-line no-console\n        console.error('[EventBus] handler error for event', event, err);\n      }\n    }\n    if (promises.length > 0) {\n      await Promise.all(promises).catch(err => {\n        // eslint-disable-next-line no-console\n        console.error('[EventBus] async handler error', err);\n      });\n    }\n  }\n\n  once<E extends CoreEventKey>(event: E, handler: Handler<E>): () => void {\n    const remover = this.on(event, async (payload) => {\n      try {\n        await handler(payload as CoreEventMap[E]);\n      } finally {\n        remover();\n      }\n    });\n    return remover;\n  }\n}\n\n// Singleton instance used across the app\nexport const eventBus = new EventBus();\n\n// Convenience top-level helpers\nexport const on = <E extends CoreEventKey>(event: E, handler: Handler<E>) => eventBus.on(event, handler);\nexport const off = <E extends CoreEventKey>(event: E, handler?: Handler<E>) => eventBus.off(event, handler);\nexport const emit = async <E extends CoreEventKey>(event: E, payload: CoreEventMap[E]) => eventBus.emit(event, payload);\n"
    },
    {
      "file_path": "src/core/hooks.ts",
      "purpose": "Hook registry for extension points. Provides a typed, simple API to register extension callbacks and run them. Used by services and providers to offer extension points for plugins or features.\n\nStandard hooks implemented: beforeApiRequest, afterApiResponse, onLogin, onLogout, onRouteChange",
      "exports": [
        "registerHook, runHook functions",
        "Hook types: HookPoint, HookContext, HookCallback",
        "HookRegistry class and singleton"
      ],
      "content": "/* src/core/hooks.ts\n\nThe HookRegistry enables lightweight plugin-style extension points. Hooks are simple and may be synchronous or return a Promise.\n\n- registerHook returns an unregister function\n- runHook executes all listeners and returns aggregated results\n\nUsage:\n  import { registerHook, runHook } from '@/core/hooks'\n  registerHook('beforeApiRequest', ctx => { ctx.headers['x-trace-id']=... })\n  await runHook('beforeApiRequest', { url, method, headers })\n*/\n\nimport { ApiResult, User } from '@/core/contracts';\n\nexport type HookPoint =\n  | 'beforeApiRequest'\n  | 'afterApiResponse'\n  | 'onLogin'\n  | 'onLogout'\n  | 'onRouteChange';\n\n// Contexts per hook. Keep contexts minimal and stable.\nexport interface BeforeApiRequestContext {\n  url: string;\n  method: string;\n  headers: Record<string, string>;\n  body?: unknown;\n  // handlers may attach metadata\n  meta?: Record<string, unknown>;\n}\n\nexport interface AfterApiResponseContext<T = any> {\n  url: string;\n  method: string;\n  response: ApiResult<T>;\n  meta?: Record<string, unknown>;\n}\n\nexport interface OnLoginContext {\n  user: User;\n}\n\nexport interface OnLogoutContext {\n  reason?: string;\n}\n\nexport interface OnRouteChangeContext {\n  pathname: string;\n  params?: Record<string, string>;\n}\n\nexport type HookContextMap = {\n  beforeApiRequest: BeforeApiRequestContext;\n  afterApiResponse: AfterApiResponseContext;\n  onLogin: OnLoginContext;\n  onLogout: OnLogoutContext;\n  onRouteChange: OnRouteChangeContext;\n};\n\nexport type HookCallback<K extends HookPoint> = (ctx: HookContextMap[K]) => void | Promise<void>;\n\nexport class HookRegistry {\n  private store: Map<HookPoint, Set<Function>> = new Map();\n\n  register<K extends HookPoint>(hook: K, fn: HookCallback<K>): () => void {\n    const set = this.store.get(hook) || new Set<Function>();\n    set.add(fn);\n    this.store.set(hook, set);\n    return () => this.unregister(hook, fn as Function);\n  }\n\n  unregister(hook: HookPoint, fn?: Function): void {\n    const set = this.store.get(hook);\n    if (!set) return;\n    if (!fn) {\n      set.clear();\n      return;\n    }\n    set.delete(fn);\n    if (set.size === 0) this.store.delete(hook);\n  }\n\n  async run<K extends HookPoint>(hook: K, ctx: HookContextMap[K]): Promise<void> {\n    const set = this.store.get(hook);\n    if (!set || set.size === 0) return;\n    // Execute in registration order\n    const promises: Promise<void>[] = [];\n    for (const fn of Array.from(set.values())) {\n      try {\n        const result = (fn as HookCallback<K>)(ctx);\n        if (result && typeof (result as Promise<void>).then === 'function') {\n          promises.push(result as Promise<void>);\n        }\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('[HookRegistry] hook handler error', hook, err);\n      }\n    }\n    if (promises.length) {\n      await Promise.all(promises).catch(err => {\n        // eslint-disable-next-line no-console\n        console.error('[HookRegistry] async hook error', err);\n      });\n    }\n  }\n}\n\n// Singleton registry\nexport const hooks = new HookRegistry();\n\n// Convenience helpers\nexport function registerHook<K extends HookPoint>(hook: K, fn: HookCallback<K>): () => void {\n  return hooks.register(hook, fn as any);\n}\n\nexport function runHook<K extends HookPoint>(hook: K, ctx: HookContextMap[K]): Promise<void> {\n  return hooks.run(hook, ctx as any);\n}\n"
    },
    {
      "file_path": "src/core/di.ts",
      "purpose": "Minimal dependency injection / service registry that allows registering and resolving typed services. Useful for swapping implementations during tests or bootstrapping alternative implementations on startup.\n\nProvided tokens: ApiClientToken, AuthServiceToken, StorageServiceToken, WebSocketServiceToken",
      "exports": [
        "registerService, resolveService, resolveOptional, ServiceToken type",
        "Service tokens: ApiClientToken, AuthServiceToken, StorageServiceToken, WebSocketServiceToken",
        "Container class and default container instance"
      ],
      "content": "/* src/core/di.ts\n\nSimple, type-safe DI container using tokens (unique symbols). Register concrete implementations keyed by a token and resolve them later.\n\nPattern:\n  const token = createToken<MyService>('MyService')\n  container.register(token, new MyServiceImpl())\n  const svc = container.resolve(token)\n\nThis keeps runtime overhead low while enabling test swapping.\n*/\n\nexport type ServiceToken<T> = { readonly __token: unique symbol; readonly name?: string } & (symbol | string);\n\nexport function createToken<T>(name?: string): ServiceToken<T> {\n  const sym = Symbol(name || 'service');\n  // cast to ServiceToken<T>\n  return sym as unknown as ServiceToken<T>;\n}\n\nexport class Container {\n  private registry = new Map<ServiceToken<any>, any>();\n\n  register<T>(token: ServiceToken<T>, impl: T): void {\n    if (this.registry.has(token)) {\n      // allow idempotent re-registration in tests, but warn\n      // eslint-disable-next-line no-console\n      console.warn(`[DI] overriding registration for token: ${(token as any).toString?.() ?? String(token)}`);\n    }\n    this.registry.set(token, impl);\n  }\n\n  resolve<T>(token: ServiceToken<T>): T {\n    const impl = this.registry.get(token);\n    if (impl === undefined) {\n      throw new Error(`[DI] No registration found for token: ${(token as any).toString?.() ?? String(token)}`);\n    }\n    return impl as T;\n  }\n\n  resolveOptional<T>(token: ServiceToken<T>): T | undefined {\n    return this.registry.get(token) as T | undefined;\n  }\n\n  has(token: ServiceToken<any>): boolean {\n    return this.registry.has(token);\n  }\n\n  clear(): void {\n    this.registry.clear();\n  }\n}\n\n// Default global container (useful for app-wide registrations)\nexport const container = new Container();\n\n// Common tokens used across the app\nexport const ApiClientToken = createToken<any>('ApiClient');\nexport const AuthServiceToken = createToken<any>('AuthService');\nexport const StorageServiceToken = createToken<any>('StorageService');\nexport const WebSocketServiceToken = createToken<any>('WebSocketService');\n\n// Convenience wrappers\nexport function registerService<T>(token: ServiceToken<T>, impl: T): void {\n  container.register(token, impl);\n}\n\nexport function resolveService<T>(token: ServiceToken<T>): T {\n  return container.resolve(token);\n}\n\nexport function resolveOptional<T>(token: ServiceToken<T>): T | undefined {\n  return container.resolveOptional(token);\n}\n"
    },
    {
      "file_path": "src/core/utils.ts",
      "purpose": "Small utilities used across the app: formatDate, buildUrl, safeJsonParse, noop and light validation helpers. Keep functions pure and small.\n\nExported utilities are intentionally generic and zero-dependency.",
      "exports": [
        "formatDate, buildUrl, safeJsonParse, noop, isDefined"
      ],
      "content": "/* src/core/utils.ts\n\nGeneral utilities used across services and components.\n*/\n\nexport function noop(..._args: any[]): void {\n  // no operation - useful default callback\n}\n\nexport function isDefined<T>(v: T | null | undefined): v is T {\n  return v !== null && v !== undefined;\n}\n\nexport function safeJsonParse<T = any>(input: string | null | undefined, fallback?: T): T | undefined {\n  if (input == null) return fallback;\n  try {\n    return JSON.parse(input) as T;\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.warn('[safeJsonParse] failed to parse', err);\n    return fallback;\n  }\n}\n\nexport function safeJsonStringify(obj: unknown): string | undefined {\n  try {\n    return JSON.stringify(obj);\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.warn('[safeJsonStringify] failed to stringify', err);\n    return undefined;\n  }\n}\n\nexport function formatDate(iso?: string | Date, opts?: Intl.DateTimeFormatOptions): string {\n  if (!iso) return '';\n  const d = typeof iso === 'string' ? new Date(iso) : iso;\n  try {\n    return new Intl.DateTimeFormat(undefined, opts || { year: 'numeric', month: 'short', day: 'numeric' }).format(d);\n  } catch (err) {\n    // fallback\n    return d.toLocaleString();\n  }\n}\n\nexport function buildUrl(base: string, path?: string, query?: Record<string, string | number | undefined | null>): string {\n  const url = new URL(path ? path.replace(/^\\/+/, '') : '', base.endsWith('/') ? base : base + '/');\n  if (query) {\n    Object.entries(query).forEach(([k, v]) => {\n      if (v === undefined || v === null) return;\n      url.searchParams.set(k, String(v));\n    });\n  }\n  return url.toString();\n}\n"
    }
  ],
  "usage_guidelines": [
    "Import domain types from '@/core/contracts.ts' across services, hooks and components. Keep types immutable and serializable.",
    "Read runtime configuration from '@/app/config.ts'. Use isFeatureEnabled() for conditional features and MOCK_USER in development only.",
    "Use the event bus (eventBus) in '@/core/events.ts' for decoupled notifications; always prefer typed event keys.",
    "Register action-level extensions via '@/core/hooks.ts'. Example: registerHook('beforeApiRequest', ctx => { ctx.headers['x-trace'] = '...'; })",
    "Use the DI container '@/core/di.ts' to register platform implementations at startup (e.g., registerService(ApiClientToken, apiClient)) and resolve them in services or tests.",
    "Use small utils from '@/core/utils.ts' for safe JSON handling, URL building and date formatting to keep code consistent.",
    "When writing services, run hooks before requests and after responses (runHook('beforeApiRequest', ctx)) and emit events when global state changes (eventBus.emit('auth.login', { user }))."
  ]
}