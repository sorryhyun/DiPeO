{
  "overview": "The Core Kernel provides a small, well-typed foundation used by every section of the application: domain contracts, runtime configuration, a typed event bus, a hook/extension registry, a minimal dependency injection container, and general-purpose utilities. These core files are intentionally small, focused, and strongly typed so the rest of the app (services, providers, hooks, components and pages) can import a single source of truth for types, behavior and runtime flags.",
  "files": [
    {
      "file_path": "src/core/contracts.ts",
      "purpose": "Domain types, DTOs and reusable UI state contracts. Centralized domain models (users, healthcare models), API response shapes and client-side UI helpers used throughout the app.",
      "exports": [
        "AppConfig",
        "User",
        "Patient",
        "Doctor",
        "Nurse",
        "Role",
        "Address",
        "Contact",
        "Appointment",
        "AppointmentStatus",
        "MedicalRecord",
        "Prescription",
        "PrescriptionStatus",
        "LabResult",
        "LabResultStatus",
        "VisitNote",
        "ApiResult",
        "ApiError",
        "PaginatedResponse",
        "WebSocketEvent",
        "WebSocketEventMap",
        "LoadingState",
        "FormState",
        "FetchState"
      ],
      "content": "Purpose\n- Provide strongly-typed contracts for the app domain (healthcare), API interactions and common UI primitives.\n- Keep stable types in one place to avoid duplication and to make tests and mocks easier.\n\nConventions\n- Types are immutable records (readonly where appropriate).\n- Use discriminated unions for role-specific payloads.\n- Keep small helper types (Address, Contact) that can be reused by multiple domain entities.\n\nTypes (detailed)\n- Role: union type string literal of allowed roles used across the app.\n\n  export type Role = 'admin' | 'doctor' | 'nurse' | 'patient' | 'staff';\n\n- User and role-specializations: base User plus small derived shapes with role-specific fields.\n\n  export interface User {\n    id: string;\n    email: string;\n    fullName: string;\n    roles: Role[];\n    avatarUrl?: string | null;\n    metadata?: Record<string, any>;\n    createdAt: string; // ISO\n    updatedAt?: string;\n  }\n\n  export interface Patient extends User {\n    medicalRecordNumber: string;\n    dateOfBirth?: string; // ISO\n    primaryProviderId?: string;\n  }\n\n  export interface Doctor extends User {\n    licenseNumber?: string;\n    specialties?: string[];\n    clinicIds?: string[];\n  }\n\n  export interface Nurse extends User {\n    department?: string;\n    shift?: 'day' | 'night' | 'rotating';\n  }\n\n- Lightweight address & contact helpers\n\n  export interface Address {\n    line1: string;\n    line2?: string;\n    city?: string;\n    state?: string;\n    postalCode?: string;\n    country?: string;\n  }\n\n  export interface Contact {\n    phone?: string;\n    secondaryPhone?: string;\n    emergencyContact?: { name: string; phone: string };\n  }\n\n- Healthcare domain models\n\n  export type AppointmentStatus = 'scheduled' | 'checked_in' | 'in_progress' | 'completed' | 'cancelled' | 'no_show';\n\n  export interface Appointment {\n    id: string;\n    patientId: string;\n    clinicianId?: string; // doctor or nurse\n    scheduledAt: string; // ISO\n    durationMinutes?: number;\n    reason?: string;\n    status: AppointmentStatus;\n    locationId?: string;\n    createdBy?: string;\n    metadata?: Record<string, any>;\n  }\n\n  export interface VisitNote {\n    id: string;\n    appointmentId?: string;\n    authorId: string;\n    note: string;\n    createdAt: string;\n  }\n\n  export type PrescriptionStatus = 'active' | 'expired' | 'cancelled' | 'draft';\n\n  export interface Prescription {\n    id: string;\n    patientId: string;\n    prescriberId: string;\n    medications: Array<{ name: string; dose?: string; frequency?: string; quantity?: number }>;\n    issuedAt: string;\n    expiresAt?: string;\n    status: PrescriptionStatus;\n    notes?: string;\n  }\n\n  export type LabResultStatus = 'pending' | 'completed' | 'amended' | 'cancelled';\n\n  export interface LabResult {\n    id: string;\n    patientId: string;\n    testName: string;\n    performedAt?: string;\n    status: LabResultStatus;\n    resultSummary?: string;\n    raw?: any; // provider-specific payload, keep as any but documented\n  }\n\n  export interface MedicalRecord {\n    id: string;\n    patientId: string;\n    problems?: string[];\n    allergies?: string[];\n    medications?: Prescription[];\n    visits?: VisitNote[];\n    lastUpdatedAt?: string;\n  }\n\n- API response / error shapes\n\n  export interface ApiResult<T = any> {\n    success: boolean;\n    data?: T;\n    error?: ApiError;\n  }\n\n  export interface ApiError {\n    code?: string | number;\n    message: string;\n    details?: any;\n    status?: number;\n  }\n\n  export interface PaginatedResponse<T> {\n    items: T[];\n    total: number;\n    page: number;\n    pageSize: number;\n  }\n\n- WebSocket / push event types\n  When websockets are enabled the WebSocket message envelope should be narrow; each message contains a type/discriminant and payload.\n\n  export type WebSocketEvent =\n    | { type: 'notification'; payload: { id: string; title: string; body?: string; url?: string } }\n    | { type: 'appointment:update'; payload: Appointment }\n    | { type: 'lab:result'; payload: LabResult }\n    | { type: 'presence'; payload: { userId: string; online: boolean } }\n    | { type: 'custom'; payload: any };\n\n  export type WebSocketEventMap = Record<string, any>; // used for typed buses or adapters\n\n- UI state helpers\n\n  export type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\n  export interface FormState<T = Record<string, any>> {\n    values: T;\n    errors: Partial<Record<keyof T, string | undefined>>;\n    touched: Partial<Record<keyof T, boolean>>;\n    isSubmitting: boolean;\n  }\n\n  export type FetchState<T> = {\n    data?: T;\n    error?: ApiError;\n    loading: boolean;\n  };\n\nPatterns and examples\n- Reuse these types in services and hooks:\n\n  import { Appointment, ApiResult } from '@/core/contracts';\n\n  async function getAppointments(): Promise<ApiResult<Appointment[]>> {\n    // implementation in src/services/apiClient.ts will return ApiResult<Appointment[]>\n  }\n\n- Use discriminated unions to narrow by event type from WebSocket payloads.\n\nIntegration points\n- src/services/apiClient.ts should use ApiResult / ApiError types for typed responses.\n- src/services/authService.ts returns User and AuthTokens that align with User type definitions here.\n- src/core/events.ts can publish WebSocketEvent payloads using the WebSocketEvent union.\n\nMocks\n- Because mock data is generated by the config layer, mock user objects should conform to User/Patient/Doctor interfaces above. The app's tests should import these types to assert shape correctness."
    },
    {
      "file_path": "src/app/config.ts",
      "purpose": "Materialized runtime configuration using Vite's import.meta.env. Central source for base URLs, feature flags, timeouts, environment flags and development mock data.",
      "exports": [
        "config",
        "isFeatureEnabled",
        "FeatureName"
      ],
      "content": "Purpose\n- Materialize a single, strongly-typed config object from import.meta.env.\n- Provide computed flags (isDevelopment, shouldUseMockData, enableWebsockets) and utilities to check feature toggles.\n- Generate small mock dataset when development mocking is enabled so other modules can import it safely.\n\nEnv contract\n- Expect Vite environment variables prefixed with VITE_ . Example variables used:\n  - VITE_API_BASE (string)\n  - VITE_ENV (\"development\"|\"staging\"|\"production\")\n  - VITE_TIMEOUT_MS (number, fallback 15000)\n  - VITE_FEATURES (JSON string or comma-separated list, e.g. '[\"analytics\",\"beta_dashboard\"]' or 'analytics,beta_dashboard')\n  - VITE_DISABLE_WEBSOCKETS (\"true\"|\"false\")\n  - VITE_ENABLE_MOCK_DATA (\"true\"|\"false\")\n  - VITE_ANALYTICS_PROVIDERS (JSON string array or csv)\n\nTypes\n  export type FeatureName = 'analytics' | 'beta_dashboard' | 'websockets' | 'mock_data' | 'experimental_ui';\n\n  export interface AppConfig {\n    env: 'development' | 'staging' | 'production';\n    isDevelopment: boolean;\n    apiBaseUrl: string;\n    requestTimeoutMs: number;\n    features: Set<string>; // allow arbitrary names for forward compatibility, prefer FeatureName\n    analyticsProviders: string[];\n    enableWebsockets: boolean;\n    shouldUseMockData: boolean;\n    buildTimestamp?: string;\n    // convenience helper\n    isFeatureEnabled: (name: string) => boolean;\n  }\n\nImplementation notes\n- Use import.meta.env (Vite) not process.env.\n- Robust parsing: permissive parsing of FEATURES and ANALYTICS_PROVIDERS using JSON.parse with safe fallback or comma-splitting.\n- Provide an isFeatureEnabled helper bound to the config object.\n- When shouldUseMockData is true, export a small mock user and sample records that conform to src/core/contracts types. Keep mocks minimal and deterministic.\n\nExample implementation (behavioral description)\n- Read raw values:\n  const rawEnv = import.meta.env;\n  const apiBase = (rawEnv.VITE_API_BASE as string) ?? `${location.protocol}//${location.host}/api`;\n  const env = ((rawEnv.VITE_ENV as string) ?? 'development') as AppConfig['env'];\n  const featuresRaw = (rawEnv.VITE_FEATURES as string | undefined) ?? '[]';\n  const parsedFeatures = safeParseFeatures(featuresRaw); // returns string[]\n\n- Computed flags:\n  const isDevelopment = env === 'development';\n  const shouldUseMockData = isDevelopment && (rawEnv.VITE_ENABLE_MOCK_DATA === 'true');\n  const enableWebsockets = rawEnv.VITE_DISABLE_WEBSOCKETS !== 'true';\n\n- Build config object and freeze it to avoid accidental mutation.\n\nMock Data\n- When shouldUseMockData is true, config exports a small `mock` object with sample User/Patient/Doctor/Appointment items. Mocks should import types from '@/core/contracts' (not circular since contracts don't import config).\n\n  export const mock = {\n    currentUser: { id: 'mock-user-1', email: 'dev@local', fullName: 'Developer Mock', roles: ['admin', 'doctor'], createdAt: new Date().toISOString() },\n    patients: [ ...sample Patient objects... ],\n    appointments: [ ...sample Appointment objects... ]\n  };\n\nUtilities\n- isFeatureEnabled(name: string): boolean - reads features Set.\n- parseCsvOrJson(raw?: string): string[] - helper to normalize env arrays.\n\nIntegration points\n- src/services/apiClient.ts should import config.apiBaseUrl and config.requestTimeoutMs.\n- src/providers/QueryProvider.tsx should import config to tune retry/timeouts and devtools.\n- src/core/events.ts and src/core/hooks.ts may read config.isFeatureEnabled('analytics') or config.enableWebsockets to decide runtime behavior.\n\nExamples\n  import { config, isFeatureEnabled } from '@/app/config';\n  if (config.isDevelopment && config.shouldUseMockData) {\n    // use injected mock data substitute in services\n  }\n\nNotes\n- Keep the config export as a single frozen object to encourage reading-only usage across the app.\n- Do not perform network calls from this module \u2014 configuration only.\n- Keep types minimal and stable so tests can import the config type to stub values."
    },
    {
      "file_path": "src/core/events.ts",
      "purpose": "Typed, lightweight event bus for decoupled cross-cutting communication (toasts, analytics, global errors, websocket messages). Supports sync and async handlers and safe unsubscribe.",
      "exports": [
        "EventBus",
        "globalEventBus",
        "EventCallback",
        "DomainEventMap"
      ],
      "content": "Goals\n- Provide a generic, typed event bus that other modules can import and subscribe to without tight coupling.\n- Support synchronous handlers and asynchronous handlers (that return Promise). The emitter returns a Promise that resolves when all handlers finish (useful for instrumentation).\n- Allow once/unsubscribe and allow handler priority when needed.\n\nTypes\n  export type EventCallback<T = any> = (payload: T) => void | Promise<void>;\n\n  export interface DomainEventMap {\n    'toast:show': { id?: string; type: 'success' | 'error' | 'info' | 'warning'; title: string; body?: string; durationMs?: number };\n    'analytics:event': { name: string; properties?: Record<string, any> };\n    'auth:login': { userId: string };\n    'auth:logout': { userId?: string };\n    'error:global': { error: Error | string; context?: string };\n    'ws:message': { raw: any }; // generic envelope for websocket wire messages\n    // App can augment this map by intersecting types in their own extension files.\n  }\n\nEventBus class\n- Generic class EventBus<E> where E is the event map type.\n- Methods:\n  - on<K extends keyof E>(event: K, handler: EventCallback<E[K]>, opts?: { priority?: number }): () => void\n    returns an unsubscribe function.\n  - off<K extends keyof E>(event: K, handler: EventCallback<E[K]>): void\n  - once<K extends keyof E>(event: K, handler: EventCallback<E[K]>): () => void\n  - emit<K extends keyof E>(event: K, payload: E[K]): Promise<void>\n    calls handlers in priority order (highest priority first). If handlers are synchronous, emit resolves synchronously; if any handler returns a Promise, emit returns a Promise that awaits all handlers.\n\nImplementation details\n- Internally maintain a Map<eventName, Array<{handler, priority}>>.\n- Provide safe iteration snapshot on emit to handle handlers registering/unregistering during iteration.\n- Ensure unhandled exceptions from handlers are caught and emitted as 'error:global' event (but avoid infinite loops).\n\nSingleton instance\n- Export a global singleton typed with DomainEventMap called globalEventBus.\n\nUsage examples\n  import { globalEventBus } from '@/core/events';\n\n  // subscribe\n  const off = globalEventBus.on('toast:show', payload => {\n    // show toast UI\n  });\n\n  // emit\n  await globalEventBus.emit('analytics:event', { name: 'page_view', properties: { path: '/dashboard' } });\n\n  // once\n  globalEventBus.once('auth:login', payload => console.log('user logged in', payload.userId));\n\nIntegration points\n- src/providers/ToastProvider.tsx should subscribe to 'toast:show' to enqueue visual toasts.\n- src/services/analytics.ts should both emit and subscribe to 'analytics:event' if forwarding to multiple providers.\n- src/services/websocket service can emit 'ws:message' when messages arrive.\n\nExtensibility\n- Projects can augment DomainEventMap by declaring module augmentation for '@/core/events' to add new keyed events and payloads for stricter typing."
    },
    {
      "file_path": "src/core/hooks.ts",
      "purpose": "A small hook registry / plugin system to register application extension points and run hooks. Hook points are typed; run order supports priority and synchronous/async execution.",
      "exports": [
        "registerHook",
        "useHook",
        "HookRegistration",
        "HookPoint",
        "hookRegistry",
        "HookContext"
      ],
      "content": "Goals\n- Provide a minimal runtime hook registry used by services to allow runtime extensions (e.g., A/B hooks, instrumentation, modifying requests/responses).\n- Typed HookPoints for common extension spots: beforeApiRequest, afterApiResponse, onLogin, onLogout, onRouteChange.\n- Make it easy for later features or plugins to register behavior without touching service code.\n\nTypes\n  export type HookPoint = 'beforeApiRequest' | 'afterApiResponse' | 'onLogin' | 'onLogout' | 'onRouteChange';\n\n  export interface HookContext {\n    // Common fields that different hook points may use. Not all fields are required by all hooks but this shape keeps hooks adaptable.\n    request?: { url: string; method: string; headers?: Record<string, string>; body?: any };\n    response?: { status: number; body?: any };\n    user?: { id: string };\n    route?: { from?: string; to?: string };\n    extra?: Record<string, any>;\n  }\n\n  export type HookHandler<T extends HookContext = HookContext> = (ctx: T) => void | Promise<void> | Partial<T>;\n\n  export interface HookRegistration {\n    id: string; // stable id for unregistering\n    point: HookPoint;\n    handler: HookHandler;\n    priority?: number; // higher executes earlier\n    once?: boolean;\n  }\n\nHookRegistry class\n- Responsibilities:\n  - register(point, handler, opts): HookRegistration\n  - unregister(id)\n  - run(point, ctx): Promise<HookContext>\n\n- register returns the registration object and adds it to internal storage keyed by point.\n- run executes registered handlers in priority order. If a handler returns a Partial<HookContext>, merge it into ctx (shallow merge). If a handler throws, capture and forward to globalEventBus.emit('error:global') for logging.\n- run returns the final merged context when all handlers have executed.\n\nHelper functions to export\n- registerHook(point, handler, opts?): convenience to register on the global registry and return an unregister function.\n- useHook(point, handler, deps?): a React hook helper for components to register a hook during lifecycle and auto-unregister on unmount. (This will depend on React; this module should export a non-React implementation and a separate small React hook module can import and wrap it. Nonetheless provide a small typed useHook signature here as a convention.)\n\nExample usage\n  import { registerHook } from '@/core/hooks';\n  // modify headers before requests\n  const reg = registerHook('beforeApiRequest', async ctx => {\n    ctx.request = ctx.request || { url: '', method: 'GET' };\n    // add instrumentation header\n    ctx.request.headers = { ...(ctx.request.headers || {}), 'x-app-trace': 'trace-id-123' };\n  }, { priority: 10 });\n\n  // running hooks inside the API client\n  const ctx = await hookRegistry.run('beforeApiRequest', { request: { url: '/patients', method: 'GET' } });\n  // use ctx.request to perform fetch\n\nIntegration points\n- src/services/apiClient.ts should call hookRegistry.run('beforeApiRequest', ctx) before executing the HTTP call and hookRegistry.run('afterApiResponse', ctx) after.\n- Auth service should run 'onLogin' and 'onLogout' hooks when authentication state changes.\n- Route changes can be wrapped to run 'onRouteChange' so analytics plugins can hook in.\n\nPatterns\n- Keep hook handlers idempotent and fast; heavy work should be delegated to background async paths where appropriate.\n- Use priority for core behaviors (auth, instrumentation) and register plugin-level hooks with lower priority by default.\n\nNotes\n- The HookRegistry should be a singleton exported as hookRegistry.\n- Because handlers may be async, run should always return a Promise. If no handlers run, it should resolve immediately with the input context.\n- Provide a simple typed registration ID (string based on timestamp + counter) to make tests deterministic when needed."
    },
    {
      "file_path": "src/core/di.ts",
      "purpose": "A minimal, type-safe dependency injection container (token-based) to register and resolve services. Useful for swapping implementations in tests or environment-specific wiring.",
      "exports": [
        "Container",
        "InjectionToken",
        "createToken",
        "registerService",
        "resolveService",
        "ApiClientToken",
        "AuthServiceToken",
        "StorageServiceToken",
        "WebSocketServiceToken",
        "defaultContainer"
      ],
      "content": "Goals\n- Provide a small, explicit token-based container for registering and resolving services. Avoid magic \u2014 tokens are explicit values (symbols) and typed so TypeScript can infer resolved types.\n- Support registering singletons and factories.\n\nCore types and helpers\n  export interface InjectionToken<T> {\n    readonly key: symbol;\n    readonly name?: string;\n  }\n\n  export function createToken<T>(name?: string): InjectionToken<T> {\n    return { key: Symbol(name), name };\n  }\n\nContainer class\n- API\n  - register<T>(token: InjectionToken<T>, provider: { useValue?: T; useFactory?: (c: Container) => T; singleton?: boolean }): void\n  - resolve<T>(token: InjectionToken<T>): T\n  - unregister(token: InjectionToken<any>): void\n  - has(token): boolean\n\n- Behavior\n  - If useValue is provided, resolve returns that value.\n  - If useFactory is provided and singleton=true, container caches the resulting instance and returns the same instance on subsequent resolves.\n  - Factory receives the container to resolve other dependencies lazily.\n  - Throw an error on resolve if token not registered.\n\nPredefined tokens\n- Export commonly used tokens to reduce duplication across the app:\n  export const ApiClientToken = createToken<ApiClient>('ApiClient');\n  export const AuthServiceToken = createToken<AuthService>('AuthService');\n  export const StorageServiceToken = createToken<StorageService>('StorageService');\n  export const WebSocketServiceToken = createToken<WebSocketService>('WebSocketService');\n\n  // The concrete interfaces (ApiClient/AuthService/StorageService) are defined in services layer; here we only refer to them by generic type parameters.\n\nConvenience functions\n- registerService(token, provider): alias to defaultContainer.register.\n- resolveService(token): alias to defaultContainer.resolve.\n\ndefaultContainer singleton\n- Export a defaultContainer used by the application bootstrap (Providers.tsx or main.tsx) to register concrete implementations.\n\nUsage pattern\n- At app startup (src/main.tsx or src/providers/Providers.tsx) register services:\n\n  import { defaultContainer, ApiClientToken } from '@/core/di';\n  import { apiClient } from '@/services/apiClient';\n\n  defaultContainer.register(ApiClientToken, { useValue: apiClient });\n\n- In services/components that need dependencies, resolve them lazily for testability:\n\n  const api = defaultContainer.resolve(ApiClientToken);\n  api.get('/patients');\n\n- For unit tests, create a test container or temporarily register a mock before the test runs and restore after.\n\nType safety and guidance\n- Using InjectionToken<T> ensures resolve<T> returns the correct static type. Keep tokens exported from this module to avoid creating accidental duplicates.\n- Prefer register with factories when initialization requires other services (factory receives the container).\n- Avoid global mutable singletons for application logic \u2014 prefer DI so tests can swap implementations easily.\n\nExample register factory with singleton\n  defaultContainer.register(AuthServiceToken, {\n    useFactory: (c) => new AuthService(c.resolve(ApiClientToken)),\n    singleton: true\n  });\n\nNotes\n- Keep this container intentionally small; it is not a full-blown DI framework. Its goal is testability and clear wiring, not reflection or decorators."
    },
    {
      "file_path": "src/core/utils.ts",
      "purpose": "General-purpose utilities used across the application: classNames, date formatting, clamp, sleep, safe JSON parsing, debug logging and low-level accessibility helpers like focus-trap utilities.",
      "exports": [
        "classNames",
        "formatDate",
        "clamp",
        "sleep",
        "safeParseJSON",
        "debugLog",
        "assertNever",
        "focusTrapHelpers"
      ],
      "content": "Purpose\n- Provide small, dependency-free helpers that are used in both components and services.\n- Keep implementations tiny and dependency-free so they are easy to reason about in tests.\n\nFunctions and behavior\n- classNames(...parts: Array<string | false | null | undefined | Record<string, boolean>>): string\n  - Concatenates class names and supports conditional objects. Example:\n    classNames('btn', { 'btn-primary': isPrimary }, maybeClass)\n\n- formatDate(dateInput: string | number | Date, opts?: { dateStyle?: Intl.DateTimeFormatOptions; timeZone?: string }): string\n  - Uses Intl.DateTimeFormat with reasonable defaults. Returns empty string for falsy input.\n  - Example: formatDate('2024-03-01T12:00:00Z', { dateStyle: 'medium' }) -> 'Mar 1, 2024'\n\n- clamp(value: number, min: number, max: number): number\n  - Returns value bounded by the inclusive [min, max].\n\n- sleep(ms: number): Promise<void>\n  - Returns a promise that resolves after ms. Useful for small delays in dev/test.\n\n- safeParseJSON<T = any>(raw: string | undefined, fallback?: T): T\n  - Try/catch JSON.parse, returns fallback on parse error. Useful for parsing env vars.\n\n- debugLog(...args: any[]): void\n  - Wrapper around console.log that is no-op in production. Detect production via import.meta.env.MODE or import.meta.env.VITE_ENV. Keep output prefixed for easier filtering.\n\n- assertNever(x: never, message?: string): never\n  - Useful for exhaustive switch checks in TypeScript.\n\n- focusTrapHelpers\n  - Small utilities to trap focus inside a container element and restore focus on release. Not a full-blown focus-trap library but a minimal, accessible helper used by Modal and other overlays.\n  - API:\n      const { trapFocus, releaseFocus } = focusTrapHelpers(containerElement, initialFocusSelector?)\n      trapFocus(); // sets keydown handlers and moves focus\n      releaseFocus(); // removes handlers and restores previously focused element\n\n  Implementation details for trapFocus\n  - Remember previouslyFocusedElement = document.activeElement as HTMLElement | null\n  - Query all focusable elements inside container using a small selector list\n  - On Tab key press, cycle focus between first and last element\n  - Add keydown handler to listen for Escape for optional close semantics (handler should be provided by modal code)\n  - Provide releaseFocus to remove listeners and restore focus\n\nExamples\n- classNames example\n\n  import { classNames } from '@/core/utils';\n  const cls = classNames('card', isActive && 'card--active', { 'card--disabled': disabled });\n\n- date formatting example\n\n  import { formatDate } from '@/core/utils';\n  const pretty = formatDate(record.createdAt, { dateStyle: 'medium' });\n\n- safe JSON parsing for config\n\n  import { safeParseJSON } from '@/core/utils';\n  const features = safeParseJSON<string[]>(import.meta.env.VITE_FEATURES, []);\n\nTesting guidance\n- All utilities are pure functions (except focusTrapHelpers which manipulates DOM). Tests should validate edge cases (null/undefined, wrong types) and ensure debugLog is suppressed in production.\n\nIntegration points\n- src/app/config.ts uses safeParseJSON and debugLog.\n- src/shared/components/Modal/Modal.tsx uses focusTrapHelpers.\n- src/shared/components/Button/Button.tsx uses classNames for variant selection.\n\nNotes\n- Keep utils dependency-free and well-documented. If a helper grows complex (e.g., focus trapping), consider moving to a dedicated small package later, but keep this implementation sufficient for the app's initial needs."
    }
  ],
  "usage_guidelines": [
    "Import domain types from '@/core/contracts' to avoid duplicate type definitions across services and UI.",
    "Read runtime configuration via '@/app/config' only (do not use import.meta.env directly in other modules). Config is frozen and includes helpers like isFeatureEnabled().",
    "Use globalEventBus from '@/core/events' for cross-cutting notifications (toasts, analytics, global errors). Avoid coupling by sending minimal payloads.",
    "Register and run hooks via '@/core/hooks' (hookRegistry). Services (apiClient, authService) should call hook points to make runtime behavior extensible by other modules.",
    "Register core services at app bootstrap in the defaultContainer (from '@/core/di') so tests can swap implementations by registering mocks in the container.",
    "Use '@/core/utils' helpers for small deterministic utilities (classNames, formatDate, safeParseJSON, focus helpers) to improve consistency and testability."
  ]
}