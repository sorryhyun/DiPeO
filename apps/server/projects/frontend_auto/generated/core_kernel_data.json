{
  "overview": "The Core Kernel provides a single, strongly-typed foundation shared by every feature and provider in the Patient Healthcare Portal. It centralizes domain contracts, runtime configuration, a typed event bus for decoupled communication, an extension hook registry for plugin-like extension points, a minimal dependency-injection container to swap real and mock implementations, and a small set of widely-used utilities. All features, services and UI components should import types, tokens and helpers from these files to guarantee a single source of truth across the codebase.",
  "files": [
    {
      "file_path": "generated/src/core/contracts.ts",
      "purpose": "Shared domain types, enums, API contracts and common UI state types used across services, features and components.",
      "exports": [
        "Role",
        "User, Patient, Doctor, Nurse, TokenPayload, AuthToken",
        "Gender",
        "Address",
        "ContactInfo",
        "Appointment, AppointmentStatus, AppointmentParticipant",
        "MedicalRecord, RecordType, Attachment",
        "Prescription, PrescriptionStatus, PrescriptionRefillRequest",
        "LabResult, LabResultStatus, LabTestType",
        "InsuranceClaim, ClaimStatus, InsuranceProvider",
        "Medication, MedicationRoute, MedicationSchedule",
        "Reminder, ReminderFrequency, ReminderStatus",
        "ApiResult<T>, ApiError, PaginatedResponse<T>",
        "WsEvent, WsEventMap, WsPayloads",
        "LoadingState, FormState, SortDirection",
        "MockUser"
      ],
      "content": "Purpose\n- Provide canonical, well-documented TypeScript interfaces and enums that represent the app domain for appointments, records, prescriptions, labs, insurance, medications and reminders.\n- Provide API response shapes used by httpClient and services.\n- Provide WebSocket event typings used by real and mock websocket implementations.\n\nConventions\n- Use exhaustive enums for discriminated unions where possible.\n- All id fields are typed as string (UUID recommended) and timestamps are ISO strings (string, ISO 8601).\n- Domain objects include minimal but complete sets of common fields required by UI/features described in the app config.\n\nTypes & Interfaces to include (complete list with field descriptions):\n\n1) Authentication & User types\n- export type Role = 'patient' | 'doctor' | 'nurse' | 'admin';\n\n- export interface User {\n    id: string;                       // UUID\n    role: Role;\n    email: string;\n    fullName: string;\n    phone?: string;\n    avatarUrl?: string;\n    createdAt: string;                // ISO timestamp\n    updatedAt?: string;\n  }\n\n- export interface Patient extends User {\n    role: 'patient';\n    dateOfBirth?: string;             // ISO date\n    gender?: Gender;\n    address?: Address;\n    primaryProviderId?: string | null;\n    medicalRecordNumber?: string | null;\n  }\n\n- export interface Doctor extends User {\n    role: 'doctor';\n    specialty?: string;\n    clinic?: string;\n    licenseNumber?: string;\n    acceptingNewPatients?: boolean;\n  }\n\n- export interface Nurse extends User {\n    role: 'nurse';\n    department?: string;\n    supervisingDoctorId?: string | null;\n  }\n\n- export interface AuthToken {\n    token: string;\n    expiresAt: string;                // ISO timestamp\n  }\n\n- export interface TokenPayload {\n    sub: string;                      // user id\n    role: Role;\n    iat?: number;\n    exp?: number;\n  }\n\n2) Common small types\n- export enum Gender { Male = 'male', Female = 'female', Other = 'other', Unknown = 'unknown' }\n\n- export interface Address {\n    line1: string;\n    line2?: string;\n    city?: string;\n    state?: string;\n    postalCode?: string;\n    country?: string;\n  }\n\n- export interface ContactInfo {\n    email?: string;\n    phone?: string;\n    preferred?: 'email' | 'phone' | 'sms';\n  }\n\n3) Appointments\n- export enum AppointmentStatus { Pending = 'pending', Confirmed = 'confirmed', Cancelled = 'cancelled', Completed = 'completed', NoShow = 'no_show' }\n\n- export interface AppointmentParticipant {\n    id: string;            // user id\n    role: Role;\n    name?: string;\n    avatarUrl?: string;\n  }\n\n- export interface Appointment {\n    id: string;\n    title: string;                 // e.g., 'Telemedicine with Dr. Smith'\n    description?: string;\n    startAt: string;               // ISO timestamp\n    endAt?: string;                // ISO timestamp\n    status: AppointmentStatus;\n    patientId: string;\n    providerId?: string | null;    // doctor/nurse id\n    participants: AppointmentParticipant[];\n    location?: string;             // clinic room or 'telemedicine'\n    isTelemedicine?: boolean;\n    createdAt: string;\n    updatedAt?: string;\n    metadata?: Record<string, unknown>;\n  }\n\n4) Medical Records\n- export enum RecordType { Note = 'note', Imaging = 'imaging', Lab = 'lab', Document = 'document' }\n\n- export interface Attachment {\n    id: string;\n    filename: string;\n    url?: string;                 // signed URL in production or data URL in dev\n    contentType?: string;\n    size?: number;\n    createdAt?: string;\n  }\n\n- export interface MedicalRecord {\n    id: string;\n    patientId: string;\n    authorId?: string;\n    type: RecordType;\n    title?: string;\n    body?: string;                // rich text or summary\n    attachments?: Attachment[];\n    createdAt: string;\n    updatedAt?: string;\n    tags?: string[];\n  }\n\n5) Prescriptions\n- export enum PrescriptionStatus { Active = 'active', Expired = 'expired', Cancelled = 'cancelled', Refilled = 'refilled' }\n\n- export interface Prescription {\n    id: string;\n    patientId: string;\n    prescriberId: string;\n    medicationName: string;\n    dose: string;                 // e.g., '10 mg'\n    directions?: string;          // e.g., 'Take one tablet daily'\n    quantity?: number;\n    refillsRemaining?: number;\n    status: PrescriptionStatus;\n    issuedAt: string;\n    expiresAt?: string;\n    notes?: string;\n  }\n\n- export interface PrescriptionRefillRequest {\n    prescriptionId: string;\n    requestedById: string;\n    reason?: string;\n  }\n\n6) Lab Results\n- export enum LabResultStatus { Normal = 'normal', Abnormal = 'abnormal', Critical = 'critical', Pending = 'pending' }\n- export type LabTestType = string; // free-form, but services should adopt a stable taxonomy (e.g., 'CBC', 'BMP')\n\n- export interface LabResult {\n    id: string;\n    patientId: string;\n    testName: LabTestType;\n    resultValue?: string;         // string to represent complex values\n    units?: string;\n    referenceRange?: string;\n    status: LabResultStatus;\n    collectedAt?: string;\n    reportedAt?: string;\n    attachments?: Attachment[];\n    notes?: string;\n  }\n\n7) Insurance\n- export enum ClaimStatus { Submitted = 'submitted', Processing = 'processing', Paid = 'paid', Denied = 'denied', Rejected = 'rejected' }\n\n- export interface InsuranceProvider {\n    id: string;\n    name: string;\n    policyNumber?: string;\n  }\n\n- export interface InsuranceClaim {\n    id: string;\n    patientId: string;\n    providerId?: string;\n    amountCents?: number;\n    currency?: string;            // e.g., 'USD', 'KRW'\n    status: ClaimStatus;\n    submittedAt?: string;\n    updatedAt?: string;\n    notes?: string;\n  }\n\n8) Medication & Reminders\n- export enum MedicationRoute { Oral = 'oral', IV = 'iv', Topical = 'topical', Inhalation = 'inhalation', Other = 'other' }\n\n- export interface Medication {\n    id: string;\n    name: string;\n    strength?: string;\n    route?: MedicationRoute;\n    instructions?: string;\n    prescribedById?: string;\n    startDate?: string;\n    endDate?: string | null;\n  }\n\n- export enum ReminderFrequency { Once = 'once', Daily = 'daily', Weekly = 'weekly', Monthly = 'monthly' }\n- export enum ReminderStatus { Scheduled = 'scheduled', Sent = 'sent', Dismissed = 'dismissed', Failed = 'failed' }\n\n- export interface Reminder {\n    id: string;\n    patientId: string;\n    medicationId?: string | null;\n    title: string;\n    message?: string;\n    scheduledAt: string;           // ISO timestamp\n    frequency?: ReminderFrequency;\n    status: ReminderStatus;\n    createdAt: string;\n  }\n\n9) API response shapes\n- export interface ApiError {\n    code: string;                  // machine-readable error code\n    message: string;               // human-friendly message\n    details?: Record<string, unknown>;\n  }\n\n- export interface ApiResult<T> {\n    success: boolean;\n    data?: T;\n    error?: ApiError;\n    meta?: Record<string, unknown>;\n  }\n\n- export interface PaginatedResponse<T> {\n    items: T[];\n    total: number;\n    page: number;\n    pageSize: number;\n  }\n\n10) WebSocket events (WsEventMap)\n- Rationale: mock websocket is enabled in dev; define event types used across features. Use discriminated union for robust typing.\n\n- export type WsEvent = keyof WsEventMap;\n\n- export interface WsPayloads {\n    'user:login': { userId: string; timestamp: string };\n    'user:logout': { userId: string; timestamp: string };\n    'appointment:created': { appointment: Appointment };\n    'appointment:updated': { appointment: Appointment };\n    'appointment:cancelled': { appointmentId: string; reason?: string };\n    'lab:result:available': { labResult: LabResult };\n    'prescription:refilled': { prescriptionId: string; refilledAt: string };\n    'notification:received': { id: string; title: string; body?: string; data?: Record<string, unknown> };\n    'telemedicine:session:update': { sessionId: string; status: string; participants?: AppointmentParticipant[] };\n  }\n\n- Export typed map type:\n  export type WsEventMap = { [K in keyof WsPayloads]: { type: K; payload: WsPayloads[K] } };\n\n11) UI & Form State\n- export type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\n- export interface FormState<T = Record<string, unknown>> {\n    values: T;\n    errors: Record<string, string>;\n    touched: Partial<Record<keyof T, boolean>>;\n    isSubmitting: boolean;\n  }\n\n- export enum SortDirection { ASC = 'asc', DESC = 'desc' }\n\n12) Development mock user shape\n- export interface MockUser extends User {\n    password?: string;            // only present in dev mock data\n  }\n\nExample usage (in comments / test code):\n- import { Appointment, AppointmentStatus, ApiResult } from '@/core/contracts';\n- const response: ApiResult<Appointment> = { success: true, data: appointment };\n\nIntegration points\n- app/config.ts will import MockUser type and provide concrete mock user data in development mode.\n- core/events.ts will import WsPayloads/WsEvent for event typing and forwarding.\n- core/di.ts tokens for services will reference types from this file (e.g., WebSocketService uses WsEvent types).\n- services and features will rely solely on these interfaces for typing data across the app."
    },
    {
      "file_path": "generated/src/app/config.ts",
      "purpose": "Materialized runtime configuration including environment flags, feature toggles, API endpoints, and mock development data. This is the single source of truth for 'isDevelopment' and 'useMocks' flags.",
      "exports": [
        "AppConfig",
        "isDevelopment",
        "shouldUseMockData",
        "shouldDisableWebsocketInDev",
        "featureFlags",
        "mockUsers"
      ],
      "content": "Purpose\n- Convert the provided JSON configuration into a typed, exported runtime config object.\n- Provide computed flags used by providers, MockServerProvider, DI and services.\n- Expose the mock users dataset in a typed way when development mock data is enabled.\n\nShape & fields to export (fully materialized):\n\n- export const AppConfig: {\n    appType: 'healthcare';\n    framework: 'react';\n    targetFramework: 'react';\n    stylingApproach: 'tailwind';\n    objective: string;\n    features: string[];               // from config.features\n    targetAudience: string;\n    outputDir: string;\n    developmentMode: {\n      enableMockData: boolean;\n      mockAuthUsers: MockUser[];      // imports MockUser from '@/core/contracts'\n      mockApiEndpoints: string[];\n      disableWebsocketInDev: boolean;\n      useLocalStoragePersistence: boolean;\n    };\n    promptRequirements: string[];\n    evaluationCriteria: string[];\n    promptSections: string[];\n  }\n\nComputed constants exported for ease-of-use\n- export const isDevelopment: boolean; // process.env.NODE_ENV !== 'production'\n- export const shouldUseMockData: boolean; // AppConfig.developmentMode.enableMockData && isDevelopment\n- export const shouldDisableWebsocketInDev: boolean; // AppConfig.developmentMode.disableWebsocketInDev && isDevelopment\n\nFeature toggles\n- export const featureFlags: Record<string, boolean>; // map of feature -> boolean (present in features array)\n  - e.g., featureFlags['appointment scheduling'] === true\n\nMock users\n- If AppConfig.developmentMode.enableMockData is true, export mockUsers: MockUser[] populated from JSON. MockUser includes password and role as defined in core/contracts.ts.\n\nEndpoints & Defaults\n- export const API_BASE = '/api'; // default API base path (used by httpClient)\n- export const MOCK_API_ENDPOINTS: string[] = AppConfig.developmentMode.mockApiEndpoints;\n\nExamples of computed values and usage (described):\n- import { shouldUseMockData, featureFlags, mockUsers } from '@/app/config';\n- if (shouldUseMockData) { registerMockServer({ endpoints: MOCK_API_ENDPOINTS, users: mockUsers }); }\n\nIntegration points\n- Providers (MockServerProvider, QueryProvider, AuthProvider) will read shouldUseMockData and shouldDisableWebsocketInDev here.\n- DI registration of mock services will use mockUsers exported here to seed mock auth.\n- Features should check featureFlags['<feature>'] before rendering optional sections (e.g., if (!featureFlags['telemedicine interface']) hide telemedicine routes).\n\nImplementation notes for generator\n- compute isDevelopment from process.env.NODE_ENV at build-time (or a fallback constant in environments that don't define it).\n- keep AppConfig as a plain object to allow JSON-like introspection by runtime code.\n- ensure exported mockUsers are strongly typed using MockUser from '@/core/contracts'."
    },
    {
      "file_path": "generated/src/core/events.ts",
      "purpose": "Typed, lightweight event bus for app-level events (notifications, telemetry, and mock websocket forwarding). Supports both synchronous and asynchronous handlers and is used by services and providers to decouple producers and consumers.",
      "exports": [
        "EventBus",
        "eventBus (singleton)",
        "subscribe",
        "unsubscribe",
        "publish"
      ],
      "content": "Objectives\n- Provide a compact, dependency-free pub/sub implementation with strong typing against WsPayloads / event names defined in '@/core/contracts'.\n- Support both sync and async handlers; allow handlers to return void or Promise<void>.\n- Provide a singleton instance to be used across the app, plus convenience helpers.\n\nTypes & Behavior\n- Use WsPayloads (imported from '@/core/contracts') to type event names and payloads.\n- export type EventName = keyof WsPayloads; // restricts allowed event names\n\n- Handler signature: type Handler<K extends EventName> = (payload: WsPayloads[K]) => void | Promise<void>;\n\nEventBus class API (must be fully specified):\n- class EventBus {\n    on<K extends EventName>(event: K, handler: Handler<K>, options?: { once?: boolean; priority?: number }): () => void;\n    off<K extends EventName>(event: K, handler: Handler<K>): void;\n    emit<K extends EventName>(event: K, payload: WsPayloads[K]): Promise<void>;\n    clearAll(): void; // remove all subscribers (useful in tests / hot-reload)\n  }\n\nSemantics & guarantees\n- on() returns an unsubscribe function for convenience.\n- Handlers may be registered with a numeric priority (higher numbers run earlier). Default priority = 0.\n- once: true handlers are auto-removed after the first successful invocation.\n- emit() invokes handlers in priority order and awaits all handlers in series (or optionally in parallel \u2014 the implementation choice should be documented). The spec recommends running handlers sequentially and awaiting each one so ordered side effects (e.g., write to storage then emit telemetry) behave deterministically.\n- Errors thrown by handlers must be caught and emitted to a global logger (integration point: DI LoggerService token) and should not block other handlers; emit should still resolve after all handlers run. The error collection should be returned via an optional return value in advanced usage, but at minimum errors are logged. For simplicity, emit resolves void but logs errors via the logger service.\n\nSingleton & helpers\n- export const eventBus = new EventBus();\n\n- Convenience functions:\n  export const subscribe = <K extends EventName>(event: K, handler: Handler<K>) => eventBus.on(event, handler);\n  export const unsubscribe = <K extends EventName>(event: K, handler: Handler<K>) => eventBus.off(event, handler);\n  export const publish = <K extends EventName>(event: K, payload: WsPayloads[K]) => eventBus.emit(event, payload);\n\nIntegration points and examples\n- MockWebSocket will forward incoming messages to eventBus.publish('appointment:created', { appointment });\n- services/queryClient or providers can subscribe to 'user:login' to warm caches.\n\nExample usage:\n- import { eventBus, subscribe, publish } from '@/core/events';\n- const unsub = subscribe('lab:result:available', async payload => { /* show UI toast */ });\n- publish('lab:result:available', { labResult });\n- unsub();\n\nNotes for implementer\n- Prefer small memory footprint and simple arrays for handlers; avoid heavy abstraction. Keep typed shape strict by depending on '@/core/contracts' WsPayloads type."
    },
    {
      "file_path": "generated/src/core/hooks.ts",
      "purpose": "Hook registry / extension point system. Enables modules to register interceptors or outcome processors for cross-cutting concerns (API request interceptors, login/logout hooks, routing hooks). Hooks are typed, asynchronous-capable and ordered by registration priority.",
      "exports": [
        "HookPoint",
        "HookContext",
        "HookHandler",
        "HookRegistry",
        "hooks (singleton)",
        "registerHook",
        "runHooks",
        "unregisterHook"
      ],
      "content": "Goal\n- Provide a centralized, small-scale plugin system so features and providers can extend behavior without tight coupling.\n- Hooks are not React hooks; they are runtime extension points (register-run pattern). For framework-level extension, use DI + hooks together.\n\nHook points (must include these standard hook points):\n- 'beforeApiRequest' \u2014 runs before every API request; may mutate request options.\n- 'afterApiResponse' \u2014 runs after every API response; can inspect/transform/augment responses.\n- 'onLogin' \u2014 called when a user successfully logs in.\n- 'onLogout' \u2014 called when a user logs out or session is cleared.\n- 'onRouteChange' \u2014 called when the router transitions to a new route.\n\nHook types & context\n- export type HookPoint =\n    | 'beforeApiRequest'\n    | 'afterApiResponse'\n    | 'onLogin'\n    | 'onLogout'\n    | 'onRouteChange';\n\n- export interface HookContext {\n    // common fields available to all hooks\n    readonly now: string;               // ISO timestamp of invocation\n    service?: string;                   // optional origin (e.g., 'appointments.api')\n    requestId?: string;                 // correlation id for tracing\n    [key: string]: unknown;             // allow extension by specific hook runners\n  }\n\n- Generic handler signature:\n  export type HookHandler<T extends HookPoint, P = unknown> = (payload: P, ctx: HookContext) => unknown | Promise<unknown>;\n\nRegistry class API\n- class HookRegistry {\n    register<T extends HookPoint>(point: T, handler: HookHandler<T, any>, options?: { priority?: number }): { id: string; unregister: () => void };\n    run<T extends HookPoint, R = unknown>(point: T, payload?: any, ctx?: Partial<HookContext>): Promise<R[]>; // execute and return array of handler results\n    clear(point?: HookPoint): void; // remove all handlers for a point or all points when omitted\n  }\n\nSemantics & behavior\n- register() returns a unique id and an unregister function; handlers may be registered multiple times.\n- Handlers run in descending priority order (higher first). If equal priority, use registration order (FIFO among equals).\n- run() should support both sync and async handlers by awaiting each handler in series. The runner returns the collection of handler results. The runner should not throw on individual handler errors \u2014 instead catch and surface via DI Logger or by returning an errors array in results (implementation detail). For the spec, state that errors are caught and logged but run() still resolves with results / undefined for failing handlers.\n- beforeApiRequest hook's payload: { url: string; method: string; options: RequestInit } and the hook may return a patched options object; implementers should merge returned option objects. Note: mutation vs return -- the registry supports both patterns (mutate in place or return override). Document that return values are respected if present.\n- afterApiResponse hook's payload: { url: string; method: string; response: ApiResult<any> } and can be used for global error handling, metrics, or response normalization.\n- onLogin payload: { user: User; token?: AuthToken }\n- onLogout payload: { userId?: string }\n- onRouteChange payload: { from?: string; to: string; params?: Record<string,string> }\n\nUsage examples\n- Registering a hook:\n  import { registerHook } from '@/core/hooks';\n  const { unregister } = registerHook('onLogin', async (payload, ctx) => {\n    // warm caches, send telemetry\n  }, { priority: 10 });\n\n- Running hooks (example inside httpClient):\n  await runHooks('beforeApiRequest', { url, method, options }, { service: 'httpClient' });\n\nIntegration points\n- httpClient service must call runHooks('beforeApiRequest', ...) and runHooks('afterApiResponse', ...).\n- AuthProvider should run 'onLogin' and 'onLogout' hooks when user state changes.\n- Router wrapper should call runHooks('onRouteChange', { from, to }).\n\nImplementation notes\n- Keep registry minimal and performant. Handlers should be stored keyed by HookPoint with an array of { id, handler, priority }.\n- Provide helper exports: registerHook(point, handler, options) -> returns unregister function; runHooks(point, payload, ctx) -> Promise<results[]>; unregisterHook(id) -> boolean.\n- Provide a singleton instance: export const hooks = new HookRegistry();"
    },
    {
      "file_path": "generated/src/core/di.ts",
      "purpose": "Minimal, type-safe dependency injection container and token registry. Enables swapping real and mock implementations at app composition time (e.g., MockServerProvider registers mock services when shouldUseMockData is true).",
      "exports": [
        "Token",
        "createToken",
        "DIContainer",
        "di (singleton container)",
        "ServiceTokens (ApiClient, AuthService, StorageService, WebSocketService, LoggerService)",
        "registerService, resolveService, clearServices"
      ],
      "content": "Goals\n- Offer a tiny, strongly-typed DI system sufficient for the app: register concrete implementations for abstract tokens and resolve them where needed.\n- Provide a simple API that is friendly to TypeScript and small enough to avoid a heavy DI framework.\n\nCore concepts\n- Token<T>: a unique identifier for a dependency which carries the TypeScript shape for that dependency.\n  - Implementation detail: Token<T> is a branded object or Symbol with an optional debug name for readability.\n\n- createToken<T>(name?: string): Token<T> \u2014 factory for tokens.\n\nService tokens to predefine (exported constants):\n- ApiClientToken: Token<{ request: (opts: { url: string; method?: string; body?: unknown; headers?: Record<string,string> }) => Promise<ApiResult<any>> }>\n- AuthServiceToken: Token<{ login: (email: string, password: string) => Promise<{ user: User; token?: AuthToken }>; logout: () => Promise<void>; getCurrentUser: () => User | null }>\n- StorageServiceToken: Token<{ get: (key: string) => Promise<string | null> | string | null; set: (key: string, value: string) => Promise<void> | void; remove: (key: string) => Promise<void> | void }>\n- WebSocketServiceToken: Token<{ connect: () => Promise<void>; disconnect: () => Promise<void>; send: (type: string, payload: any) => void; subscribe: (type: string, handler: (payload: any) => void) => () => void }>\n- LoggerServiceToken: Token<{ debug: (...args: any[]) => void; info: (...args: any[]) => void; warn: (...args: any[]) => void; error: (...args: any[]) => void }>\n\nContainer API\n- class DIContainer {\n    register<T>(token: Token<T>, implementation: T, options?: { replace?: boolean }): void;\n    resolve<T>(token: Token<T>): T; // throws if not registered\n    tryResolve<T>(token: Token<T>): T | undefined; // returns undefined if missing\n    unregister<T>(token: Token<T>): void;\n    clear(): void; // clears all registrations\n  }\n\nConvenience global container\n- export const di = new DIContainer();\n- export const registerService = di.register.bind(di);\n- export const resolveService = di.resolve.bind(di);\n- export const clearServices = di.clear.bind(di);\n\nType safety & best practices\n- Require the token's generic type to match implementation shape. Consumers always resolve with the token to get typed instances.\n- Encourage registration at app startup: MockServerProvider should register mock implementations before providers that depend on them initialize. QueryProvider registers queryClient into DI if needed.\n\nExample usage\n- Registering a service (in MockServerProvider or App bootstrap):\n  import { registerService, ApiClientToken } from '@/core/di';\n  registerService(ApiClientToken, { request: (opts) => fetchWrapper(opts) });\n\n- Resolving inside a service file:\n  import { resolveService, AuthServiceToken } from '@/core/di';\n  const auth = resolveService(AuthServiceToken);\n  await auth.login(email, password);\n\nIntegration points\n- MockServerProvider: when shouldUseMockData is true, register a mock AuthService and mock WebSocketService tokens here.\n- services/httpClient.ts should read ApiClientToken if available, otherwise create a default runtime implementation.\n- core/events.ts and core/hooks.ts may use LoggerServiceToken to log errors from handlers.\n\nImplementation notes\n- Container may store implementations in a Map<Token<any>, any> keyed by token.id (Symbol).\n- register should throw or optionally replace existing registration depending on options.replace; document the default behavior is to throw if duplicate registration occurs unless replace: true.\n- Prefer simplicity over advanced features like scoped or hierarchical containers; keep one global container for simplicity in this application."
    },
    {
      "file_path": "generated/src/core/utils.ts",
      "purpose": "A set of small, well-tested utility helpers shared across services and UI (date formatting, safe JSON helpers, simple id generator, storage helpers and basic validators).",
      "exports": [
        "formatDateISO",
        "formatDateLocal",
        "parseISODate",
        "safeJsonParse",
        "safeJsonStringify",
        "sleep",
        "generateId",
        "isEmail",
        "normalizePhone",
        "localGet, localSet, localRemove",
        "parseJwt, isJwtExpired"
      ],
      "content": "Goals\n- Provide deterministic small utilities that reduce duplication and guard against common runtime errors when parsing JSON, working with dates and localStorage.\n- All functions should be pure where possible and thoroughly described so they can be implemented deterministically by the generator.\n\nFunction contracts\n1) formatDateISO(date: string | Date): string\n- Accepts a Date instance or an ISO date string; returns a canonical ISO 8601 string (UTC), e.g., '2025-08-26T13:45:30Z'.\n\n2) formatDateLocal(date: string | Date, options?: { locale?: string; dateStyle?: 'short'|'medium'|'long'; timeStyle?: 'short'|'medium'|'long' }): string\n- Formats a date to a readable localized string using Intl.DateTimeFormat. Defaults: locale = navigator.language || 'en-US', dateStyle = 'medium', timeStyle = 'short'.\n\n3) parseISODate(input?: string | null): Date | null\n- Return a Date object for valid ISO strings, otherwise null.\n\n4) safeJsonParse<T = unknown>(input: string | null | undefined, fallback?: T): T | undefined\n- Try/catch JSON.parse and return fallback when parse fails. Never throw.\n\n5) safeJsonStringify(value: unknown): string | null\n- Try/catch JSON.stringify and return null if value can't be stringified.\n\n6) sleep(ms: number): Promise<void>\n- Promise-based delay helper used by mocks and tests.\n\n7) generateId(prefix?: string): string\n- Lightweight collision-resistant id generator suitable for mock data (prefix + timestamp + random). Not a UUID generator but good for dev mock objects.\n\n8) isEmail(value: string): boolean\n- Minimal RFC-like validation using a safe regex.\n\n9) normalizePhone(phone: string): string\n- Strip non-digit characters and optionally add country code heuristics; document behavior (returns digits only).\n\n10) localGet(key: string): string | null\n11) localSet(key: string, value: string): void\n12) localRemove(key: string): void\n- Thin wrappers around localStorage with try/catch guarding for environments where localStorage is unavailable or disabled. Returns null on failure.\n\n13) parseJwt(token: string): TokenPayload | null\n- Parse base64 payload and return TokenPayload (import TokenPayload type from '@/core/contracts'). Catch errors and return null on failure.\n\n14) isJwtExpired(token: string): boolean\n- Use parseJwt to determine expiry (exp claim) and return true if expired or token invalid.\n\nIntegration & examples\n- AuthProvider uses localGet/localSet to persist tokens in development if AppConfig.developmentMode.useLocalStoragePersistence is true.\n- MockAuth uses generateId and sleep to emulate network delays and persistent mock data storage via localSet/localGet.\n- httpClient uses safeJsonParse when parsing response bodies and formatDateISO on timestamps when creating payloads.\n\nImplementation notes\n- Keep functions small and synchronous where possible except sleep which returns a Promise.\n- Avoid dependencies; use built-in browser APIs (Intl, atob, btoa, localStorage) guarded with try/catch.\n\nExample usage:\n- import { formatDateLocal, safeJsonParse, localSet } from '@/core/utils';\n- localSet('auth.token', JSON.stringify(token));\n- const parsed = safeJsonParse<{ user: User }>(raw, { user: null });\n\nTesting considerations\n- Utilities should be pure and easy to unit test. Provide deterministic behavior for generateId by optionally supporting a seed in tests (implementation detail).\n\nSecurity notes\n- parseJwt must not validate signature; it's a convenience parser for client-side expiry checks only. Always treat parsed payloads as untrusted."
    }
  ],
  "usage_guidelines": [
    "Import domain types from '@/core/contracts' in services and features to stay consistent (e.g., import { Appointment, Prescription } from '@/core/contracts').",
    "Read runtime behavior flags from '@/app/config' (isDevelopment, shouldUseMockData, featureFlags) instead of reading process.env directly.",
    "Use the DI container in '@/core/di' to register concrete implementations once during app bootstrap (MockServerProvider registers mocks when shouldUseMockData is true). Resolve tokens where needed for typed dependencies.",
    "Use the singleton eventBus from '@/core/events' for cross-cutting notifications and to surface mock websocket events to UI and feature logic.",
    "Register and run extension hooks via '@/core/hooks' for API interceptors (beforeApiRequest / afterApiResponse) and lifecycle events (onLogin/onLogout/onRouteChange). httpClient and AuthProvider must call these hook points.",
    "Use '@/core/utils' helpers for safe JSON parsing, date formatting and localStorage access to prevent scattered try/catch logic.",
    "When adding new global events, hooks, or DI tokens, extend the typed maps in core/contracts.ts, core/events.ts and core/hooks.ts so consumers remain type-safe.",
    "All foundational files must remain minimal and stable. Avoid adding feature-specific logic here \u2014 reference feature-level constants and logic from features/ implementations."
  ]
}