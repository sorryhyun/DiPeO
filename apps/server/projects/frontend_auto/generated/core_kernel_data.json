{
  "overview": "The Core Kernel provides the immutable foundation for every application section. It defines shared domain contracts, a typed configuration surface with computed flags, a decoupled event bus, a pluggable hook registry, a tiny DI container, and a compact utilities toolkit. Each file is focused, interoperable, and designed to be consumed via @/core/* imports across features, pages, and services.",
  "files": [
    {
      "file_path": "src/core/contracts.ts",
      "purpose": "Domain models and API contracts shared across the app (generic API response, user identities, healthcare domain models, and basic UI state).",
      "exports": [
        "ApiResponse",
        "ApiResult",
        "ApiError",
        "User",
        "Patient",
        "Doctor",
        "Nurse",
        "Appointment",
        "MedicalRecord",
        "Prescription",
        "LabResult",
        "PaginatedResponse",
        "WSMessage",
        "WebSocketEventMap",
        "LoadingState",
        "FormState",
        "ID"
      ],
      "content": "// Core domain contracts and API contracts shared across the app\n\nexport type ID = string;\n\nexport interface ApiError {\n  code?: string;\n  message: string;\n  details?: any;\n}\n\nexport interface ApiResult<T> {\n  ok: boolean;\n  data?: T;\n  error?: ApiError;\n}\n\nexport type ApiResponse<T> = ApiResult<T>;\n\nexport type UserRole = 'patient'|'doctor'|'nurse'|'admin';\n\nexport interface User {\n  id: ID;\n  name: string;\n  email: string;\n  role: UserRole;\n}\n\nexport interface Patient extends User {\n  role: 'patient';\n  patientId?: string;\n}\n\nexport interface Doctor extends User {\n  role: 'doctor';\n  specialty?: string;\n}\n\nexport interface Nurse extends User {\n  role: 'nurse';\n  department?: string;\n}\n\ntype HealthcareUser = Patient | Doctor | Nurse | User;\n\nexport interface Appointment {\n  id: string;\n  patientId: string;\n  doctorId: string;\n  when: string; // ISO date string\n  status: 'scheduled'|'completed'|'cancelled';\n  reason?: string;\n}\n\nexport interface MedicalRecord {\n  id: string;\n  patientId: string;\n  doctorId?: string;\n  notes?: string;\n  diagnoses?: string[];\n  createdAt: string; // ISO date string\n}\n\nexport interface Prescription {\n  id: string;\n  patientId: string;\n  doctorId: string;\n  medication: string;\n  dosage?: string;\n  instructions?: string;\n  date?: string;\n}\n\nexport interface LabResult {\n  id: string;\n  patientId: string;\n  testName: string;\n  value?: string;\n  unit?: string;\n  referenceRange?: string;\n  date?: string;\n}\n\nexport interface PaginatedResponse<T> {\n  items: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n}\n\nexport type WSMessage<T = any> = {\n  type: string;\n  payload: T;\n  timestamp?: number;\n};\n\nexport type WebSocketEventMap = {\n  'appointment:updated': Appointment;\n  'medicalRecord:updated': MedicalRecord;\n  'labResult:updated': LabResult;\n};\n\nexport type LoadingState = 'idle'|'loading'|'success'|'error';\n\nexport interface FormState<T> {\n  values: T;\n  touched?: Partial<Record<keyof T, boolean>>;\n  errors?: Partial<Record<keyof T, string>>;\n  isSubmitting?: boolean;\n}\n\n// NOTE:\n// - These contracts are the shared language across features and services.\n// - Import from '@/core/contracts' wherever you model domain data.\n"
    },
    {
      "file_path": "src/app/config.ts",
      "purpose": "Materialized application configuration with API base, feature flags, theming defaults, and mock data for development.",
      "exports": [
        "AppConfig",
        "MockUser",
        "APP_CONFIG",
        "isDevelopment",
        "shouldUseMockData",
        "isFeatureEnabled"
      ],
      "content": "// Materialized application configuration\n\nexport type ThemeName = 'light'|'dark';\n\nexport interface MockUser {\n  id: string;\n  name: string;\n  email: string;\n  role: 'patient'|'doctor'|'nurse';\n}\n\nexport interface DevelopmentConfig {\n  enableMockData?: boolean;\n  mockUsers?: MockUser[];\n}\n\nexport interface AppConfig {\n  environment: 'development'|'production'|'staging';\n  apiBaseUrl: string;\n  features: string[]; // e.g., ['dashboard','patients','appointments','auth','settings']\n  theme: ThemeName;\n  development?: DevelopmentConfig;\n}\n\n// Raw config (could be sourced from process.env or a JSON file in a real app)\nconst RAW_CONFIG = {\n  environment: 'development' as const,\n  apiBaseUrl: 'https://api-dev.local',\n  features: ['dashboard','patients','appointments','auth','settings'],\n  theme: 'light' as const,\n  development: {\n    enableMockData: true,\n    mockUsers: [\n      { id: 'mock-doctor-1', name: 'Dr. Ava Smith', email: 'ava.smith@example.local', role: 'doctor' as const },\n      { id: 'mock-patient-1', name: 'John Doe', email: 'john.doe@example.local', role: 'patient' as const }\n    ]\n  }\n};\n\nexport const APP_CONFIG: AppConfig = {\n  environment: RAW_CONFIG.environment,\n  apiBaseUrl: RAW_CONFIG.apiBaseUrl,\n  features: RAW_CONFIG.features,\n  theme: RAW_CONFIG.theme,\n  development: RAW_CONFIG.development\n};\n\nexport const isDevelopment = APP_CONFIG.environment === 'development';\nexport const shouldUseMockData = APP_CONFIG.development?.enableMockData === true;\n\nexport function isFeatureEnabled(feature: string): boolean {\n  return APP_CONFIG.features.includes(feature);\n}\n"
    },
    {
      "file_path": "src/core/events.ts",
      "purpose": "Typed event bus for cross-component communication and decoupled interactions.",
      "exports": [
        "EventBus",
        "eventBus",
        "DomainEventMap"
      ],
      "content": "import type { Appointment, MedicalRecord, LabResult } from '@/core/contracts';\n\n// Typed domain events map. Extend as your domain grows.\nexport type DomainEventMap = {\n  'auth:login': { userId: string };\n  'auth:logout': void;\n  'route:change': { path: string; params?: any };\n  'appointment:updated': Appointment;\n  'medicalRecord:updated': MedicalRecord;\n  'labResult:updated': LabResult;\n};\n\ntype Handler<T> = (payload: T) => void | Promise<void>;\n\nexport class EventBus<Events extends Record<string, any> = DomainEventMap> {\n  private listeners = new Map<keyof Events | string, Set<Handler<any>>>() as Map<string, Set<Handler<any>>>;\n\n  on<K extends keyof Events>(event: K, handler: Handler<Events[K]>): void {\n    const key = String(event);\n    const set = this.listeners.get(key) ?? new Set<Handler<any>>();\n    set.add(handler as Handler<any>);\n    this.listeners.set(key, set);\n  }\n\n  off<K extends keyof Events>(event: K, handler: Handler<Events[K]>): void {\n    const key = String(event);\n    const set = this.listeners.get(key);\n    if (!set) return;\n    set.delete(handler as Handler<any>);\n  }\n\n  async emit<K extends keyof Events>(event: K, payload: Events[K]): Promise<void> {\n    const key = String(event);\n    const handlers = Array.from(this.listeners.get(key) ?? []);\n    const results = handlers.map(h => {\n      try {\n        return h(payload);\n      } catch {\n        return Promise.resolve();\n      }\n    });\n    if (results.length) {\n      await Promise.all(results.map(r => (r instanceof Promise ? r : Promise.resolve())));\n    }\n  }\n}\n\nexport const eventBus = new EventBus<DomainEventMap>();\n"
    },
    {
      "file_path": "src/core/hooks.ts",
      "purpose": "Hook registry to support extension points and runtime augmentation.",
      "exports": [
        "HookPoint",
        "HookRegistry",
        "registerHook",
        "runHook",
        "hooks"
      ],
      "content": "// Hook registry to enable extension points across the app\n\nexport type HookPoint = 'beforeApiRequest'|'afterApiResponse'|'onLogin'|'onLogout'|'onRouteChange';\n\nexport type HookHandler<Ctx = any> = (ctx: Ctx, ...args: any[]) => void | Promise<void>;\n\nexport class HookRegistry<Ctx = any> {\n  private registry = new Map<HookPoint, Array<HookHandler<Ctx>>>();\n\n  register(point: HookPoint, handler: HookHandler<Ctx>): void {\n    const list = this.registry.get(point) ?? [];\n    list.push(handler);\n    this.registry.set(point, list);\n  }\n\n  async run(point: HookPoint, ctx: Ctx, ...args: any[]): Promise<void> {\n    const handlers = this.registry.get(point) ?? [];\n    for (const h of handlers) {\n      await h(ctx, ...args);\n    }\n  }\n}\n\nexport const hooks = new HookRegistry<any>();\n\nexport function registerHook<Ctx = any>(point: HookPoint, handler: HookHandler<Ctx>): void {\n  hooks.register(point, handler);\n}\n\nexport async function runHook<Ctx = any>(point: HookPoint, ctx: Ctx, ...args: any[]): Promise<void> {\n  await hooks.run(point, ctx, ...args);\n}\n"
    },
    {
      "file_path": "src/core/di.ts",
      "purpose": "Tiny dependency injection container to decouple consumers from concrete implementations.",
      "exports": [
        "DIContainer",
        "createContainer",
        "TOKEN_API_CLIENT",
        "TOKEN_AUTH_SERVICE",
        "TOKEN_STORAGE_SERVICE",
        "TOKEN_WEBSOCKET_SERVICE"
      ],
      "content": "// Lightweight DI container with token-based resolution\n\n// Tokens (tokens are symbols to avoid collisions)\nexport const TOKEN_API_CLIENT = Symbol.for('ApiClient');\nexport const TOKEN_AUTH_SERVICE = Symbol.for('AuthService');\nexport const TOKEN_STORAGE_SERVICE = Symbol.for('StorageService');\nexport const TOKEN_WEBSOCKET_SERVICE = Symbol.for('WebSocketService');\n\nexport class DIContainer {\n  private registry = new Map<any, any>();\n\n  register<T>(token: any, instance: T): void {\n    this.registry.set(token, instance);\n  }\n\n  resolve<T>(token: any): T {\n    if (!this.registry.has(token)) {\n      throw new Error(`Unregistered token: ${String(token)}`);\n    }\n    return this.registry.get(token) as T;\n  }\n}\n\nexport const createContainer = (): DIContainer => new DIContainer();\n"
    },
    {
      "file_path": "src/core/utils.ts",
      "purpose": "Common utility helpers used across the app (timers, formatting, safe JSON, etc).",
      "exports": [
        "sleep",
        "formatDate",
        "clamp",
        "safeJsonParse",
        "safeJsonStringify"
      ],
      "content": "// Small collection of utilities used across the app\n\nexport async function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport function formatDate(input: string | number | Date, options?: Intl.DateTimeFormatOptions): string {\n  const d = input instanceof Date ? input : new Date(input);\n  return d.toLocaleString(undefined, options);\n}\n\nexport function clamp(n: number, min: number, max: number): number {\n  return Math.max(min, Math.min(n, max));\n}\n\nexport function safeJsonParse<T = any>(value: string, fallback: T): T {\n  try {\n    return JSON.parse(value) as T;\n  } catch {\n    return fallback;\n  }\n}\n\nexport function safeJsonStringify(value: any, replacer?: any, space?: number): string {\n  try {\n    return JSON.stringify(value, replacer, space);\n  } catch {\n    return '{}';\n  }\n}\n"
    }
  ],
  "usage_guidelines": [
    "Import types from @/core/contracts in modules that participate in domain modeling (e.g., events.ts, services).",
    "Register implementations in DI container using tokens from @/core/di.",
    "Coordinate cross-cutting concerns via @/core/events and @/core/hooks with a small, predictable API."
  ]
}