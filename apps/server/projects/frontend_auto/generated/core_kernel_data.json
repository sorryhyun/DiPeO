{
  "overview": "The Core Kernel provides single-source-of-truth TypeScript contracts, runtime config, a lightweight event bus, extensible hook registry, DI tokens/container, and common utilities. These foundational files live in src/core and src/app and are referenced across providers, services, hooks and components. They are intentionally small, strictly typed and framework-agnostic so feature code can depend on stable contracts and swap implementations in tests or alternative environments.",
  "files": [
    {
      "file_path": "src/core/contracts.ts",
      "purpose": "Domain types and API contracts for the whole application: users/roles, healthcare models (appointments, medical records, prescriptions, lab results), API response shapes, websocket events and small UI state helpers. This is the canonical type surface used by services and components.",
      "exports": [
        "User",
        "Patient",
        "Doctor",
        "Nurse",
        "Role",
        "AuthTokens",
        "ApiResult<T>",
        "ApiError",
        "PaginatedResponse<T>",
        "Pagination",
        "Appointment",
        "MedicalRecord",
        "Prescription",
        "LabResult",
        "WebsocketEvent",
        "WebsocketEventMap",
        "LoadingState",
        "FormState"
      ],
      "content": "This file defines the entire type-level contract used across services, components and providers. Key conventions: - Use discriminated unions where appropriate (e.g., Role, User.kind) - Keep DTOs lean and map server fields to client-friendly names - Mark optional fields explicitly and prefer Readonly where values should not be mutated by consumer code - Provide small helper utility type aliases like Id = string | number\n\nTypes and interfaces to provide (full list and rationale):\n\n1) Core primitives and aliases\n- type Id = string | number\n- type ISODateString = string // RFC3339/ISO8601 date/time string\n\n2) Roles and user types\n- export type Role = 'admin' | 'doctor' | 'nurse' | 'patient' | 'receptionist' | 'billing';\n- export interface UserBase { id: Id; firstName: string; lastName: string; email: string; createdAt: ISODateString; updatedAt?: ISODateString; role: Role; avatarUrl?: string; }\n- export interface Patient extends UserBase { role: 'patient'; dateOfBirth?: ISODateString; patientNumber?: string; primaryDoctorId?: Id; }\n- export interface Doctor extends UserBase { role: 'doctor'; specialty?: string[]; licenseNumber?: string; }\n- export interface Nurse extends UserBase { role: 'nurse'; certifications?: string[]; }\n- export type User = Patient | Doctor | Nurse | (UserBase & { role: Exclude<Role, 'patient' | 'doctor' | 'nurse'> });\n\nRationale: keep Patient/Doctor/Nurse expanded so UI can narrow by role.\n\n3) Auth related\n- export interface AuthTokens { accessToken: string; refreshToken?: string; expiresAt?: number; } // expiresAt = epoch ms optional\n\n4) API response shapes\n- export interface ApiError { code: string; message: string; status?: number; details?: Record<string, unknown>; }\n- export interface ApiResult<T> { success: boolean; data?: T; error?: ApiError; meta?: any; }\n\n5) Pagination helpers\n- export interface Pagination { page: number; perPage: number; total?: number; totalPages?: number; }\n- export interface PaginatedResponse<T> { items: T[]; pagination: Pagination; }\n\n6) Healthcare domain models\n- export interface Appointment { id: Id; patientId: Id; doctorId: Id; startAt: ISODateString; endAt?: ISODateString; status: 'scheduled' | 'checked_in' | 'in_progress' | 'completed' | 'cancelled'; reason?: string; location?: string; createdAt: ISODateString; updatedAt?: ISODateString; }\n\n- export interface MedicalRecord { id: Id; patientId: Id; createdById: Id; createdAt: ISODateString; type: 'visit_note' | 'allergy' | 'problem' | 'immunization' | 'other'; summary?: string; details?: string; attachments?: Array<{ url: string; filename?: string }>; }\n\n- export interface Prescription { id: Id; patientId: Id; prescribedById: Id; medication: string; dosage: string; frequency?: string; startDate?: ISODateString; endDate?: ISODateString; instructions?: string; refillsRemaining?: number; createdAt: ISODateString; }\n\n- export interface LabResult { id: Id; patientId: Id; orderedById: Id; testName: string; resultValue?: string; unit?: string; normalRange?: string; takenAt?: ISODateString; reportedAt?: ISODateString; attachments?: Array<{ url: string; filename?: string }>; }\n\nRationale: keep domain models normalized and small; services may map server DTOs to these shapes.\n\n7) WebSocket / realtime events (if websockets enabled)\n- export type WebsocketEventType = 'appointment.updated' | 'patient.updated' | 'labresult.available' | 'prescription.issued' | 'notification';\n- export interface WebsocketEvent<T = any> { type: WebsocketEventType; payload: T; receivedAt: ISODateString; correlationId?: string; }\n- export interface WebsocketEventMap { 'appointment.updated': Appointment; 'patient.updated': Patient; 'labresult.available': LabResult; 'prescription.issued': Prescription; 'notification': { title: string; body: string; level?: 'info' | 'warning' | 'error' }; }\n\n8) UI helpers\n- export type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n- export interface FormState<T = Record<string, any>> { values: T; errors?: Partial<Record<keyof T, string>>; touched?: Partial<Record<keyof T, boolean>>; isSubmitting?: boolean; }\n\n9) Utility types\n- export type Nullable<T> = T | null | undefined;\n- export type DeepReadonly<T> = { readonly [K in keyof T]: DeepReadonly<T[K]> };\n\nPatterns and conventions to follow:\n- All IDs are Id alias for flexibility between numeric/string backends.\n- Services should return ApiResult<T> or throw for network-level errors. Use ApiError for normalized errors.\n- For paginated endpoints, return PaginatedResponse<T> wrapped with ApiResult<PaginatedResponse<T>>.\n- Narrow by role in UI via guard helpers (e.g., isDoctor(user): user is Doctor).\n\nExample usage snippets:\n- import { User, ApiResult, PaginatedResponse } from '@/core/contracts';\n- async function fetchUsers(): Promise<ApiResult<PaginatedResponse<User>>> { /* ... */ }\n\nIntegration points with kernel files:\n- services/apiClient.ts should reference ApiResult and ApiError types here to ensure typed responses.\n- events.ts WebsocketEventMap should reuse WebsocketEventMap here to type real-time payloads.\n- providers/AuthProvider and contexts/AuthContext will use User and AuthTokens defined here."
    },
    {
      "file_path": "src/app/config.ts",
      "purpose": "Materialized runtime configuration exported as a typed APP_CONFIG object. Provides computed flags, feature toggles, environment info and optional mock data when development mock mode is enabled.",
      "exports": [
        "APP_CONFIG"
      ],
      "content": "This file produces a fully typed runtime configuration object named APP_CONFIG. It's safe to import anywhere in the app. It should be small, serializable and contain computed convenience flags.\n\nDefine types and structure:\n- export type Environment = 'development' | 'staging' | 'production';\n- export interface FeatureFlags { users?: boolean; appointments?: boolean; telehealth?: boolean; billing?: boolean; labs?: boolean; [key: string]: boolean | undefined; }\n- export interface DevelopmentModeConfig { enableMockData?: boolean; mockSeed?: number | string; enableVerboseLogging?: boolean; }\n- export interface AppConfig { appName: string; environment: Environment; apiBaseUrl: string; websocketUrl?: string; version?: string; buildNumber?: string | number; defaultPerPage: number; features: FeatureFlags; development_mode?: DevelopmentModeConfig; storageKeyPrefix?: string; }\n\nMaterialization and computed flags (to include in APP_CONFIG at runtime):\n- isDevelopment: boolean (environment === 'development')\n- isStaging: boolean\n- isProduction: boolean\n- shouldUseMockData: boolean (isDevelopment && development_mode?.enableMockData === true) or based on localStorage override - explain pattern below\n\nProvide a concrete default configuration object and runtime overrides:\n- APP_CONFIG should be exported as a const with type AppConfig & { isDevelopment:boolean; isStaging:boolean; isProduction:boolean; shouldUseMockData:boolean; hasFeature: (name:string)=>boolean }.\n- Allow override via window.__APP_CONFIG__ if present to support runtime injection by server or test harnesses.\n\nMock data provisioning (when development_mode.enableMockData === true):\n- Provide small in-file mock data structures used by services when the mock flag is active. This file includes only static mock fixtures such as a few users (Patient/Doctor/Nurse) and sample appointments/lab results.\n- Exported mock data should be readonly and minimal; e.g. readonly MOCK_USERS: ReadonlyArray<User> and MOCK_APPOINTMENTS.\n- The mock fixtures are guarded behind APP_CONFIG.shouldUseMockData so services must check APP_CONFIG.shouldUseMockData before using them. This keeps services deterministic.\n\nExample default APP_CONFIG (concrete recommended values):\n- appName: 'HealthPortal'\n- environment: window.__APP_CONFIG__?.environment ?? (import.meta.env && import.meta.env.MODE ? (import.meta.env.MODE as Environment) : 'development')\n- apiBaseUrl: window.__APP_CONFIG__?.apiBaseUrl ?? import.meta.env.VITE_API_BASE_URL ?? 'https://api.health-portal.local'\n- websocketUrl: window.__APP_CONFIG__?.websocketUrl ?? (new URL('/ws', apiBaseUrl)).toString()\n- version: process.env.APP_VERSION ?? '0.0.1'\n- defaultPerPage: 20\n- features: { users: true, appointments: true, telehealth: false, billing: false, labs: true }\n- development_mode: { enableMockData: true, enableVerboseLogging: true }\n- storageKeyPrefix: 'hp:'\n\nExample mock fixtures (only present if enableMockData true):\n- MOCK_USERS: array of 3 users: an admin/doctor/patient entry with realistic fields (id, name, email, role, createdAt)\n- MOCK_APPOINTMENTS: 2 appointments referencing MOCK_USERS ids\n- MOCK_LAB_RESULTS: 1 lab result for the patient\n\nRecommended usage examples:\n- import { APP_CONFIG, MOCK_USERS } from '@/app/config';\n- if (APP_CONFIG.shouldUseMockData) { userService.useMock(MOCK_USERS); }\n- console.log(APP_CONFIG.hasFeature('telehealth'))\n\nPatterns and conventions:\n- Keep config serializable and avoid functions except small helpers like hasFeature.\n- Guard production-only secrets out of this file; this file should consume env vars injected by the bundler or runtime.\n- When reading APP_CONFIG in services/providers, prefer properties and avoid reading global window.__APP_CONFIG__ directly elsewhere.\n\nIntegration points:\n- services/apiClient.ts will read APP_CONFIG.apiBaseUrl and APP_CONFIG.defaultPerPage\n- providers/ApiProvider may use APP_CONFIG.websocketUrl to configure real-time connectors\n- tests and storybooks can override window.__APP_CONFIG__ before importing APP_CONFIG to inject test values"
    },
    {
      "file_path": "src/core/events.ts",
      "purpose": "Typed, minimal EventBus used for decoupled cross-cutting communication (auth changes, toast notifications, realtime updates). Supports synchronous and asynchronous handlers, once handlers, and safe emission that collects handler results and errors into a standard shape.",
      "exports": [
        "events",
        "EventEmitter",
        "EventHandler",
        "DomainEvents"
      ],
      "content": "File responsibilities: - Provide a small class EventEmitter<E> parameterized by a typed event map E (mapping event names to payload types). - Provide utility types EventHandler<E,K> and OnceEventHandler. - Export a singleton instance named events typed with a DomainEvents map used by the app.\n\nDesign requirements and API:\n1) Typed event map\n- export interface DomainEvents { 'auth.login': { userId: string }; 'auth.logout': { userId?: string }; 'toast.show': { id?: string; title?: string; message: string; level?: 'info' | 'success' | 'warning' | 'error'; timeout?: number }; 'appointment.updated': import('@/core/contracts').Appointment; 'ws.raw': { topic: string; payload: any }; 'error.report': { error: Error | string; context?: any }; }\n\n2) EventEmitter class signature and methods\n- export class EventEmitter<E extends Record<string, any>> {\n    on<K extends keyof E>(eventName: K, handler: (payload: E[K]) => void | Promise<void>): () => void; // returns unsubscribe\n    once<K extends keyof E>(eventName: K, handler: (payload: E[K]) => void | Promise<void>): () => void;\n    off<K extends keyof E>(eventName: K, handler: (payload: E[K]) => void | Promise<void>): void;\n    emit<K extends keyof E>(eventName: K, payload: E[K]): Promise<Array<{ handlerResult?: any; error?: any }>>; // collects results/errors\n  }\n\nBehavioral details:\n- Handlers can be sync or async. emit should await each handler and return an array of result objects capturing success/error per handler so callers may inspect failures.\n- Emission order: handlers are called in registration order.\n- once handlers are removed after first successful invocation (still removed even if handler throws).\n- on returns an unsubscribe function for convenience, which calls off under the hood.\n- off removes a single handler reference; removing an unregistered handler is a no-op.\n- Protect against handler errors so one failing handler doesn't block others. All handler exceptions are captured and returned.\n\nSingleton export and usage:\n- export const events = new EventEmitter<DomainEvents>();\n\nExamples:\n- import { events } from '@/core/events';\n- const unsub = events.on('toast.show', ({ message }) => console.log('TOAST', message));\n- await events.emit('auth.login', { userId: '123' });\n- events.once('appointment.updated', appointment => { /* handle once */ });\n\nIntegration points:\n- providers/AuthProvider emits 'auth.login' and 'auth.logout' events when user signs in/out.\n- shared ErrorBoundary emits 'error.report' when capturing render errors.\n- services that handle websocket messages route parsed events to events.emit('ws.raw', {...}) and to specific typed events like 'appointment.updated'.\n\nPerformance and memory notes:\n- Keep handler lists small and avoid holding closures with long-lived memory. In large apps, consider scoped emitters per feature; this global emitter is intended for cross-cutting lightweight signals.\n\nTesting tips:\n- Tests can subscribe to events and await emitted results. Remember to unsubscribe after each test to avoid leakage."
    },
    {
      "file_path": "src/core/hooks.ts",
      "purpose": "A small hook registry / extension-point system for features to register callbacks at strategic points. Hooks are synchronous or asynchronous and support ordering and short-circuiting when needed.",
      "exports": [
        "HookRegistry",
        "registerHook",
        "runHook",
        "HookPoint",
        "HookContext"
      ],
      "content": "This file provides a tiny extensibility mechanism: named HookPoints that features can register handlers for. The registry should be lightweight and safe for both browser runtime registration (when a feature module mounts) and server-side tests.\n\nDefinitions and API:\n1) HookPoint union\n- export type HookPoint = 'beforeApiRequest' | 'afterApiResponse' | 'onLogin' | 'onLogout' | 'onRouteChange' | 'onErrorReported';\n\n2) HookContext\n- export interface HookContext { id?: string; source?: string; timestamp: string; meta?: Record<string, any>; }\n- For beforeApiRequest/afterApiResponse include request/response shape types in meta e.g., meta.request, meta.response\n\n3) Hook handler signature\n- Handlers can be sync or async and receive a payload dependent on the hook point and a shared HookContext. Example generic signature:\n  type HookHandler<P = any> = (payload: P, ctx: HookContext) => Promise<any> | any;\n\n4) HookRegistry class\n- class HookRegistry {\n    register<P = any>(point: HookPoint, handler: HookHandler<P>, options?: { id?: string; priority?: number }): () => void; // returns unregister\n    run<P = any>(point: HookPoint, payload?: P, ctx?: Partial<HookContext>): Promise<Array<{ handlerId?: string; result?: any; error?: any }>>;\n    clear(point?: HookPoint): void; // clear handlers for a point or all\n  }\n\nBehavioral details:\n- Handlers can be registered with a numeric priority (default 0). Lower priority numbers run earlier. This allows features to insert pre/post handlers predictably.\n- run executes handlers in priority order ascending and collects results into an array. run awaits each handler; if a handler throws, the error is captured and the remaining handlers still run (unless an option to short-circuit is added in future).\n- register returns an unregister function to remove the handler. Each handler may optionally have an id (string) used for bookkeeping.\n- Handler identity: equality is by function reference and optional id; registry must track both.\n\nStandard hooks and payload shapes (recommended):\n- beforeApiRequest: payload { url: string; method: string; headers?: Record<string,string>; body?: any; signal?: AbortSignal } - used to add headers/metrics/tracing; handlers may mutate payload in-place or return a transformed payload\n- afterApiResponse: payload { url: string; method: string; status: number; response: any; elapsedMs?: number } - used to implement telemetry, analytics, or post-processing\n- onLogin: payload { userId: string; tokens?: import('@/core/contracts').AuthTokens }\n- onLogout: payload { userId?: string }\n- onRouteChange: payload { from?: string; to: string }\n- onErrorReported: payload { error: any; context?: any }\n\nExported helpers:\n- export const globalHookRegistry = new HookRegistry();\n- export function registerHook(...) { return globalHookRegistry.register(...); }\n- export function runHook(...) { return globalHookRegistry.run(...); }\n\nExample usage:\n- import { registerHook, runHook } from '@/core/hooks';\n- const unregister = registerHook('beforeApiRequest', (payload, ctx) => { payload.headers = payload.headers ?? {}; payload.headers['x-request-source'] = 'dashboard'; }, { priority: -10 });\n- await runHook('onLogin', { userId: 'u1' });\n\nIntegration points:\n- services/apiClient.ts should call runHook('beforeApiRequest', { ... }) before sending and runHook('afterApiResponse', { ... }) after receiving a response. That allows features to inject headers, trace, instrument and modify responses.\n- providers/AuthProvider should runHook('onLogin', ...) and 'onLogout' appropriately so other features can react.\n- RootProvider or route layer can call runHook('onRouteChange', { from, to }) on navigation events.\n\nPatterns and conventions:\n- Keep hook handlers idempotent and side-effect minimal; use priority ordering for coordination.\n- Prefer to mutate payload in-place for performance but document when a handler returns a new payload (consistent contract) \u2014 registry should accept either mutation or returned value but runHook should always pass final payload to next handler.\n- In order to future-proof, design run to accept options like { shortCircuitOnTruthy?: boolean } though not required initially."
    },
    {
      "file_path": "src/core/di.ts",
      "purpose": "A minimal, type-safe dependency injection (service locator) used to register and resolve runtime implementations for common services (ApiClient, AuthService, StorageService, WebSocketService). It supports overriding implementations for tests or feature-level composition.",
      "exports": [
        "container",
        "provide",
        "resolve",
        "Token"
      ],
      "content": "Design goals:\n- Lightweight and typed: tokens carry type information for resolution\n- Allow late binding and safe overrides in tests\n- Prevent accidental re-provide in production unless explicitly allowed\n\nAPI and types to implement:\n1) Token<T>\n- export interface Token<T> { readonly key: symbol; readonly name?: string; }\n- export function createToken<T>(name?: string): Token<T> // returns a unique token\n\n2) Core tokens to export (examples):\n- export const API_CLIENT = createToken<{ request: <T>(input: RequestInfo, init?: RequestInit)=>Promise<T> }>('API_CLIENT');\n- export const AUTH_SERVICE = createToken<{ login: (u:string,p:string)=>Promise<any>; logout:()=>Promise<void>; getCurrentUser: ()=>Promise<import('@/core/contracts').User | null> }>('AUTH_SERVICE');\n- export const STORAGE_SERVICE = createToken<{ get: (k:string)=>Promise<any>; set: (k:string,v:any)=>Promise<void>; remove: (k:string)=>Promise<void> }>('STORAGE_SERVICE');\n- export const WEBSOCKET_SERVICE = createToken<{ connect: ()=>Promise<void>; disconnect: ()=>Promise<void>; send: (topic:string,payload:any)=>void }>('WEBSOCKET_SERVICE');\n\n3) Container class signature\n- class Container {\n    provide<T>(token: Token<T>, implementation: T, options?: { override?: boolean }): void;\n    resolve<T>(token: Token<T>): T; // throws if not registered\n    has(token: Token<any>): boolean;\n    clear(): void; // clear all registrations (useful for tests)\n  }\n\n4) Top-level exports and convenience helpers\n- export const container = new Container();\n- export function provide<T>(token: Token<T>, impl: T, options?: { override?: boolean }) { container.provide(token, impl, options); }\n- export function resolve<T>(token: Token<T>) { return container.resolve(token); }\n\nBehavioral details and safety:\n- provide should throw if token already registered unless options.override === true. This prevents accidental double-registration in production. Tests can call container.clear() or override explicitly.\n- resolve throws a descriptive error when token not registered; provide helpful message listing token.name.\n- container should be a module-level singleton to keep consistent registrations app-wide.\n- Avoid storing heavy closures or DOM nodes in the container; use it for services only.\n\nUsage examples:\n- import { provide, resolve, API_CLIENT } from '@/core/di';\n- provide(API_CLIENT, { request: apiClient.request.bind(apiClient) });\n- const api = resolve(API_CLIENT);\n- await api.request('/users');\n\nIntegration points:\n- RootProvider should register concrete implementations for API_CLIENT, AUTH_SERVICE, STORAGE_SERVICE and WEBSOCKET_SERVICE during app bootstrap. Providers/services may also register wrappers that decorate underlying implementations.\n- Tests can call container.clear() in afterEach to avoid cross-test pollution and register mock implementations via provide(..., { override: true }).\n\nNotes on Type Safety:\n- createToken<T>() returns a token typed to T; provide/resolve are typed and enforce compile-time guarantees.\n- Use Token names for helpful debugging only; do not rely on names for resolution."
    },
    {
      "file_path": "src/core/utils.ts",
      "purpose": "Common lightweight utility helpers used across services and components: fetchWithTimeout, safeJsonParse, formatDate, relativeTime helpers, and a small debug logger that respects APP_CONFIG development flags.",
      "exports": [
        "fetchWithTimeout",
        "safeJsonParse",
        "formatDate",
        "formatDateTime",
        "relativeTime",
        "debugLog"
      ],
      "content": "This file exposes deterministic, well-typed helpers with no side effects. Keep implementations small and dependency-free.\n\nFunctions to implement and expected behavior:\n\n1) fetchWithTimeout\n- Signature: export async function fetchWithTimeout(input: RequestInfo, init?: RequestInit & { timeoutMs?: number }, defaultTimeout?: number): Promise<Response>\n- Behavior: Uses AbortController to abort fetch after provided timeoutMs or defaultTimeout. If aborted, throws an Error with name 'AbortError' and message 'Request timed out'. The returned promise rejects with original fetch error or timeout error.\n- Good for services/apiClient to cancel slow requests.\n\n2) safeJsonParse\n- Signature: export function safeJsonParse<T = any>(input: string | null | undefined): T | null\n- Behavior: Returns parsed object or null on parse errors. Do not throw. Useful for reading localStorage or server-sent strings.\n\n3) formatDate and formatDateTime\n- Signature: export function formatDate(isoString: string, options?: Intl.DateTimeFormatOptions): string\n- Signature: export function formatDateTime(isoString: string, options?: Intl.DateTimeFormatOptions): string\n- Behavior: Use Intl.DateTimeFormat with sensible defaults, fallback gracefully when isoString is invalid.\n\n4) relativeTime\n- Signature: export function relativeTime(isoString: string): string\n- Behavior: Return human-friendly relative time like '5m ago', '2d ago', 'in 3h'. Use simple thresholds (seconds/minutes/hours/days) \u2014 no external libs.\n\n5) debugLog\n- Signature: export const debugLog: (...args: any[]) => void\n- Behavior: Logs to console only if APP_CONFIG.isDevelopment or development_mode.enableVerboseLogging is true. Ensure it's a no-op in production by checking config. Accepts an optional tag as first arg if string.\n\nExample implementations and usage:\n- import { fetchWithTimeout } from '@/core/utils';\n- const res = await fetchWithTimeout('/health', { timeoutMs: 5000 });\n- import { safeJsonParse } from '@/core/utils';\n- const obj = safeJsonParse(localStorage.getItem('hp:user'));\n\nIntegration points and patterns:\n- services/apiClient.ts uses fetchWithTimeout and debugLog to perform requests and log when verbose mode enabled.\n- Providers and hooks can use formatDate/relativeTime for consistent UI presentation.\n\nPerformance and reliability notes:\n- All functions must be synchronous or return a Promise when needed; avoid heavy CPU work.\n- Keep code small and well documented; these utilities are shared widely so avoid changing semantics once in production."
    }
  ],
  "usage_guidelines": [
    "Import domain types from '@/core/contracts' everywhere \u2014 services must return ApiResult<T> and components should accept domain models from there.",
    "Use APP_CONFIG from '@/app/config' for runtime flags, base URL and feature toggles. Check APP_CONFIG.shouldUseMockData before using any mock fixtures.",
    "Use the typed events singleton from '@/core/events' (events.on / events.emit) for cross-cutting communication such as auth changes and toast notifications.",
    "Register platform-level implementations in the DI container (src/core/di.ts) inside RootProvider: provide(API_CLIENT, apiClientImpl); provide(AUTH_SERVICE, authServiceImpl); provide(STORAGE_SERVICE, storageImpl);",
    "Use the hook registry ('@/core/hooks') to extend behavior: services/apiClient should run runHook('beforeApiRequest', payload) and runHook('afterApiResponse', payload) around network calls; AuthProvider should run onLogin/onLogout hooks.",
    "Prefer resolving dependencies via the DI token (resolve(API_CLIENT)) inside services when you need to call an external sink; tests can override implementations by calling provide(token, mockImpl, { override: true }) or container.clear().",
    "Use utils from '@/core/utils' for consistent fetch timeouts, safe JSON parsing and date formatting.",
    "Keep handlers idempotent and small: event and hook handlers should only do narrowly scoped work (emit side-effects, update caches, route analytics). Avoid heavy long-running work inside handlers \u2014 schedule work off the main handler if needed.",
    "When adding new hook points or events, add typed entries to contracts.ts where appropriate and update the DomainEvents map in events.ts and HookPoint union in hooks.ts for consistent typing across the app.",
    "For testing: clear the DI container between tests, register mock implementations and optionally set window.__APP_CONFIG__ before importing APP_CONFIG to inject test config values."
  ]
}