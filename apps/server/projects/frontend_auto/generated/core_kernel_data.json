{
  "overview": "The Core Kernel provides a small, well-typed foundation for the entire application. It centralizes domain contracts, runtime configuration, a typed event bus, an extensible hook registry, a tiny dependency-injection container, and generic utilities. All feature modules, providers and services should import types and primitives from these files (use @/core/* imports). These files are minimal, focused, and immediately usable in production and development workflows (including mock-mode).",
  "files": [
    {
      "file_path": "src/core/contracts.ts",
      "purpose": "Domain types, DTOs and API contracts shared across services and UI. Provides a single source of truth for domain models, API shapes and WS events.",
      "exports": [
        "Role",
        "AuthToken",
        "User",
        "Patient",
        "Doctor",
        "Nurse",
        "Appointment",
        "AppointmentStatus",
        "MedicalRecord",
        "Prescription",
        "PrescriptionStatus",
        "LabResult",
        "LabResultSeverity",
        "InsuranceClaim",
        "InsuranceStatus",
        "Medication",
        "PaginationParams",
        "ApiResult",
        "PaginatedResponse",
        "ApiError",
        "WebsocketEvent",
        "WebsocketEventMap",
        "LoadingState",
        "FormState"
      ],
      "content": "/* src/core/contracts.ts\n   Central domain contracts used across services and UI.\n   Keep this file small and stable; prefer additive changes.\n*/\n\nexport enum Role {\n  PATIENT = 'patient',\n  DOCTOR = 'doctor',\n  NURSE = 'nurse',\n  ADMIN = 'admin'\n}\n\nexport type AuthToken = string & { __brand?: 'AuthToken' };\n\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  role: Role;\n  avatarUrl?: string | null;\n  createdAt: string; // ISO\n}\n\nexport interface Patient extends User {\n  role: Role.PATIENT;\n  dateOfBirth?: string; // ISO\n  medicalRecordNumber?: string;\n}\n\nexport interface Doctor extends User {\n  role: Role.DOCTOR;\n  specialty?: string;\n  licenseNumber?: string;\n}\n\nexport interface Nurse extends User {\n  role: Role.NURSE;\n  department?: string;\n}\n\nexport type AnyUser = Patient | Doctor | Nurse | User;\n\nexport enum AppointmentStatus {\n  SCHEDULED = 'scheduled',\n  COMPLETED = 'completed',\n  CANCELLED = 'cancelled',\n  NO_SHOW = 'no_show',\n  RESCHEDULED = 'rescheduled'\n}\n\nexport interface Appointment {\n  id: string;\n  patientId: string;\n  providerId: string; // doctor or nurse\n  startAt: string; // ISO\n  endAt: string; // ISO\n  status: AppointmentStatus;\n  reason?: string;\n  location?: string | { type: 'virtual' | 'in-person'; details?: string };\n  createdAt: string;\n  updatedAt?: string;\n}\n\nexport interface MedicalRecord {\n  id: string;\n  patientId: string;\n  title: string;\n  notes?: string;\n  attachments?: Array<{ id: string; name: string; url?: string }>; // url may be absent in mock\n  createdAt: string;\n  reviewedBy?: string; // provider id\n}\n\nexport enum PrescriptionStatus {\n  ACTIVE = 'active',\n  EXPIRED = 'expired',\n  CANCELLED = 'cancelled',\n  REFILLED = 'refilled'\n}\n\nexport interface Prescription {\n  id: string;\n  patientId: string;\n  prescriberId: string;\n  medicationId: string;\n  dosage: string;\n  frequency?: string;\n  durationDays?: number;\n  status: PrescriptionStatus;\n  issuedAt: string;\n  expiresAt?: string;\n}\n\nexport enum LabResultSeverity {\n  NORMAL = 'normal',\n  WARNING = 'warning',\n  CRITICAL = 'critical'\n}\n\nexport interface LabResult {\n  id: string;\n  patientId: string;\n  testName: string;\n  value: string | number;\n  unit?: string;\n  referenceRange?: string;\n  severity?: LabResultSeverity;\n  collectedAt: string;\n  reportedAt?: string;\n}\n\nexport enum InsuranceStatus {\n  PENDING = 'pending',\n  APPROVED = 'approved',\n  DENIED = 'denied',\n  PAID = 'paid'\n}\n\nexport interface InsuranceClaim {\n  id: string;\n  patientId: string;\n  providerId?: string;\n  amount: number;\n  status: InsuranceStatus;\n  submittedAt: string;\n  updatedAt?: string;\n  notes?: string;\n}\n\nexport interface Medication {\n  id: string;\n  name: string;\n  doseForm?: string; // e.g., 'tablet', 'syrup'\n  strength?: string; // e.g., '10mg'\n  instructions?: string;\n  rxRequired?: boolean;\n}\n\nexport interface PaginationParams {\n  page?: number; // 1-based\n  pageSize?: number;\n  q?: string; // search query\n  sortBy?: string;\n  sortDir?: 'asc' | 'desc';\n}\n\nexport interface ApiResult<T> {\n  data: T;\n  meta?: Record<string, unknown>;\n}\n\nexport interface PaginatedResponse<T> {\n  items: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n}\n\nexport interface ApiError {\n  code: string; // machine code\n  message: string; // human friendly\n  status?: number; // HTTP status\n  details?: Record<string, unknown> | string;\n}\n\n/* Minimal WebSocket / event types used by providers and the mock websocket\n   Real app may expand payloads. Having stable event keys helps TypeScript\n   across the app when subscribing to events.\n*/\nexport type WebsocketEvent =\n  | { type: 'appointment.updated'; payload: Appointment }\n  | { type: 'labresult.created'; payload: LabResult }\n  | { type: 'prescription.refilled'; payload: Prescription }\n  | { type: 'medication.reminder'; payload: { medicationId: string; userId: string; remindAt: string } }\n  | { type: 'insurance.updated'; payload: InsuranceClaim };\n\nexport type WebsocketEventMap = {\n  'appointment.updated': Appointment;\n  'labresult.created': LabResult;\n  'prescription.refilled': Prescription;\n  'medication.reminder': { medicationId: string; userId: string; remindAt: string };\n  'insurance.updated': InsuranceClaim;\n};\n\n/* Common UI state types used by shared components */\nexport type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\nexport interface FormState<FieldValues extends Record<string, any> = Record<string, any>> {\n  values: FieldValues;\n  touched: Partial<Record<keyof FieldValues, boolean>>;\n  errors: Partial<Record<keyof FieldValues, string>>;\n  isSubmitting: boolean;\n}\n\n/* Example usage:\nimport { Appointment, User, ApiResult } from '@/core/contracts';\n\nfunction handleAppointment(resp: ApiResult<Appointment>) {\n  const appointment = resp.data;\n  console.log(appointment.startAt);\n}\n*/"
    },
    {
      "file_path": "src/app/config.ts",
      "purpose": "Materialized runtime configuration. Exposes a typed AppConfig, computed flags, feature toggles and development mock users & endpoints. This file is the single source for runtime flags and should be referenced by providers and the mock server.",
      "exports": [
        "AppConfig",
        "appConfig",
        "DEV_MOCK_ENDPOINTS"
      ],
      "content": "/* src/app/config.ts\n   Runtime configuration. Keep non-sensitive defaults here. For production, the build can replace\n'this file' or environment variables injected. For this project we materialize the provided\nconfiguration for development-first behavior (mock mode enabled by default in dev).\n*/\n\nimport { Role, User } from '@/core/contracts';\n\nexport interface AppConfig {\n  appName: string;\n  apiBaseUrl: string; // used by apiClient in production\n  features: string[]; // feature toggles list\n  env: 'development' | 'production' | 'test';\n  enableMockData: boolean;\n  disableWebsocketInDev: boolean;\n  useLocalStoragePersistence: boolean;\n  mockApiEndpoints: string[];\n  devMockUsers: User[];\n}\n\n// Materialized defaults based on provided project configuration\nconst DEFAULT_MOCK_USERS: User[] = [\n  {\n    id: 'u-doctor-1',\n    email: 'doctor@hospital.com',\n    name: 'Dr. Alice Kim',\n    role: Role.DOCTOR,\n    avatarUrl: null,\n    createdAt: new Date().toISOString()\n  },\n  {\n    id: 'u-patient-1',\n    email: 'patient@email.com',\n    name: 'John Patient',\n    role: Role.PATIENT,\n    avatarUrl: null,\n    createdAt: new Date().toISOString()\n  },\n  {\n    id: 'u-nurse-1',\n    email: 'nurse@hospital.com',\n    name: 'Nora Nurse',\n    role: Role.NURSE,\n    avatarUrl: null,\n    createdAt: new Date().toISOString()\n  }\n];\n\nexport const DEV_MOCK_ENDPOINTS = [\n  '/api/appointments',\n  '/api/medical-records',\n  '/api/prescriptions',\n  '/api/lab-results',\n  '/api/insurance',\n  '/api/medications'\n] as const;\n\nexport const appConfig: AppConfig = {\n  appName: 'Healthcare Portal',\n  apiBaseUrl: typeof window !== 'undefined' ? window.location.origin + '/api' : 'http://localhost:3000/api',\n  features: [\n    'appointment scheduling',\n    'medical records viewer',\n    'prescription management',\n    'telemedicine interface',\n    'health metrics dashboard',\n    'lab results display',\n    'insurance claim tracker',\n    'medication reminders'\n  ],\n  env: (process.env.NODE_ENV as AppConfig['env']) || 'development',\n  enableMockData: true, // development-first default; providers will honor computed flags\n  disableWebsocketInDev: true,\n  useLocalStoragePersistence: true,\n  mockApiEndpoints: DEV_MOCK_ENDPOINTS as unknown as string[],\n  devMockUsers: DEFAULT_MOCK_USERS\n};\n\n/* Computed helpers */\nexport const isDevelopment = appConfig.env === 'development';\nexport const shouldUseMockData = isDevelopment && appConfig.enableMockData;\n\n/* Example usage:\nimport { appConfig, shouldUseMockData } from '@/app/config';\nif (shouldUseMockData) { startMockServer(); }\n*/"
    },
    {
      "file_path": "src/core/events.ts",
      "purpose": "A tiny, strongly-typed event bus used for broadcasting domain events across providers and features. Useful for integrating WebSocket messages with React Query or local state.",
      "exports": [
        "eventBus",
        "EventTypes",
        "subscribe",
        "publish",
        "unsubscribe"
      ],
      "content": "/* src/core/events.ts\n   Typed EventBus with both sync and async handler support.\n   Use it to decouple providers from consumers (e.g., WebsocketProvider publishes, pages subscribe).\n*/\n\nimport {\n  Appointment,\n  LabResult,\n  Prescription,\n  InsuranceClaim,\n  WebsocketEventMap\n} from '@/core/contracts';\n\n/* Define the event names used across the app. Keep this narrow and stable. */\nexport type EventTypes =\n  | 'appointment.updated'\n  | 'appointment.created'\n  | 'appointment.deleted'\n  | 'labresult.created'\n  | 'prescription.refilled'\n  | 'medication.reminder'\n  | 'insurance.updated'\n  | 'auth.login'\n  | 'auth.logout';\n\n/* Map event names to payload types for compile-time safety. Extend as needed. */\nexport interface EventPayloadMap {\n  'appointment.updated': Appointment;\n  'appointment.created': Appointment;\n  'appointment.deleted': { id: string };\n  'labresult.created': LabResult;\n  'prescription.refilled': Prescription;\n  'medication.reminder': { medicationId: string; userId: string; remindAt: string };\n  'insurance.updated': InsuranceClaim;\n  'auth.login': { userId: string };\n  'auth.logout': { userId?: string };\n}\n\ntype Handler<K extends EventTypes> = (payload: EventPayloadMap[K]) => void | Promise<void>;\n\nclass EventBus {\n  private handlers: Map<EventTypes, Set<Handler<any>>> = new Map();\n\n  on<K extends EventTypes>(event: K, handler: Handler<K>): () => void {\n    const set = this.handlers.get(event) ?? new Set();\n    set.add(handler as Handler<any>);\n    this.handlers.set(event, set);\n\n    // return unsubscribe\n    return () => {\n      set.delete(handler as Handler<any>);\n      if (set.size === 0) this.handlers.delete(event);\n    };\n  }\n\n  off<K extends EventTypes>(event: K, handler: Handler<K>): void {\n    const set = this.handlers.get(event);\n    if (!set) return;\n    set.delete(handler as Handler<any>);\n    if (set.size === 0) this.handlers.delete(event);\n  }\n\n  async emit<K extends EventTypes>(event: K, payload: EventPayloadMap[K]): Promise<void> {\n    const set = this.handlers.get(event);\n    if (!set || set.size === 0) return;\n\n    // Run handlers and await any returned Promises; do not short-circuit\n    const promises: Array<void | Promise<void>> = [];\n    for (const h of Array.from(set)) {\n      try {\n        const result = (h as Handler<K>)(payload);\n        promises.push(result as Promise<void> | void);\n      } catch (err) {\n        // swallow sync errors but log for diagnostics\n        // In production integrate with a structured logger\n        // eslint-disable-next-line no-console\n        console.error('[EventBus] handler sync error', event, err);\n      }\n    }\n    await Promise.all(promises.map(p => Promise.resolve(p)));\n  }\n\n  clear(): void {\n    this.handlers.clear();\n  }\n}\n\nexport const eventBus = new EventBus();\n\n/* Convenience helpers for non-class-based code */\nexport const subscribe = <K extends EventTypes>(event: K, handler: Handler<K>): () => void => eventBus.on(event, handler);\nexport const unsubscribe = <K extends EventTypes>(event: K, handler: Handler<K>): void => eventBus.off(event, handler);\nexport const publish = async <K extends EventTypes>(event: K, payload: EventPayloadMap[K]): Promise<void> => eventBus.emit(event, payload);\n\n/* Example usage:\nimport { subscribe, publish } from '@/core/events';\n\nconst off = subscribe('labresult.created', async (lab) => { console.log('new lab', lab); });\nawait publish('labresult.created', labResultInstance);\n// later to unsubscribe: off();\n*/"
    },
    {
      "file_path": "src/core/hooks.ts",
      "purpose": "Hook registry for extension points. Providers and features register small callbacks (hooks) for cross-cutting behavior: logging, instrumentation, request lifecycle and auth changes. The registry supports ordering and both sync & async handlers.",
      "exports": [
        "registerHook",
        "invokeHook",
        "HookName"
      ],
      "content": "/* src/core/hooks.ts\n   HookRegistry enables named extension points across the application.\n   Keep hook side-effects idempotent; hooks should be small.\n*/\n\nimport { ApiError } from '@/core/contracts';\n\nexport type HookName =\n  | 'beforeApiRequest'\n  | 'afterApiResponse'\n  | 'onLogin'\n  | 'onLogout'\n  | 'onRouteChange';\n\nexport interface BeforeApiRequestContext {\n  url: string;\n  method: string;\n  headers?: Record<string, string>;\n  body?: unknown;\n}\n\nexport interface AfterApiResponseContext<T = unknown> {\n  url: string;\n  method: string;\n  status: number;\n  data?: T;\n  error?: ApiError | null;\n}\n\nexport interface OnAuthContext {\n  userId?: string;\n}\n\nexport interface OnRouteChangeContext {\n  from?: string;\n  to: string;\n}\n\ntype HookHandler<T> = (ctx: T) => void | Promise<void>;\n\nclass HookRegistry {\n  private registry: Map<HookName, Set<HookHandler<any>>> = new Map();\n\n  register<T>(name: HookName, handler: HookHandler<T>): () => void {\n    const set = this.registry.get(name) ?? new Set();\n    set.add(handler as HookHandler<any>);\n    this.registry.set(name, set);\n    return () => set.delete(handler as HookHandler<any>);\n  }\n\n  async invoke<T>(name: HookName, ctx: T): Promise<void> {\n    const set = this.registry.get(name);\n    if (!set) return;\n    const tasks: Array<void | Promise<void>> = [];\n    for (const h of Array.from(set)) {\n      try {\n        tasks.push((h as HookHandler<T>)(ctx));\n      } catch (err) {\n        // swallow single handler errors but log\n        // eslint-disable-next-line no-console\n        console.error('[HookRegistry] handler threw', name, err);\n      }\n    }\n    await Promise.all(tasks.map(p => Promise.resolve(p)));\n  }\n\n  clear(name?: HookName) {\n    if (name) this.registry.delete(name);\n    else this.registry.clear();\n  }\n}\n\nconst registry = new HookRegistry();\n\n/* Public helpers */\nexport const registerHook = <T>(name: HookName, handler: HookHandler<T>): (() => void) => registry.register(name, handler as HookHandler<any>);\nexport const invokeHook = async <T>(name: HookName, ctx: T): Promise<void> => registry.invoke(name, ctx);\n\n/* Example common hook usage:\n\nimport { registerHook, invokeHook } from '@/core/hooks';\n\n// Register instrumentation for all API requests\nconst off = registerHook('beforeApiRequest', (ctx: BeforeApiRequestContext) => {\n  console.log('[API] request', ctx.method, ctx.url);\n});\n\n// In api client, call invokeHook('beforeApiRequest', { url, method, headers, body });\n*/"
    },
    {
      "file_path": "src/core/di.ts",
      "purpose": "A minimal, type-safe dependency injection container. It lets parts of the app (tests or mock providers) register alternate implementations for well-known tokens (ApiClient, AuthService, StorageService, WebsocketService). Prefer passing dependencies explicitly where possible; the DIContainer is a pragmatic escape hatch for app-wide swaps in tests or dev.",
      "exports": [
        "DIContainer",
        "registerService",
        "getService"
      ],
      "content": "/* src/core/di.ts\n   Tiny type-safe DI container. Tokens are unique symbols with associated types.\n   Usage:\n     const AuthServiceToken = token<AuthService>('AuthService');\n     registerService(AuthServiceToken, new MockAuthService());\n     const auth = getService(AuthServiceToken);\n*/\n\nexport type Token<T> = symbol & { __type?: T };\n\nexport const token = <T = unknown>(description = 'token'): Token<T> => Symbol(description) as Token<T>;\n\nclass DIContainer {\n  private map = new Map<symbol, unknown>();\n\n  register<T>(t: Token<T>, impl: T): void {\n    this.map.set(t as symbol, impl);\n  }\n\n  resolve<T>(t: Token<T>): T {\n    if (!this.map.has(t as symbol)) {\n      throw new Error(`DIContainer: no binding for token ${String(t)}`);\n    }\n    return this.map.get(t as symbol) as T;\n  }\n\n  has(t: Token<any>): boolean {\n    return this.map.has(t as symbol);\n  }\n\n  clear(): void {\n    this.map.clear();\n  }\n}\n\nexport const di = new DIContainer();\n\n/* Predefined tokens for common services. Types are intentionally minimal so the kernel does not\n   depend on service implementations. Services can extend these interfaces.\n*/\n\nexport interface ApiClientLike {\n  request<T = unknown>(input: RequestInfo, init?: RequestInit): Promise<T>;\n}\n\nexport interface AuthServiceLike {\n  login(email: string, password: string): Promise<{ token: string; user: { id: string } }>;\n  logout(): Promise<void>;\n  getCurrentUser(): Promise<{ id: string } | null>;\n}\n\nexport interface StorageServiceLike {\n  get<T = unknown>(key: string): Promise<T | null> | T | null;\n  set<T = unknown>(key: string, value: T): Promise<void> | void;\n  remove(key: string): Promise<void> | void;\n}\n\nexport interface WebsocketServiceLike {\n  connect(url: string): Promise<void> | void;\n  disconnect(): Promise<void> | void;\n  send(event: unknown): void;\n}\n\nexport const ApiClientToken = token<ApiClientLike>('ApiClient');\nexport const AuthServiceToken = token<AuthServiceLike>('AuthService');\nexport const StorageServiceToken = token<StorageServiceLike>('StorageService');\nexport const WebsocketServiceToken = token<WebsocketServiceLike>('WebsocketService');\n\n/* Register and resolve helpers */\nexport const registerService = <T>(t: Token<T>, impl: T) => di.register(t, impl);\nexport const getService = <T>(t: Token<T>): T => di.resolve(t);\n\n/* Example usage:\nimport { ApiClientToken, registerService, getService } from '@/core/di';\n\n// In test setup\nregisterService(ApiClientToken, { request: async (input) => ({ data: 'ok' }) });\n\n// In a service file\nconst client = getService(ApiClientToken);\nawait client.request('/api/appointments');\n*/"
    },
    {
      "file_path": "src/core/utils.ts",
      "purpose": "Small, well-tested utilities used across the app: safe json parse, sleep, development detection and small helpers. Keep utilities generic and dependency-free where possible.",
      "exports": [
        "safeJsonParse",
        "sleep",
        "isDev"
      ],
      "content": "/* src/core/utils.ts\n   Generic utilities used throughout the application.\n*/\n\nimport { appConfig } from '@/app/config';\n\nexport const isDev = appConfig.env === 'development';\n\nexport function safeJsonParse<T = unknown>(input: string | null | undefined, fallback: T): T {\n  if (!input) return fallback;\n  try {\n    return JSON.parse(input) as T;\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.warn('[safeJsonParse] parse failed, returning fallback', err);\n    return fallback;\n  }\n}\n\nexport const sleep = (ms: number) => new Promise<void>(res => setTimeout(res, ms));\n\nexport function uid(prefix = ''): string {\n  // small, collision-resistant id for mock data and temporary keys\n  return prefix + Math.random().toString(36).slice(2, 9) + Date.now().toString(36).slice(-4);\n}\n\nexport function debugLog(...args: any[]) {\n  if (isDev) {\n    // eslint-disable-next-line no-console\n    console.debug('[debug]', ...args);\n  }\n}\n\n/* Example usage:\nimport { safeJsonParse, sleep, isDev } from '@/core/utils';\n\nif (isDev) debugLog('running in development');\nawait sleep(200);\n*/"
    }
  ],
  "usage_guidelines": [
    "Import domain types from @/core/contracts. Keep contracts stable; only additive changes to enums and interfaces should be made after initial release.",
    "Use appConfig (from @/app/config) in providers and services to toggle mock behavior. Do not import raw process.env values elsewhere\u2014use appConfig as a single source of runtime flags.",
    "Publish domain-wide notifications via the singleton eventBus (@/core/events) rather than ad-hoc Events. Use typed payloads to ensure consumers get compile-time checks.",
    "Register extension behavior via registerHook(@/core/hooks) for cross-cutting concerns (e.g., analytics, request instrumentation). Invoke hooks from apiClient and auth flows (invokeHook('beforeApiRequest', ctx)).",
    "Prefer explicit dependency injection using the DI container (@/core/di) only for app-level service swaps (tests and mock providers). For normal components, prefer React context + props.",
    "Use utilities in @/core/utils for safe JSON parsing and development-aware logging. Keep utility functions small and well-documented.",
    "Example pattern for api client integration:\n - apiClient invokes invokeHook('beforeApiRequest', { url, method }) before sending.\n - apiClient invokes invokeHook('afterApiResponse', { url, method, status, data, error }) after the response.\n - The MockServerProvider inspects appConfig.shouldUseMockData and starts the mock server if enabled.",
    "For real-time features, WebsocketProvider should publish incoming messages to eventBus.publish('labresult.created', payload) so React Query or components can subscribe.",
    "When writing tests, register test doubles with core/di registerService() at the top of test suites and clear them in teardown."
  ]
}