{
  "overview": "The Core Kernel provides a small, well-typed foundation shared by all sections of the application. It centralizes domain contracts, runtime configuration, a typed event bus for decoupled messaging, a hook/extension registry, a lightweight dependency-injection container, and a set of minimal, safe utilities. All higher-level services, providers, and feature modules should import types and utilities from these files (use import paths like '@/core/contracts', '@/core/events', '@/core/hooks', '@/core/di', '@/core/utils', and '@/app/config'). The kernel is intentionally small, focused, and strictly typed so it can be used across the React app, the in-project mock server, and unit tests.",
  "files": [
    {
      "file_path": "src/core/contracts.ts",
      "purpose": "Single source of truth for domain types used across the app. Includes e-commerce domain models (Product, Cart, Order, Review, User) and also a few healthcare types to satisfy cross-domain contract requirements so the kernel can be extended safely. It also contains API response and websocket event typings, pagination helpers, and UI state types.",
      "exports": [
        "Product",
        "ProductVariant",
        "CartItem",
        "Cart",
        "Order",
        "OrderStatus",
        "User",
        "AuthToken",
        "Review",
        "Paginated",
        "ApiResult",
        "ApiError",
        "WsEvent",
        "LoadingState",
        "FormState",
        "Patient",
        "Doctor",
        "Nurse",
        "Appointment",
        "MedicalRecord",
        "Prescription",
        "LabResult"
      ],
      "content": "Overview\n- Provide strict TypeScript interfaces for all domain models used across services, providers, mocks and components.\n- Keep interfaces small and composable; prefer readonly fields where possible.\n\nDesign conventions\n- Use PascalCase for types and enums\n- Use generics for reusable shapes (Paginated<T>, ApiResult<T>)\n- Keep API-level fields optional when backend may not return them\n- Include basic JSDoc for clarity\n\nType definitions (examples)\n- E-commerce domain models\n\nexport type ID = string;\n\n/** Product variant (size/color/sku mapping) */\nexport interface ProductVariant {\n  id: ID;\n  sku: string;\n  title?: string;\n  priceCents: number;\n  inventory: number; // available units\n  attributes?: Record<string, string>; // e.g. { color: 'red', size: 'M' }\n}\n\n/** E-commerce product */\nexport interface Product {\n  id: ID;\n  title: string;\n  description?: string;\n  priceCents: number;\n  currency: string; // ISO currency code e.g. 'USD'\n  images: string[];\n  variants?: ProductVariant[];\n  rating?: number; // aggregated rating 0-5\n  reviewCount?: number;\n  categories?: string[];\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n  createdAt: string; // ISO\n  updatedAt?: string;\n}\n\n/** Cart item referencing a product or variant */\nexport interface CartItem {\n  id: ID; // cart item id\n  productId: ID;\n  variantId?: ID;\n  quantity: number;\n  priceCents: number; // snapshot price\n  title: string; // snapshot title\n  image?: string;\n}\n\nexport interface Cart {\n  id: ID;\n  userId?: ID; // optional for guest carts\n  items: CartItem[];\n  subtotalCents: number;\n  currency: string;\n  updatedAt: string;\n}\n\n/** Order status enumeration */\nexport type OrderStatus =\n  | 'pending'\n  | 'processing'\n  | 'paid'\n  | 'shipped'\n  | 'delivered'\n  | 'cancelled'\n  | 'refunded';\n\nexport interface Order {\n  id: ID;\n  userId: ID;\n  items: CartItem[];\n  totalCents: number;\n  currency: string;\n  status: OrderStatus;\n  createdAt: string;\n  updatedAt?: string;\n  trackingNumber?: string;\n  shippingAddress?: {\n    name: string;\n    line1: string;\n    line2?: string;\n    city: string;\n    state?: string;\n    postalCode?: string;\n    country?: string;\n  };\n  metadata?: Record<string, unknown>;\n}\n\nexport interface Review {\n  id: ID;\n  productId: ID;\n  userId: ID;\n  rating: number; // 1-5\n  title?: string;\n  body?: string;\n  createdAt: string;\n}\n\n/** User and Auth types */\nexport type UserRole = 'buyer' | 'seller' | 'admin' | 'guest';\n\nexport interface User {\n  id: ID;\n  email: string;\n  fullName?: string;\n  avatarUrl?: string;\n  roles: UserRole[];\n  createdAt?: string;\n}\n\nexport interface AuthToken {\n  accessToken: string;\n  refreshToken?: string;\n  expiresAt?: string; // ISO\n}\n\n/** Generic pagination container */\nexport interface Paginated<T> {\n  items: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n  hasNext: boolean;\n}\n\n/** API response wrappers */\nexport interface ApiResult<T> {\n  ok: true;\n  data: T;\n}\n\nexport interface ApiError {\n  ok: false;\n  status: number;\n  message: string;\n  code?: string; // machine-readable\n  details?: Record<string, unknown>;\n}\n\n/** WebSocket event types used internally by the mock WS and socketService */\nexport type WsEventType =\n  | 'inventory.updated'\n  | 'price.updated'\n  | 'order.status.updated'\n  | 'review.created'\n  | 'ping';\n\nexport interface WsEvent<T = any> {\n  type: WsEventType;\n  payload: T;\n  timestamp: string;\n}\n\n// Example typed payloads\nexport interface InventoryUpdatedPayload {\n  productId: ID;\n  variantId?: ID;\n  inventory: number;\n}\n\nexport interface PriceUpdatedPayload {\n  productId: ID;\n  variantId?: ID;\n  priceCents: number;\n}\n\nexport interface OrderStatusUpdatedPayload {\n  orderId: ID;\n  status: OrderStatus;\n}\n\n/** UI state and helper types */\nexport type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\nexport interface FormState<T = Record<string, unknown>> {\n  values: T;\n  errors?: Partial<Record<keyof T, string>>;\n  touched?: Partial<Record<keyof T, boolean>>;\n  loading?: boolean;\n}\n\n/* -------------------------------------------------------------------------- */\n/* Optional: Healthcare models (included so kernel supports cross-domain types)\n   These are intentionally minimal but typed so parts of the app or plugins that\n   require healthcare domain models can import them from the same contract file.\n   They do not interfere with the ecommerce models. */\n\nexport interface Patient {\n  id: ID;\n  fullName: string;\n  dateOfBirth?: string;\n  email?: string;\n  phone?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface Doctor {\n  id: ID;\n  fullName: string;\n  specialty?: string;\n  email?: string;\n}\n\nexport interface Nurse {\n  id: ID;\n  fullName: string;\n  email?: string;\n}\n\nexport interface Appointment {\n  id: ID;\n  patientId: ID;\n  doctorId: ID;\n  startAt: string;\n  endAt?: string;\n  reason?: string;\n}\n\nexport interface MedicalRecord {\n  id: ID;\n  patientId: ID;\n  notes: string;\n  createdAt: string;\n}\n\nexport interface Prescription {\n  id: ID;\n  patientId: ID;\n  doctorId: ID;\n  medication: string;\n  dosage: string;\n  instructions?: string;\n}\n\nexport interface LabResult {\n  id: ID;\n  patientId: ID;\n  type: string;\n  result: string | Record<string, unknown>;\n  date: string;\n}\n\n/* -------------------------------------------------------------------------- */\n\nUsage patterns and integration points\n- Import domain types in services and hooks:\n  import { Product, Paginated } from '@/core/contracts';\n\n- Use ApiResult/ApiError for typed apiClient responses:\n  async function fetchProducts(): Promise<ApiResult<Paginated<Product>> | ApiError> { ... }\n\n- WebSocket event shapes are used in the mock websocket emitter and socketService:\n  import { WsEvent, InventoryUpdatedPayload } from '@/core/contracts';\n\n- UI components use LoadingState and FormState:\n  const [state, setState] = useState<FormState<{ email: string }>>({ values: { email: '' } });\n\nNotes\n- Keep this file focused on types only; no runtime values or side effects.\n- When adding fields, prefer optional fields for backwards compatibility."
    },
    {
      "file_path": "src/app/config.ts",
      "purpose": "Materialized runtime configuration for the app. Exports a typed APP_CONFIG containing build/runtime flags, computed booleans, feature toggles, and mock users/endpoints for development mode. All providers and services should import these values to decide behavior (e.g., startMockServer, use localStorage persistence, enable mock auth).",
      "exports": [
        "APP_CONFIG",
        "AppConfig",
        "isDev",
        "shouldUseMockData",
        "shouldUseLocalStoragePersistence",
        "DEV_MOCK_USERS",
        "DEV_MOCK_ENDPOINTS",
        "FEATURES"
      ],
      "content": "Purpose and design\n- Provide a single imported constant APP_CONFIG that materializes the original JSON config.\n- Expose computed flags so services don't need to duplicate logic (isDev, shouldUseMockData, etc.).\n- Provide typed mock users & mock endpoints only when mock data is enabled; otherwise exports are empty arrays for safety.\n\nTypes and the exported constant\n\nexport interface DevModeConfig {\n  enable_mock_data: boolean;\n  mock_auth_users: Array<{ email: string; password: string; role: 'seller' | 'buyer' | 'admin' }>;\n  mock_api_endpoints: string[];\n  disable_websocket_in_dev: boolean;\n  use_localstorage_persistence: boolean;\n}\n\nexport interface AppConfig {\n  app_type: string; // 'ecommerce'\n  framework: string;\n  target_framework: string;\n  styling_approach: string;\n  objective?: string;\n  features: string[]; // features array from the manifest\n  target_audience?: string;\n  output_dir?: string;\n  development_mode: DevModeConfig;\n  prompt_requirements?: string[];\n  evaluation_criteria?: string[];\n}\n\n// Materialized runtime configuration. This object is intentionally frozen to prevent accidental mutation.\nexport const APP_CONFIG: Readonly<AppConfig> = Object.freeze({\n  app_type: 'ecommerce',\n  framework: 'react',\n  target_framework: 'react',\n  styling_approach: 'tailwind',\n  objective: 'Modern E-commerce Platform',\n  features: [\n    'product catalog with filters',\n    'shopping cart functionality',\n    'payment integration UI',\n    'order tracking dashboard',\n    'wishlist management',\n    'product reviews and ratings',\n    'inventory status display'\n  ],\n  target_audience: 'Online Shoppers',\n  output_dir: './generated',\n  development_mode: {\n    enable_mock_data: true,\n    mock_auth_users: [\n      { email: 'seller@shop.com', password: 'seller123', role: 'seller' },\n      { email: 'buyer@customer.com', password: 'buyer123', role: 'buyer' },\n      { email: 'admin@shop.com', password: 'admin123', role: 'admin' }\n    ],\n    mock_api_endpoints: ['/api/products', '/api/cart', '/api/orders', '/api/payments', '/api/reviews'],\n    disable_websocket_in_dev: false,\n    use_localstorage_persistence: true\n  },\n  prompt_requirements: [],\n  evaluation_criteria: []\n});\n\n/* Computed flags and convenience exports */\nexport const isDev = process.env.NODE_ENV !== 'production';\nexport const shouldUseMockData = isDev && APP_CONFIG.development_mode.enable_mock_data === true;\nexport const shouldUseLocalStoragePersistence = isDev && !!APP_CONFIG.development_mode.use_localstorage_persistence;\n\n// Feature set for quick checks\nexport const FEATURES = new Set<string>(APP_CONFIG.features || []);\n\n// Export mock users/endpoints only when mocks are enabled, otherwise export empty lists (safe default)\nexport const DEV_MOCK_USERS = shouldUseMockData ? APP_CONFIG.development_mode.mock_auth_users : [] as typeof APP_CONFIG.development_mode.mock_auth_users;\nexport const DEV_MOCK_ENDPOINTS = shouldUseMockData ? APP_CONFIG.development_mode.mock_api_endpoints : [] as string[];\n\n// Example usage patterns\n// import { APP_CONFIG, shouldUseMockData, DEV_MOCK_USERS } from '@/app/config';\n// if (shouldUseMockData) startMockServer(DEV_MOCK_ENDPOINTS);\n\nNotes\n- This file is the canonical runtime config for the front-end. If a future build step injects environment-specific config, replace the literal object with a build-time generated one but keep the exports stable.\n- Consumers must not mutate APP_CONFIG. Use read-only checks like FEATURES.has('wishlist management')."
    },
    {
      "file_path": "src/core/events.ts",
      "purpose": "Typed, minimal event bus for decoupled pub/sub across the app. Used by mock websocket emitter, socketService, and any module that needs lightweight in-process events. Supports synchronous handlers and asynchronous handlers (returns a Promise that resolves after all handlers complete).",
      "exports": [
        "EventBus",
        "subscribe",
        "unsubscribe",
        "publish",
        "defaultEventBus",
        "AppEventMap",
        "AppEventKey"
      ],
      "content": "Design goals\n- Strongly typed: event names mapped to payload shapes\n- Support for on/off and once\n- Allow async handlers (handler may return Promise)\n- Singleton defaultEventBus for application modules\n\nTyped event map used by the application\nimport { ID, Product, Order, InventoryUpdatedPayload, PriceUpdatedPayload } from '@/core/contracts';\n\nexport type AppEventMap = {\n  'auth.login': { userId: ID };\n  'auth.logout': { userId?: ID };\n  'cart.updated': { cartId: ID; userId?: ID };\n  'product.created': { product: Product };\n  'product.updated': { product: Product };\n  'inventory.updated': InventoryUpdatedPayload;\n  'price.updated': PriceUpdatedPayload;\n  'order.status.updated': { orderId: ID; status: OrderStatus };\n  'toast.show': { message: string; level?: 'info' | 'success' | 'error' };\n  'ws.ping': { timestamp: string };\n};\n\nexport type AppEventKey = keyof AppEventMap;\n\n/** Handler type: payload matched to the event key */\nexport type EventHandler<K extends AppEventKey> = (payload: AppEventMap[K]) => void | Promise<void>;\n\n/** Internal handler record */\ntype HandlerRecord<K extends AppEventKey = AppEventKey> = {\n  handler: EventHandler<K> | ((payload: any) => any);\n  once?: boolean;\n};\n\n/** EventBus class */\nexport class EventBus {\n  private handlers: Map<string, HandlerRecord[]> = new Map();\n\n  /** Subscribe to an event. Returns an unsubscribe function. */\n  on<K extends AppEventKey>(event: K, handler: EventHandler<K>): () => void {\n    const key = String(event);\n    const list = this.handlers.get(key) ?? [];\n    list.push({ handler });\n    this.handlers.set(key, list);\n    return () => this.off(event, handler as any);\n  }\n\n  /** Subscribe once */\n  once<K extends AppEventKey>(event: K, handler: EventHandler<K>): () => void {\n    const key = String(event);\n    const list = this.handlers.get(key) ?? [];\n    list.push({ handler, once: true });\n    this.handlers.set(key, list);\n    return () => this.off(event, handler as any);\n  }\n\n  /** Unsubscribe a handler */\n  off<K extends AppEventKey>(event: K, handler?: EventHandler<K>): void {\n    const key = String(event);\n    const list = this.handlers.get(key);\n    if (!list) return;\n    if (!handler) {\n      this.handlers.delete(key);\n      return;\n    }\n    const filtered = list.filter(r => r.handler !== handler);\n    if (filtered.length === 0) this.handlers.delete(key);\n    else this.handlers.set(key, filtered);\n  }\n\n  /** Publish an event synchronously; handlers that return promises will be awaited if wait flag is true */\n  async emit<K extends AppEventKey>(event: K, payload: AppEventMap[K], options?: { wait?: boolean }): Promise<void> {\n    const key = String(event);\n    const list = this.handlers.get(key) ?? [];\n    if (list.length === 0) return;\n\n    // iterate over a shallow copy to allow modifications during iteration\n    const copy = [...list];\n    const results: Promise<void>[] = [];\n\n    for (const rec of copy) {\n      try {\n        const res = rec.handler(payload as any);\n        if (rec.once) {\n          // remove the handler\n          this.off(event, rec.handler as any);\n        }\n        if (options?.wait && res instanceof Promise) {\n          results.push(res.then(() => undefined));\n        }\n      } catch (err) {\n        // swallow to avoid breaking other handlers; optionally log\n        // consumers can subscribe to error events if desired\n        // For dev, console.error\n        if (process.env.NODE_ENV !== 'production') console.error('Event handler error for', event, err);\n      }\n    }\n\n    if (options?.wait && results.length > 0) {\n      await Promise.all(results);\n    }\n  }\n\n  /** Clear all handlers (useful in tests) */\n  clear(): void {\n    this.handlers.clear();\n  }\n}\n\n// Export a singleton default bus used across the app\nexport const defaultEventBus = new EventBus();\n\n/* Convenience helpers for common operations */\nexport const subscribe = <K extends AppEventKey>(event: K, handler: EventHandler<K>) => defaultEventBus.on(event, handler);\nexport const unsubscribe = <K extends AppEventKey>(event: K, handler?: EventHandler<K>) => defaultEventBus.off(event, handler as any);\nexport const publish = <K extends AppEventKey>(event: K, payload: AppEventMap[K], options?: { wait?: boolean }) => defaultEventBus.emit(event, payload, options);\n\n/* Usage examples\n\nimport { subscribe, publish } from '@/core/events';\nimport { defaultEventBus } from '@/core/events';\n\n// subscribe\nconst unsub = subscribe('cart.updated', (payload) => {\n  console.log('cart updated', payload);\n});\n\n// publish\npublish('cart.updated', { cartId: 'cart_1' });\n\n// async handlers\nsubscribe('order.status.updated', async ({ orderId, status }) => {\n  await someAsyncCleanup(orderId);\n});\n\n// tests can clear handlers\ndefaultEventBus.clear();\n\nNotes\n- Keep handlers fast. Use 'options.wait' when emitters must ensure async handlers complete (e.g., during graceful shutdown in tests).\n- The event map is the canonical list of cross-cutting event names. Extend it as needed when features require new global events."
    },
    {
      "file_path": "src/core/hooks.ts",
      "purpose": "A small, typed hook/extension registry for runtime extensibility. Allows modules to register hook callbacks for predefined hook points (beforeApiRequest, afterApiResponse, onLogin, onLogout, onRouteChange). Hook callbacks receive a context object and may return modifications or async results. The registry supports registering multiple handlers per hook and running them in sequence or in parallel depending on the hook contract.",
      "exports": [
        "HookKey",
        "HookContext",
        "HookHandler",
        "HookRegistry",
        "registerHook",
        "resolveHook"
      ],
      "content": "Goals\n- Provide a typed, centralized extension mechanism for small cross-cutting concerns (e.g., analytics, telemetry, request transforms, feature toggles).\n- Lightweight and synchronous-by-default; handlers may be async when needed.\n\nHook point names\nexport type HookKey =\n  | 'beforeApiRequest' // allows modifying request init or url\n  | 'afterApiResponse' // receives response or error and can modify/augment\n  | 'onLogin' // called when user logs in\n  | 'onLogout' // called on logout\n  | 'onRouteChange'; // receives pathname and params\n\n/** Context object passed to hooks; each hook can expect specific fields but keep it extendable */\nexport interface HookContext {\n  // for request hooks\n  url?: string;\n  init?: RequestInit;\n  // for response hooks\n  response?: unknown;\n  error?: unknown;\n  // for auth hooks\n  userId?: string;\n  user?: unknown;\n  // route hooks\n  pathname?: string;\n  params?: Record<string, string>;\n  // generic metadata\n  meta?: Record<string, unknown>;\n}\n\nexport type HookHandler<T extends HookKey = HookKey> = (ctx: HookContext) => void | Promise<void> | HookContext | Promise<HookContext>;\n\n/** Hook registry implementation */\nexport class HookRegistry {\n  private registry: Map<HookKey, HookHandler[]> = new Map();\n\n  register<T extends HookKey>(key: T, handler: HookHandler<T>): () => void {\n    const list = this.registry.get(key) ?? [];\n    list.push(handler as HookHandler);\n    this.registry.set(key, list);\n    return () => this.unregister(key, handler as HookHandler);\n  }\n\n  unregister<T extends HookKey>(key: T, handler?: HookHandler<T>): void {\n    const list = this.registry.get(key);\n    if (!list) return;\n    if (!handler) {\n      this.registry.delete(key);\n      return;\n    }\n    const filtered = list.filter(h => h !== handler);\n    if (filtered.length === 0) this.registry.delete(key);\n    else this.registry.set(key, filtered);\n  }\n\n  /** Run handlers sequentially, passing the context along. Each handler may mutate or return a context. */\n  async run<T extends HookKey>(key: T, ctx: HookContext): Promise<HookContext> {\n    const list = this.registry.get(key) ?? [];\n    let current = { ...ctx };\n    for (const handler of list) {\n      const result = await handler(current as HookContext);\n      if (result && typeof result === 'object') {\n        current = { ...current, ...result };\n      }\n    }\n    return current;\n  }\n\n  /** Run handlers in parallel and return aggregated contexts (useful for non-mutating hooks) */\n  async runParallel<T extends HookKey>(key: T, ctx: HookContext): Promise<HookContext[]> {\n    const list = this.registry.get(key) ?? [];\n    return Promise.all(list.map(h => Promise.resolve(h(ctx as HookContext)).then(r => (typeof r === 'object' ? r as HookContext : ctx))));\n  }\n\n  clear(): void {\n    this.registry.clear();\n  }\n}\n\n// Export a global registry instance that app modules can import and extend\nexport const globalHookRegistry = new HookRegistry();\n\n// Convenience functions\nexport const registerHook = <T extends HookKey>(key: T, handler: HookHandler<T>) => globalHookRegistry.register(key, handler);\nexport const resolveHook = <T extends HookKey>(key: T, ctx: HookContext) => globalHookRegistry.run(key, ctx);\n\n/* Standard hooks and patterns\n- beforeApiRequest: modify url/init (add headers, trace ids)\n  registerHook('beforeApiRequest', async (ctx) => {\n    // mutate ctx.init.headers\n  });\n- afterApiResponse: log or transform response; can attach telemetry\n- onLogin/onLogout: used by plugins to update analytics or clear caches\n- onRouteChange: used by analytics or feature flags to respond to navigation\n\nExample integration with apiClient (pseudocode):\n\nimport { registerHook, resolveHook } from '@/core/hooks';\n\nasync function apiFetch(url: string, init: RequestInit = {}) {\n  const ctx = await resolveHook('beforeApiRequest', { url, init });\n  const res = await fetch(ctx.url ?? url, ctx.init ?? init);\n  const data = await res.json().catch(() => null);\n  await resolveHook('afterApiResponse', { url: ctx.url, init: ctx.init, response: data });\n  return data;\n}\n\nNotes\n- Hooks are intentionally low-level; prefer idempotent handlers and avoid heavy side effects in runParallel unless you know handlers are independent.\n- Use unregister to remove plugin handlers in tests or dynamic plugin systems."
    },
    {
      "file_path": "src/core/di.ts",
      "purpose": "A lightweight dependency injection container to register and resolve services by tokens. Useful to provide test doubles in unit tests and to avoid hard imports in runtime wiring. Tokens are strongly typed symbols. Container supports singleton and transient registrations and enforces type safety using generics.",
      "exports": [
        "Token",
        "Container",
        "register",
        "resolve",
        "TOKENS",
        "ApiClientToken",
        "AuthServiceToken",
        "StorageServiceToken",
        "WebSocketServiceToken"
      ],
      "content": "Design goals\n- Small, predictable API for registering and resolving services\n- Type-safe tokens using unique symbols and generic typing\n- Support for factory registration, singleton caching, and transient factories\n\nToken helper\n\nexport type Token<T> = symbol & { __type?: T };\n\nexport function createToken<T = unknown>(desc: string): Token<T> {\n  return Symbol(desc) as Token<T>;\n}\n\n/** Registration kinds */\ntype Factory<T> = () => T | Promise<T>;\n\ntype Registration<T> =\n  | { type: 'value'; value: T }\n  | { type: 'factory'; factory: Factory<T>; singleton: boolean; cached?: T };\n\n/** Container implementation */\nexport class Container {\n  private registry = new Map<Token<any>, Registration<any>>();\n\n  registerValue<T>(token: Token<T>, value: T): void {\n    this.registry.set(token, { type: 'value', value });\n  }\n\n  registerFactory<T>(token: Token<T>, factory: Factory<T>, options?: { singleton?: boolean }): void {\n    this.registry.set(token, { type: 'factory', factory, singleton: !!options?.singleton });\n  }\n\n  resolve<T>(token: Token<T>): T {\n    const reg = this.registry.get(token) as Registration<T> | undefined;\n    if (!reg) throw new Error('Token not registered');\n    if (reg.type === 'value') return reg.value as T;\n    // factory\n    if (reg.type === 'factory') {\n      if (reg.singleton) {\n        if (reg.cached !== undefined) return reg.cached as T;\n        const val = reg.factory();\n        if (val instanceof Promise) throw new Error('Cannot resolve async factory as sync');\n        reg.cached = val as T;\n        return val as T;\n      }\n      const val = reg.factory();\n      if (val instanceof Promise) throw new Error('Cannot resolve async factory as sync');\n      return val as T;\n    }\n    throw new Error('Invalid registration');\n  }\n\n  async resolveAsync<T>(token: Token<T>): Promise<T> {\n    const reg = this.registry.get(token) as Registration<T> | undefined;\n    if (!reg) throw new Error('Token not registered');\n    if (reg.type === 'value') return reg.value as T;\n    if (reg.type === 'factory') {\n      if (reg.singleton) {\n        if (reg.cached !== undefined) return reg.cached as T;\n        const val = await reg.factory();\n        reg.cached = val as T;\n        return val as T;\n      }\n      const val = await reg.factory();\n      return val as T;\n    }\n    throw new Error('Invalid registration');\n  }\n\n  has(token: Token<any>): boolean {\n    return this.registry.has(token);\n  }\n\n  clear(): void {\n    this.registry.clear();\n  }\n}\n\n/* Export a default container instance used by the app. Tests can create independent Container instances when isolating behavior. */\nexport const defaultContainer = new Container();\n\n/* Convenience register/resolve functions using defaultContainer */\nexport const register = <T>(token: Token<T>, valueOrFactory: T | Factory<T>, options?: { singleton?: boolean; isFactory?: boolean }) => {\n  if (typeof valueOrFactory === 'function' && options?.isFactory) {\n    defaultContainer.registerFactory(token, valueOrFactory as Factory<T>, { singleton: options.singleton });\n  } else {\n    defaultContainer.registerValue(token, valueOrFactory as T);\n  }\n};\n\nexport const resolve = <T>(token: Token<T>): T => defaultContainer.resolve(token);\nexport const resolveAsync = <T>(token: Token<T>): Promise<T> => defaultContainer.resolveAsync(token);\n\n/* Predefined tokens for core services (examples) */\nexport const TOKENS = {\n  ApiClient: createToken('ApiClient'),\n  AuthService: createToken('AuthService'),\n  StorageService: createToken('StorageService'),\n  WebSocketService: createToken('WebSocketService')\n} as const;\n\nexport type ApiClientToken = typeof TOKENS.ApiClient;\nexport type AuthServiceToken = typeof TOKENS.AuthService;\nexport type StorageServiceToken = typeof TOKENS.StorageService;\nexport type WebSocketServiceToken = typeof TOKENS.WebSocketService;\n\n/* Example usage\n\n// register an API client instance\nimport { register, TOKENS } from '@/core/di';\nregister(TOKENS.ApiClient, apiClientInstance);\n\n// later in a service module\nimport { resolve, TOKENS } from '@/core/di';\nconst apiClient = resolve<TApiClient>(TOKENS.ApiClient);\n\n// For factories and singletons\nregister(TOKENS.AuthService, () => new AuthService(), { isFactory: true, singleton: true });\n\nNotes\n- Avoid circular dependencies by registering only at app startup (e.g., App.tsx) and resolving inside functions/modules, not at top-level import time when possible.\n- Tests should either clear defaultContainer or create a new Container instance for isolation."
    },
    {
      "file_path": "src/core/utils.ts",
      "purpose": "Small set of safe utilities used across kernel modules: deep clone (structuredClone fallback), noop, environment checks, sleep/delay, safe JSON parse/stringify, basic date formatting, and debug logging controlled by NODE_ENV.",
      "exports": [
        "deepClone",
        "noop",
        "isServer",
        "sleep",
        "safeJsonParse",
        "safeJsonStringify",
        "formatDateISO",
        "debugLog",
        "validateEmail"
      ],
      "content": "Design goals\n- Provide tiny, dependency-free helpers that are safe in both browser and Node-like environments.\n- Avoid heavy third-party libraries in kernel; higher-level modules can import more advanced utils from /utils if needed.\n\nUtilities\n\n/** deepClone - uses structuredClone when available, otherwise falls back to JSON-based clone (loses functions and Dates) */\nexport function deepClone<T>(obj: T): T {\n  if (typeof (globalThis as any).structuredClone === 'function') {\n    return (globalThis as any).structuredClone(obj) as T;\n  }\n  return JSON.parse(JSON.stringify(obj)) as T;\n}\n\n/** noop - typed no-op function */\nexport const noop = (..._args: any[]) => undefined;\n\n/** isServer - runtime check for SSR or node environment */\nexport const isServer = typeof window === 'undefined';\n\n/** sleep/delay - async delay helper */\nexport const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n/** safeJsonParse - returns undefined on failure (prevents throw in many callsites) */\nexport function safeJsonParse<T = unknown>(input: string | undefined | null): T | undefined {\n  if (input == null) return undefined;\n  try {\n    return JSON.parse(input) as T;\n  } catch {\n    return undefined;\n  }\n}\n\n/** safeJsonStringify - returns string or undefined if fails */\nexport function safeJsonStringify(input: unknown): string | undefined {\n  try {\n    return JSON.stringify(input);\n  } catch {\n    return undefined;\n  }\n}\n\n/** formatDateISO - friendly formatting of ISO strings; falls back to toString */\nexport function formatDateISO(iso: string | undefined, locale = 'en-US', options?: Intl.DateTimeFormatOptions): string {\n  if (!iso) return '';\n  try {\n    const d = new Date(iso);\n    return new Intl.DateTimeFormat(locale, options ?? { year: 'numeric', month: 'short', day: 'numeric' }).format(d);\n  } catch {\n    return String(iso);\n  }\n}\n\n/** debugLog - logs only in non-production */\nexport function debugLog(...args: any[]) {\n  if (process.env.NODE_ENV !== 'production') console.debug('[debug]', ...args);\n}\n\n/** validateEmail - small RFC-lite email check for forms */\nexport function validateEmail(email?: string): boolean {\n  if (!email) return false;\n  // simple regex: not exhaustive but practical for UI validation\n  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n}\n\n/* Usage examples\n\nimport { deepClone, sleep, safeJsonParse, debugLog } from '@/core/utils';\n\nconst copy = deepClone(someObject);\nawait sleep(200);\nconst parsed = safeJsonParse<MyType>(maybeJson);\ndebugLog('parsed', parsed);\n\nNotes\n- Keep these helpers intentionally small. Add additional helpers here only if they are generic and used across many modules. Otherwise add feature-scoped utilities under src/utils/.\n- deepClone uses structuredClone when available to preserve Dates/Maps in supporting runtimes."
    }
  ],
  "usage_guidelines": [
    "Import types from '@/core/contracts' in services, hooks and components to ensure a single source of truth.",
    "Use APP_CONFIG from '@/app/config' to gate development-only features like the mock server and mock auth.",
    "Use defaultEventBus from '@/core/events' for cross-module pub/sub and prefer specific typed event names from AppEventMap.",
    "Register lightweight extensions with registerHook from '@/core/hooks' rather than hard-wiring behavior into services; resolveHook is used to run them.",
    "Register and resolve core runtime services via the DI container '@/core/di' (TOKENS.ApiClient, TOKENS.AuthService etc.) to enable test doubles in unit tests.",
    "Use utilities in '@/core/utils' for safe JSON handling, small date formatting, and debug logging; keep heavy helpers out of the kernel.",
    "Keep all kernel modules side-effect free at import time as much as possible. Start mock server or register DI factories during application bootstrap (main.tsx / App.tsx)."
  ]
}