{
  "overview": "The core kernel provides a single source of truth for domain contracts, runtime configuration, an in-process typed event bus, an extensible hook registry, a small dependency-injection container, and shared utilities. All application sections (providers, services, hooks, pages, components) import types/contracts and utilities from the kernel to ensure consistent types, predictable runtime configuration and clear extension points. Use @/core/* imports in application code to access these definitions.",
  "files": [
    {
      "file_path": "src/core/contracts.ts",
      "purpose": "Domain TypeScript types and shared API contracts used across the app. This file defines the canonical domain model (users and healthcare objects), API response envelopes, WebSocket event types, and small UI helper types.",
      "exports": [
        "Role",
        "User",
        "Patient",
        "Doctor",
        "Nurse",
        "Appointment",
        "MedicalRecord",
        "Prescription",
        "LabResult",
        "ApiResult",
        "ApiError",
        "PaginatedResponse",
        "WebSocketEvent",
        "LoadingState",
        "FormState"
      ],
      "content": "Summary\n- Purpose: provide canonical domain interfaces so services, components and tests share the same shapes.\n- Conventions: all ids are strings (UUIDs). Dates are ISO strings (string) in DTOs and Date in internal helpers when appropriate. Optional fields are marked with ?.\n\nTypes & interfaces to define (explicit signatures)\n\n1) Role and User types\n- export type Role = 'patient' | 'doctor' | 'nurse' | 'admin';\n\n- export interface User {\n    id: string; // uuid\n    email: string;\n    firstName: string;\n    lastName: string;\n    role: Role;\n    avatarUrl?: string;\n    createdAt: string; // ISO date string\n    updatedAt?: string;\n  }\n\n- export interface Patient extends User {\n    role: 'patient';\n    dateOfBirth?: string; // ISO\n    medicalRecordId?: string;\n    emergencyContact?: { name: string; phone?: string };\n  }\n\n- export interface Doctor extends User {\n    role: 'doctor';\n    specialties: string[];\n    licenseNumber?: string;\n    clinicId?: string;\n  }\n\n- export interface Nurse extends User {\n    role: 'nurse';\n    unit?: string;\n  }\n\n2) Healthcare domain models\n- export interface Appointment {\n    id: string;\n    patientId: string;\n    providerId: string; // doctor or nurse id\n    scheduledAt: string; // ISO\n    durationMinutes?: number;\n    status: 'scheduled' | 'cancelled' | 'completed' | 'no_show';\n    notes?: string;\n    createdAt: string;\n  }\n\n- export interface MedicalRecord {\n    id: string;\n    patientId: string;\n    summary?: string;\n    allergies?: string[];\n    conditions?: string[];\n    medications?: string[];\n    updatedAt?: string;\n  }\n\n- export interface Prescription {\n    id: string;\n    recordId?: string;\n    patientId: string;\n    providerId: string;\n    drugName: string;\n    dose: string;\n    frequency: string;\n    instructions?: string;\n    issuedAt: string;\n    expiresAt?: string;\n  }\n\n- export interface LabResult {\n    id: string;\n    patientId: string;\n    testName: string;\n    result: string;\n    units?: string;\n    normalRange?: string;\n    collectedAt?: string;\n    reportedAt?: string;\n  }\n\n3) API response envelopes\n- export interface ApiResult<T = unknown> {\n    success: boolean;\n    data?: T;\n    error?: ApiError;\n  }\n\n- export interface ApiError {\n    code: string; // machine code e.g. 'AUTH_INVALID'\n    message: string; // human readable\n    status?: number; // http status if available\n    details?: Record<string, unknown>;\n  }\n\n- export interface PaginatedResponse<T> {\n    items: T[];\n    total: number;\n    page: number;\n    pageSize: number;\n  }\n\n4) WebSocket events (typed)\n- WebSocket is enabled by default in this kernel. If your runtime disables websockets update references in src/app/config.ts.\n\n- export type WebSocketEvent =\n    | { type: 'appointment.created'; payload: Appointment }\n    | { type: 'appointment.updated'; payload: Appointment }\n    | { type: 'user.updated'; payload: Partial<User> & { id: string } }\n    | { type: 'lab.result'; payload: LabResult }\n    | { type: 'prescription.issued'; payload: Prescription };\n\n5) UI helper types\n- export type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\n- export interface FormState<T = any> {\n    values: Partial<T>;\n    errors: Record<string, string>;\n    touched: Record<string, boolean>;\n    isSubmitting: boolean;\n  }\n\nPatterns and conventions\n- All domain models use ISO strings for date/time. Convert to Date at the boundaries (components/services) as needed with utilities in src/core/utils.ts.\n- Use ApiResult<T> for service responses; convert or throw in apiClient for simpler handling in services.\n\nExample usage patterns\n- import { User, Appointment, ApiResult } from '@/core/contracts';\n- const res: ApiResult<Appointment> = await appointmentService.create(...);\n\nIntegration points with other kernel files\n- src/services/apiClient.ts should return ApiResult<T> or throw HttpError; map backend shape to ApiResult.\n- src/core/events.ts uses Appointment and WebSocketEvent types to produce typed events.\n- src/core/hooks.ts uses these models in hook contexts (e.g., onLogin hook receives User)."
    },
    {
      "file_path": "src/app/config.ts",
      "purpose": "Materialized application configuration. Exports typed runtime configuration, computed flags and feature helpers. Provides small, deterministic mock data when development mode enables mock data.",
      "exports": [
        "APP_CONFIG",
        "API_BASE_URL",
        "APP_NAME",
        "ENV",
        "isDevelopment",
        "shouldUseMockData",
        "hasFeature",
        "MOCK_USERS"
      ],
      "content": "Summary\n- Purpose: provide a single typed config object that the whole app reads from. Avoid sprinkling process.env checks across the codebase.\n- Conventions: keep the config immutable; computed flags are pure functions of the raw config. Feature keys are strings and accessed via hasFeature(key).\n\nTyped shape\n- export type Environment = 'development' | 'production' | 'test';\n\n- export interface AppConfig {\n    env: Environment;\n    apiBaseUrl: string;\n    appName: string;\n    version?: string;\n    features: string[]; // feature flag names\n    developmentMode: {\n      enableMockData: boolean;\n      verboseLogging: boolean;\n    };\n    websocket: {\n      enabled: boolean;\n      url?: string;\n    };\n  }\n\nMaterialized config (example materialization)\n- The file materializes a concrete APP_CONFIG constant. This value is the canonical runtime configuration the rest of the application uses. You may alter values before building for different environments.\n\nExample APP_CONFIG content (complete and deterministic):\n\nexport const APP_CONFIG: AppConfig = {\n  env: (process.env.NODE_ENV as Environment) || 'development',\n  apiBaseUrl: process.env.REACT_APP_API_BASE_URL || 'https://api.example-health.local/v1',\n  appName: 'DiPeO Health',\n  version: process.env.REACT_APP_VERSION || '0.0.1',\n  features: [\n    'telemedicine',\n    'lab_results',\n    'prescriptions',\n    'patient_portal'\n  ],\n  developmentMode: {\n    enableMockData: (process.env.REACT_APP_ENABLE_MOCKS === 'true') || true,\n    verboseLogging: (process.env.REACT_APP_VERBOSE_LOGGING === 'true') || false\n  },\n  websocket: {\n    enabled: true,\n    url: process.env.REACT_APP_WS_URL || 'wss://ws.example-health.local'\n  }\n};\n\nComputed flags & helpers\n- export const ENV = APP_CONFIG.env;\n- export const API_BASE_URL = APP_CONFIG.apiBaseUrl;\n- export const APP_NAME = APP_CONFIG.appName;\n- export const isDevelopment = APP_CONFIG.env === 'development';\n- export const shouldUseMockData = isDevelopment && APP_CONFIG.developmentMode.enableMockData;\n\n- export function hasFeature(name: string): boolean {\n    return APP_CONFIG.features.includes(name);\n  }\n\nMock data (only included when shouldUseMockData === true)\n- Provide a small deterministic MOCK_USERS array so the app can run in dev without a backend. The array is exported only for developer consumption.\n\n- export const MOCK_USERS = shouldUseMockData ? [\n    {\n      id: 'mock-patient-1',\n      email: 'jane.patient@example.test',\n      firstName: 'Jane',\n      lastName: 'Patient',\n      role: 'patient',\n      avatarUrl: undefined,\n      createdAt: new Date().toISOString()\n    },\n    {\n      id: 'mock-doctor-1',\n      email: 'dr.smith@example.test',\n      firstName: 'John',\n      lastName: 'Smith',\n      role: 'doctor',\n      specialties: ['cardiology'],\n      createdAt: new Date().toISOString()\n    }\n  ] : [];\n\nPatterns and conventions\n- Always import configuration values from this module: import { API_BASE_URL } from '@/app/config'. Do not read process.env directly elsewhere.\n- Feature toggles: use hasFeature('lab_results') to guard UI and service behavior.\n\nIntegration points\n- src/services/apiClient.ts uses API_BASE_URL and websocket.url from this file.\n- src/core/events.ts and src/core/hooks.ts can check shouldUseMockData to alter behavior in development.\n- Providers and storybooks can import MOCK_USERS to bootstrap dev sessions."
    },
    {
      "file_path": "src/core/events.ts",
      "purpose": "A small, typed in-process event bus for cross-cutting domain events. Provides synchronous and asynchronous handler support, safe subscribe/unsubscribe, and a singleton instance to be used across the app.",
      "exports": [
        "EventMap",
        "EventHandler",
        "EventBus",
        "eventBus",
        "subscribe",
        "unsubscribe",
        "publish"
      ],
      "content": "Summary\n- Purpose: allow decoupled communication (e.g., AuthProvider emits 'auth:login' and many parts of the app react).\n- Conventions: events are typed via EventMap. Handlers can be sync or return Promise<void>. publish will await async handlers unless publishAsync is explicitly false.\n\nEvent types\n- export interface EventMap {\n    'auth:login': { userId: string; user?: import('@/core/contracts').User };\n    'auth:logout': { userId?: string };\n    'appointment:created': { appointment: import('@/core/contracts').Appointment };\n    'appointment:updated': { appointment: import('@/core/contracts').Appointment };\n    'user:updated': { userId: string; changes: Partial<import('@/core/contracts').User> };\n    'ws:message': { event: import('@/core/contracts').WebSocketEvent };\n  }\n\nAPI and class\n- export type EventHandler<E> = (payload: E) => void | Promise<void>;\n\n- export class EventBus {\n    // internal map: event name -> Set of handlers\n    private handlers = new Map<string, Set<EventHandler<any>>>();\n\n    public on<K extends keyof EventMap>(event: K, handler: EventHandler<EventMap[K]>): () => void {\n      // returns an unsubscribe function\n    }\n\n    public off<K extends keyof EventMap>(event: K, handler: EventHandler<EventMap[K]>): boolean {\n      // returns whether handler was removed\n    }\n\n    public async emit<K extends keyof EventMap>(event: K, payload: EventMap[K], options?: { awaitHandlers?: boolean }): Promise<void> {\n      // if awaitHandlers !== false await all handlers, otherwise fire-and-forget\n    }\n\n    public clear(): void {\n      // remove all handlers (used in tests)\n    }\n  }\n\nImplementation notes (what should be implemented)\n- on(event, handler) registers handler and returns a function that when called removes the handler.\n- off(event, handler) removes a handler; returns true when removed.\n- emit(event, payload, options) iterates over a snapshot of handlers to avoid issues when handlers unregister themselves, calls each handler; when awaitHandlers is true (default) await Promise.all for handlers that return promises but preserve handler execution order for easier debugging (call and collect results in order).\n- clear() is useful for unit tests to reset the bus.\n\nSingleton & convenience functions\n- export const eventBus = new EventBus();\n- export const subscribe = <K extends keyof EventMap>(event: K, handler: EventHandler<EventMap[K]>) => eventBus.on(event, handler);\n- export const unsubscribe = <K extends keyof EventMap>(event: K, handler: EventHandler<EventMap[K]>) => eventBus.off(event, handler);\n- export const publish = <K extends keyof EventMap>(event: K, payload: EventMap[K], options?: { awaitHandlers?: boolean }) => eventBus.emit(event, payload, options);\n\nExample usage\n- import { publish, subscribe } from '@/core/events';\n- const off = subscribe('auth:login', async ({ userId, user }) => { console.log('user logged in', userId); });\n- publish('auth:login', { userId: 'u1' });\n- off();\n\nIntegration points\n- AuthProvider should publish 'auth:login' and 'auth:logout'.\n- WebSocketService publishes 'ws:message' when receiving messages and EventBus handles broadcasting to interested components/services.\n- Tests may call eventBus.clear() between test cases."
    },
    {
      "file_path": "src/core/hooks.ts",
      "purpose": "Lightweight hook registry for extension points. Plugins and features can register handlers for lifecycle events such as beforeApiRequest or onLogin. Hooks are typed and run in a controlled context. The registry is intentionally small and synchronous/async-friendly.",
      "exports": [
        "HookPoint",
        "HookContext",
        "HookHandler",
        "HookRegistry",
        "hooks"
      ],
      "content": "Summary\n- Purpose: provide clear extension points used by apiClient, auth flows and routing. Hooks allow modifications to API requests, side-effects after responses, and lifecycle hooks on login/logout or route changes.\n- Conventions: hooks are registered by name; a register call returns an unregister function. Handlers can be async and return values which the registry collates when appropriate.\n\nHook names (HookPoint union)\n- export type HookPoint =\n    | 'beforeApiRequest'\n    | 'afterApiResponse'\n    | 'onLogin'\n    | 'onLogout'\n    | 'onRouteChange';\n\nHook context shape\n- export interface HookContext {\n    // for API hooks\n    request?: {\n      url: string;\n      method?: string;\n      headers?: Record<string,string>;\n      body?: unknown;\n    };\n    response?: {\n      status?: number;\n      body?: unknown;\n      raw?: Response;\n    };\n    // auth & user context\n    user?: import('@/core/contracts').User | null;\n    // route context for onRouteChange\n    route?: {\n      from?: string;\n      to: string;\n      params?: Record<string,string>;\n    };\n    // arbitrary metadata used by plugins\n    meta?: Record<string, any>;\n  }\n\n- export type HookHandler<T extends HookPoint = HookPoint, R = unknown> = (ctx: HookContext) => R | Promise<R>;\n\nRegistry API\n- export class HookRegistry {\n    // register a handler for a specific HookPoint\n    public register<K extends HookPoint>(hook: K, handler: HookHandler<K>): () => void {\n      // returns an unregister function\n    }\n\n    // run handlers for a hook; returns results in order\n    public async run<K extends HookPoint, R = unknown>(hook: K, ctx: HookContext): Promise<R[]> {\n      // call handlers sequentially or in parallel depending on hook; default: sequential to allow mutation of ctx\n    }\n\n    // clear all handlers (useful for tests)\n    public clear(): void {}\n  }\n\nPre-registered standard hooks\n- beforeApiRequest: runs before each API request; handlers can modify ctx.request (headers, body) to add authentication tokens or tracing headers.\n- afterApiResponse: runs after successful or error responses; handlers receive ctx.response and can transform or record metrics.\n- onLogin: runs after a successful login with ctx.user present.\n- onLogout: runs after logout.\n- onRouteChange: runs when the router notifies a route change; can block or redirect by setting ctx.meta.redirect.\n\nSingleton & usage\n- export const hooks = new HookRegistry();\n\nExample usage\n- Register a hook:\n  import { hooks } from '@/core/hooks';\n  const unregister = hooks.register('beforeApiRequest', (ctx) => {\n    // add auth header\n    if (!ctx.request) return;\n    ctx.request.headers = { ...(ctx.request.headers || {}), 'x-app-version': '0.0.1' };\n  });\n\n- Running hooks inside apiClient:\n  await hooks.run('beforeApiRequest', { request });\n  const response = await fetch(...);\n  await hooks.run('afterApiResponse', { request, response: { raw: response } });\n\nIntegration points\n- src/services/apiClient.ts should call hooks.run('beforeApiRequest', ctx) before sending requests and hooks.run('afterApiResponse', ctx) after receiving responses.\n- AuthProvider should call hooks.run('onLogin', { user }) and hooks.run('onLogout', { user: null }).\n- Router can call hooks.run('onRouteChange', { route: { from, to } }) on navigation changes.\n\nTesting and mockability\n- HookRegistry.clear() should be used in tests to reset global state between runs."
    },
    {
      "file_path": "src/core/di.ts",
      "purpose": "A minimal TypeScript-friendly dependency injection container for registering and resolving service implementations. Uses symbol-based tokens for type safety and easy overrides in tests.",
      "exports": [
        "Token",
        "createToken",
        "DIContainer",
        "defaultContainer",
        "register",
        "resolve",
        "API_CLIENT_TOKEN",
        "AUTH_SERVICE_TOKEN",
        "STORAGE_SERVICE_TOKEN",
        "WEBSOCKET_SERVICE_TOKEN"
      ],
      "content": "Summary\n- Purpose: allow swapping implementations (e.g., mock services in tests) without coupling all imports to concrete modules. The container supports singleton lifetimes and transient factories.\n- Conventions: tokens are created by createToken<T>('Name') and used to register a value or factory. resolve<T>(token) returns the registered instance or throws when missing unless an optional default is provided.\n\nToken type and creator\n- export interface Token<T> { readonly key: symbol; readonly name: string; }\n- export function createToken<T>(name: string): Token<T> {\n    return { key: Symbol(name), name } as Token<T>;\n  }\n\nContainer signatures\n- export type Factory<T> = (c: DIContainer) => T | Promise<T>;\n\n- export class DIContainer {\n    register<T>(token: Token<T>, implementation: T | Factory<T>, options?: { singleton?: boolean }): void;\n    resolve<T>(token: Token<T>): T;\n    has(token: Token<any>): boolean;\n    clear(): void; // remove all registrations\n  }\n\nImplementation notes\n- Internally keep a Map<Token.key, { impl, singleton, instance? }>\n- When register receives a Factory and singleton=true, call it lazily on first resolve and cache result.\n- When resolve cannot find a registration, throw a helpful error listing the missing token name.\n\nDefault container & convenience functions\n- export const defaultContainer = new DIContainer();\n- export const register = defaultContainer.register.bind(defaultContainer);\n- export const resolve = defaultContainer.resolve.bind(defaultContainer);\n\nCommon tokens (examples used across the app)\n- export const API_CLIENT_TOKEN = createToken<{ request<T>(...args: any[]): Promise<T> }>('ApiClient');\n- export const AUTH_SERVICE_TOKEN = createToken<{ login(...args: any[]): Promise<any>; logout(): Promise<void> }>('AuthService');\n- export const STORAGE_SERVICE_TOKEN = createToken<Storage>('StorageService');\n- export const WEBSOCKET_SERVICE_TOKEN = createToken<{ connect(): void; disconnect(): void }>('WebSocketService');\n\nExample usage\n- Register API client at app boot (main.tsx or provider composition):\n  import { register } from '@/core/di';\n  import { API_CLIENT_TOKEN } from '@/core/di';\n  register(API_CLIENT_TOKEN, apiClientInstance, { singleton: true });\n\n- Resolve inside a service or module (prefer constructor injection where possible):\n  import { resolve } from '@/core/di';\n  const api = resolve(API_CLIENT_TOKEN);\n\nIntegration points\n- QueryProvider or service initialization should register implementations for API_CLIENT_TOKEN and WEBSOCKET_SERVICE_TOKEN.\n- In tests, call defaultContainer.clear() then register() mock implementations to control behavior.\n\nType-safety\n- The container API uses Token<T> so resolve returns T, preserving compile-time typing across registrations and resolutions."
    },
    {
      "file_path": "src/core/utils.ts",
      "purpose": "Common utilities used across the application: date formatting, safe JSON parsing, URL builder, className helper and small debug helpers. Keep these small and dependency-free for use in both browser and test environments.",
      "exports": [
        "formatDate",
        "formatDateTime",
        "safeParseJson",
        "safeStringify",
        "buildUrl",
        "noop",
        "classNames",
        "assert"
      ],
      "content": "Summary\n- Purpose: lightweight utility helpers used by components, services and tests.\n- Conventions: functions are pure and have narrow responsibilities. Prefer small, well-documented helpers rather than large utility libraries.\n\nFunctions to implement (signatures & behavior)\n\n1) formatDate\n- export function formatDate(isoOrDate: string | Date, locale = 'en-US'): string;\n- Description: returns a short date (e.g., \"Jan 10, 2024\") while handling invalid input gracefully by returning '' (empty string).\n\n2) formatDateTime\n- export function formatDateTime(isoOrDate: string | Date, locale = 'en-US'): string;\n- Description: returns a localized date + time string.\n\n3) safeParseJson\n- export function safeParseJson<T = any>(input: string, fallback?: T): T;\n- Description: parses JSON and returns fallback on parse error.\n\n4) safeStringify\n- export function safeStringify(obj: unknown): string;\n- Description: Safe stringify that handles cyclic structures by replacing cycles with '[Circular]'.\n\n5) buildUrl\n- export function buildUrl(base: string, path?: string, params?: Record<string, string | number | boolean | undefined>): string;\n- Description: join base + path and append query string from params. Skip undefined values.\n\n6) noop\n- export const noop = (): void => {};\n\n7) classNames\n- export function classNames(...parts: Array<string | false | null | undefined | Record<string, boolean>>): string;\n- Description: small helper to join class names (handles object maps and booleans).\n\n8) assert\n- export function assert(condition: any, message?: string): asserts condition;\n- Description: throw Error when condition falsy; useful to narrow types in code paths.\n\nExamples & usage\n- import { formatDate, buildUrl } from '@/core/utils';\n- buildUrl(API_BASE_URL, '/appointments', { page: 1, pageSize: 20 });\n- safeParseJson<{ id: string }>(maybeJson, { id: 'unknown' });\n\nIntegration points\n- Use formatDate in UI components (shared components and pages).\n- Use buildUrl in apiClient to create request URLs safely.\n- safeParseJson used in places where backend responses may be malformed (local caches, localStorage).\n\nTesting\n- Each function is pure and trivial to unit test with typical inputs and edge cases (invalid ISO strings, null/undefined params, cyclic objects for safeStringify).\n\nImplementation notes\n- Keep dependencies minimal (no external libraries). Use URL and URLSearchParams where available for robust query building."
    }
  ],
  "usage_guidelines": [
    "Import domain types from @/core/contracts to ensure consistent shapes throughout services, providers and components.",
    "Read runtime config only from @/app/config: API_BASE_URL, hasFeature('x'), shouldUseMockData. Do not use process.env directly elsewhere.",
    "Use the singleton event bus (import { publish, subscribe } from '@/core/events') for decoupled cross-cutting notifications. Remember to unsubscribe in effects or component cleanup.",
    "Register cross-cutting behaviors using the HookRegistry (import { hooks } from '@/core/hooks'). apiClient should call beforeApiRequest/afterApiResponse hooks.",
    "Register service implementations at app bootstrap using DI tokens (import { register, API_CLIENT_TOKEN } from '@/core/di') and resolve them in services or tests.",
    "Use utilities from @/core/utils for date formatting, safe JSON parsing and building URLs; keep UI components free of ad-hoc logic.",
    "When writing tests, clear global state: call eventBus.clear(), hooks.clear(), and defaultContainer.clear() to isolate state between test cases."
  ]
}