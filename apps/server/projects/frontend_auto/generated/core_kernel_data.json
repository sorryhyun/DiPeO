{
  "overview": "The Core Kernel provides a small, highly-focused foundation used by every feature and provider in the app. It contains the single source of truth for domain types and API contracts (core/contracts.ts), materialized runtime configuration (app/config.ts), a typed event bus for decoupled communication (core/events.ts), a hook registry for extension points (core/hooks.ts), a small DI container for swapping implementations in tests/dev (core/di.ts), and compact safe utilities used by kernel-level code (core/utils.ts). All other modules import contracts, events, hooks and DI tokens from this kernel. Keep the kernel deliberately minimal, well-typed and side-effect free so it can be imported anywhere (including mocks and node-based tooling).",
  "files": [
    {
      "file_path": "core/contracts.ts",
      "purpose": "Domain types, API request/response contracts and shared interfaces used across the entire application (appointments, records, prescriptions, lab results, user and auth types, WebSocket events, form/loading states).",
      "exports": [
        "User",
        "AuthToken",
        "Role",
        "Appointment",
        "MedicalRecord",
        "Prescription",
        "LabResult",
        "InsuranceClaim",
        "Medication",
        "ApiResult",
        "ApiError",
        "PaginatedResponse",
        "WebSocketEvent",
        "LoadingState",
        "FormState",
        "Nullable"
      ],
      "content": "Summary\n- Purpose: provide a lightweight, fully-typed contract layer that every file imports from (avoid importing services/providers here). Keep only pure types and small helper types.\n\nType design principles\n- Use discriminated unions where appropriate (e.g., role: 'patient' | 'doctor' | 'nurse').\n- Keep fields optional only when truly optional across API responses.\n- Prefer ISO 8601 strings for dates in API payloads (backend-agnostic).\n- Provide generic ApiResult<T> and ApiError to standardize error handling.\n\nRequired types\n1) Basic primitives and helpers\n- export type Nullable<T> = T | null;\n\n2) Roles and Auth token\n- export type Role = 'patient' | 'doctor' | 'nurse' | 'admin';\n\n- export interface AuthToken {\n-   accessToken: string; // JWT or opaque token\n-   refreshToken?: string;\n-   expiresAt?: string; // ISO date-time when token expires\n- }\n\n3) User types\n- export interface UserBase {\n-   id: string;\n-   email: string;\n-   fullName: string;\n-   avatarUrl?: string;\n-   role: Role;\n- }\n-\n- export interface Patient extends UserBase {\n-   role: 'patient';\n-   dateOfBirth?: string; // ISO\n-   medicalRecordNumber?: string;\n- }\n-\n- export interface Doctor extends UserBase {\n-   role: 'doctor';\n-   specialty?: string;\n-   licenseId?: string;\n- }\n-\n- export interface Nurse extends UserBase {\n-   role: 'nurse';\n-   department?: string;\n- }\n-\n- export type User = Patient | Doctor | Nurse | UserBase;\n\n4) Domain models (keep minimal fields required by UI)\n- Appointment\n  - id, patientId, providerId, startAt, endAt, status, type, location, notes\n  - status: 'scheduled' | 'confirmed' | 'cancelled' | 'completed' | 'no_show'\n  - type: 'telemedicine' | 'in_person' | 'phone'\n\n- MedicalRecord\n  - id, patientId, title, summary, recordedAt, attachments?: string[]\n\n- Prescription\n  - id, patientId, prescribedBy (doctor id), medicationId, dosage, frequency, startAt, endAt, status\n  - status: 'active' | 'expired' | 'cancelled' | 'refill_requested'\n\n- LabResult\n  - id, patientId, testName, value, unit, referenceRange?, collectedAt, status\n  - status: 'preliminary' | 'final' | 'amended'\n\n- InsuranceClaim\n  - id, patientId, providerId, amount, currency, submittedAt, status\n  - status: 'pending' | 'approved' | 'denied' | 'in_review'\n\n- Medication\n  - id, name, form, strength, instructions, nextReminderAt?\n\nExample Type Declarations (pseudo-TS inside content)\nexport interface Appointment {\n  id: string;\n  patientId: string;\n  providerId: string;\n  startAt: string; // ISO\n  endAt?: string; // ISO\n  status: 'scheduled' | 'confirmed' | 'cancelled' | 'completed' | 'no_show';\n  type: 'telemedicine' | 'in_person' | 'phone';\n  location?: string;\n  notes?: string;\n}\n\nexport interface MedicalRecord {\n  id: string;\n  patientId: string;\n  title: string;\n  summary: string;\n  recordedAt: string; // ISO\n  attachments?: Array<{ url: string; name?: string; mime?: string }>;\n}\n\nexport interface Prescription {\n  id: string;\n  patientId: string;\n  prescribedBy: string; // doctor id\n  medicationId: string;\n  dosage: string; // human readable: '5 mg'\n  frequency: string; // 'twice daily'\n  startAt?: string;\n  endAt?: string;\n  status: 'active' | 'expired' | 'cancelled' | 'refill_requested';\n}\n\nexport interface LabResult {\n  id: string;\n  patientId: string;\n  testName: string;\n  value: number | string;\n  unit?: string;\n  referenceRange?: string;\n  collectedAt: string; // ISO\n  status: 'preliminary' | 'final' | 'amended';\n  flags?: 'low' | 'high' | 'normal';\n}\n\nexport interface InsuranceClaim {\n  id: string;\n  patientId: string;\n  providerId?: string;\n  amount: number;\n  currency: string;\n  submittedAt?: string;\n  status: 'pending' | 'approved' | 'denied' | 'in_review';\n}\n\nexport interface Medication {\n  id: string;\n  name: string;\n  form?: string; // tablet, liquid\n  strength?: string; // '500 mg'\n  instructions?: string;\n  nextReminderAt?: string;\n}\n\n5) API envelope types\n- export interface ApiError {\n-   code?: string;\n-   message: string;\n-   details?: any;\n- }\n-\n- export interface ApiResult<T> {\n-   success: boolean;\n-   data?: T;\n-   error?: ApiError;\n- }\n-\n- export interface PaginatedResponse<T> {\n-   items: T[];\n-   total: number;\n-   page: number;\n-   perPage: number;\n- }\n\n6) WebSocket event types (used by WebSocket mock and real WS integrations). Include event discriminants, payload shapes.\n- export type WebSocketEventType =\n-   | 'appointment_update'\n-   | 'incoming_call'\n-   | 'lab_result_available'\n-   | 'prescription_refill_request'\n-   | 'notification';\n-\n- export interface WebSocketEventBase {\n-   id: string;\n-   type: WebSocketEventType;\n-   timestamp: string; // ISO\n- }\n-\n- export interface AppointmentUpdateEvent extends WebSocketEventBase {\n-   type: 'appointment_update';\n-   payload: { appointmentId: string; status: Appointment['status']; }; \n- }\n-\n- export interface IncomingCallEvent extends WebSocketEventBase {\n-   type: 'incoming_call';\n-   payload: { callId: string; fromUserId: string; room?: string; }; \n- }\n-\n- export type WebSocketEvent = AppointmentUpdateEvent | IncomingCallEvent | {\n-   type: 'lab_result_available';\n-   payload: { labResultId: string; patientId: string; };\n- } | { type: 'prescription_refill_request'; payload: { prescriptionId: string; patientId: string } } | { type: 'notification'; payload: { title: string; body: string } };\n\n7) UI state helpers\n- export type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n-\n- export interface FormState {\n-   isSubmitting: boolean;\n-   isValid: boolean;\n-   errors?: Record<string, string>;\n- }\n\nPatterns and conventions\n- Keep domain models small and serializable.\n- Do not include service methods or runtime logic in this file\u2014only pure types.\n- Use these types across hooks, providers and services (e.g., appointmentsService returns ApiResult<PaginatedResponse<Appointment>>).\n\nExample usage\n- import { Appointment, ApiResult } from '@/core/contracts';\n- const result: ApiResult<Appointment[]> = await apiClient.get('/api/appointments');\n\nIntegration points\n- app/config.ts: will import Role types only to type-check mock user fixtures.\n- services/*: import domain models to declare return types.\n- hooks/useWebSocket.ts and core/events.ts: use WebSocketEvent types.\n"
    },
    {
      "file_path": "app/config.ts",
      "purpose": "Materialized runtime configuration object. Exposes typed flags and computed helper booleans. Also exports the development mock users derived from the top-level application configuration.",
      "exports": [
        "AppConfig",
        "config"
      ],
      "content": "Summary\n- Purpose: create a typed, materialized config that other modules import at runtime. The file reads environment variables minimally (process.env.NODE_ENV, process.env.REACT_APP_API_BASE) and merges them with the static application configuration provided in the build/development environment.\n- Keep the config pure and serializable.\n\nTypes\n- export interface AppConfig {\n-   appName: string;\n-   environment: 'development' | 'production' | 'test';\n-   apiBaseUrl: string;\n-   appType: string; // 'healthcare'\n-   framework: string; // 'react'\n-   features: string[]; // from architecture.features\n-   developmentMode: {\n-     enableMockData: boolean;\n-     mockAuthUsers: Array<{ email: string; password: string; role: 'doctor' | 'patient' | 'nurse' | string }>;\n-     mockApiEndpoints: string[];\n-     disableWebsocketInDev: boolean;\n-     useLocalstoragePersistence: boolean;\n-   };\n-   i18n: { defaultLocale: string; supported: string[] };\n-   featureFlags: Record<string, boolean>;\n- }\n\nMaterialized value and computed helpers\n- const isDevelopment = process.env.NODE_ENV !== 'production';\n- const apiBase = process.env.REACT_APP_API_BASE ?? (isDevelopment ? 'http://localhost:4000' : '/api');\n\n- export const config: AppConfig = { ... } // fully populated below.\n\nConcrete exported config (example)\nexport const config: AppConfig = {\n  appName: 'Patient Portal',\n  environment: (process.env.NODE_ENV as any) || 'development',\n  apiBaseUrl: apiBase,\n  appType: 'healthcare',\n  framework: 'react',\n  features: [\n    'appointment scheduling',\n    'medical records viewer',\n    'prescription management',\n    'telemedicine interface',\n    'health metrics dashboard',\n    'lab results display',\n    'insurance claim tracker',\n    'medication reminders'\n  ],\n  developmentMode: {\n    enableMockData: true,\n    mockAuthUsers: [\n      { email: 'doctor@hospital.com', password: 'doc123', role: 'doctor' },\n      { email: 'patient@email.com', password: 'patient123', role: 'patient' },\n      { email: 'nurse@hospital.com', password: 'nurse123', role: 'nurse' }\n    ],\n    mockApiEndpoints: [\n      '/api/appointments',\n      '/api/medical-records',\n      '/api/prescriptions',\n      '/api/lab-results',\n      '/api/insurance',\n      '/api/medications'\n    ],\n    disableWebsocketInDev: true,\n    useLocalstoragePersistence: true\n  },\n  i18n: { defaultLocale: 'en', supported: ['en', 'ko'] },\n  featureFlags: {\n    telemedicine: true,\n    prescriptionsRefill: true,\n    insuranceClaims: true\n  }\n};\n\nComputed helpers\n- export const isDevelopment = config.environment === 'development';\n- export const shouldUseMockData = isDevelopment && config.developmentMode.enableMockData;\n- export const shouldDisableWebsocket = isDevelopment && config.developmentMode.disableWebsocketInDev;\n- export const supportsFeature = (name: string) => config.features.includes(name) || !!config.featureFlags[name];\n\nMock data exposure\n- If shouldUseMockData is true, export a strongly-typed array of mockAuthUsers: export const mockAuthUsers = config.developmentMode.mockAuthUsers;\n\nPatterns and conventions\n- Import this file everywhere as the canonical runtime config. Avoid reading process.env elsewhere in the codebase.\n- Keep secrets out of the commit \u2014 only non-sensitive values belong here. In CI/production REACT_APP_API_BASE should be set externally.\n\nExample usage\n- import { config, shouldUseMockData, mockAuthUsers } from '@/app/config';\n- if (shouldUseMockData) { startMockServer({ users: mockAuthUsers }); }\n\nIntegration points\n- mocks/*: will import mockAuthUsers to seed authentication.\n- services/apiClient.ts and providers/QueryProvider.tsx: will read config.apiBaseUrl.\n- websocketMock.ts: will consult shouldDisableWebsocket.\n"
    },
    {
      "file_path": "core/events.ts",
      "purpose": "Typed, lightweight in-process event bus for cross-cutting notifications (incoming telemedicine calls, global notifications, background sync results). The event bus supports synchronous and asynchronous handlers and is safe to import anywhere.",
      "exports": [
        "EventBus",
        "subscribe",
        "publish",
        "unsubscribe",
        "events"
      ],
      "content": "Summary\n- Purpose: provide a tiny, typesafe publish/subscribe mechanism used by both UI and non-UI modules. Prefer EventBus for cross-component signals; prefer React Context for local UI state.\n- Implementation guarantees: handlers can be sync or return Promise<void>. publish returns Promise<void> that resolves when all handlers finished or rejects if any handler throws (caller can ignore errors if they wish).\n\nEvent map (typed)\n- Define a central EventMap interface mapping event names to payload shapes. Keep names camelCase and domain-specific.\n\nexport interface EventMap {\n  // Telemedicine\n  incomingCall: { callId: string; fromUserId: string; room?: string };\n  callEnded: { callId: string; reason?: string };\n\n  // Appointment lifecycle\n  appointmentUpdated: { appointmentId: string; status: string };\n\n  // Notifications\n  notification: { id: string; title: string; body?: string; level?: 'info' | 'warning' | 'error' };\n\n  // Auth\n  login: { userId: string };\n  logout: { userId?: string };\n\n  // Global error\n  globalError: { error: Error | string; context?: any };\n}\n\nEventBus class\n- class EventBus<EM extends Record<string, any>> {\n-   private handlers = new Map<keyof EM, Set<(...args: any[]) => any>>();\n-\n-   on<K extends keyof EM>(event: K, handler: (payload: EM[K]) => void | Promise<void>): () => void {\n-     // register and return unsubscribe\n-   }\n-\n-   off<K extends keyof EM>(event: K, handler: (payload: EM[K]) => void | Promise<void>): void {\n-     // remove handler\n-   }\n-\n-   async emit<K extends keyof EM>(event: K, payload: EM[K]): Promise<void> {\n-     // call handlers (catch per-handler errors, aggregate or rethrow depending on policy)\n-   }\n- }\n\nExported singleton\n- export const events = new EventBus<EventMap>();\n\nHelper functions exported for ergonomic usage\n- export const subscribe = events.on.bind(events);\n- export const unsubscribe = events.off.bind(events);\n- export const publish = events.emit.bind(events);\n\nBehavior and error policy\n- Handlers run in registration order.\n- publish waits for all handlers (await Promise.allSettled([...])) and then:\n  - if any handler throws, publish will log the error via core/utils.log and rethrow an aggregated Error containing first error message unless caller passes { swallowErrors: true }.\n- Provide an optional options bag on emit to control swallowErrors.\n\nCode example usage\n- import { publish, subscribe, events } from '@/core/events';\n-\n- // subscribing\n- const unsub = subscribe('incomingCall', async (payload) => {\n-   // show incoming call UI\n-   await showCallModal(payload);\n- });\n-\n- // publishing\n- await publish('incomingCall', { callId: 'abc', fromUserId: 'user-1', room: 'room-1' });\n-\n- // cleanup\n- unsub();\n\nIntegration points\n- AuthProvider emits 'login' and 'logout'.\n- WebSocketMock will publish 'appointmentUpdated', 'labResultAvailable' etc. Services and UI components subscribe to these events.\n- ErrorBoundary should publish 'globalError' when catching.\n"
    },
    {
      "file_path": "core/hooks.ts",
      "purpose": "A small, typed hook registry used to register lifecycle extension points. Use this for cross-cutting plugins (analytics, logging, feature toggles) without coupling to provider implementations.",
      "exports": [
        "registerHook",
        "runHooks",
        "HookPoint",
        "HookContext",
        "HookHandler"
      ],
      "content": "Summary\n- Purpose: enable feature modules or external integrations to register small callbacks at well-known points in the app lifecycle (e.g., beforeApiRequest, afterApiResponse, onLogin, onLogout, onRouteChange). Hooks run in registration order and can be sync or async.\n- Keep hooks lightweight: they receive a typed context and return void or Promise<void>.\n\nHookPoint names\n- export type HookPoint = 'beforeApiRequest' | 'afterApiResponse' | 'onLogin' | 'onLogout' | 'onRouteChange' | 'onError';\n\nHook context shapes\n- export interface HookContextBase { timestamp: string; }\n- export interface BeforeApiRequestContext extends HookContextBase { url: string; method: string; payload?: any; headers?: Record<string, string> }\n- export interface AfterApiResponseContext extends HookContextBase { url: string; method: string; status: number; response?: any; error?: any }\n- export interface AuthContext extends HookContextBase { userId: string }\n- export interface RouteChangeContext extends HookContextBase { from?: string; to: string }\n- export type HookContext = BeforeApiRequestContext | AfterApiResponseContext | AuthContext | RouteChangeContext | { [k: string]: any };\n\nHandler signature\n- export type HookHandler<HP extends HookPoint = HookPoint> = (ctx: HookContext) => void | Promise<void>;\n\nHookRegistry class\n- class HookRegistry {\n-   private registry = new Map<HookPoint, Set<HookHandler>>();\n-\n-   register(point: HookPoint, handler: HookHandler): () => void {\n-     // add and return unregister fn\n-   }\n-\n-   async run(point: HookPoint, ctx: HookContext): Promise<void> {\n-     // run handlers sequentially (or parallel depending on point). If a handler throws, log via core/utils and continue (do not break the chain) unless a handler returns a specific control message.\n-   }\n- }\n\nTop-level exports\n- export const hooks = new HookRegistry();\n- export const registerHook = hooks.register.bind(hooks);\n- export const runHooks = hooks.run.bind(hooks);\n\nDesign decisions\n- beforeApiRequest hooks should be able to mutate headers/payload if they return a modified object. To keep typing simple, beforeApiRequest handlers can return an optional mutated payload object; the caller (apiClient) should pick up the returned object.\n- afterApiResponse and onError are primarily for logging, analytics and instrumentation; they should not mutate the response.\n\nExample usage\n- Register a hook in a plugin module:\n  registerHook('beforeApiRequest', async (ctx) => {\n    // example: add header\n    if (ctx.headers) { ctx.headers['x-trace-id'] = generateTraceId(); }\n  });\n\n- apiClient integration point in services/apiClient.ts:\n  // before the fetch\n  const beforeResult = await runHooks('beforeApiRequest', { timestamp: new Date().toISOString(), url, method, payload, headers });\n  // after receiving response\n  await runHooks('afterApiResponse', { timestamp: new Date().toISOString(), url, method, status: response.status, response: parsed });\n\nIntegration points\n- services/apiClient.ts: call runHooks('beforeApiRequest'...) and runHooks('afterApiResponse'...)\n- providers/AuthProvider: call runHooks('onLogin') and runHooks('onLogout')\n- routes/AppRouter.tsx or router wrapper: call runHooks('onRouteChange')\n- ErrorBoundary: call runHooks('onError')\n"
    },
    {
      "file_path": "core/di.ts",
      "purpose": "A minimal, type-safe dependency injection service locator and token registry. Used to swap implementations in tests and to register mock adapters in development. Keep it intentionally small \u2014 the preferred pattern in the app is explicit props/context; DI is only for global swappables (apiClient, storage, websocket).",
      "exports": [
        "Token",
        "register",
        "resolve",
        "clearRegistry",
        "DIContainer",
        "Tokens"
      ],
      "content": "Summary\n- Purpose: provide a minimal, predictable container with token-level type safety. The container supports registering implementations under tokens (unique symbols) and resolving them in runtime code.\n- Do not use reflection or stringly-typed keys. Use well-documented symbols exported from this module for the canonical tokens.\n\nToken abstraction\n- export type Token<T> = symbol & { __type?: T };\n- export function createToken<T>(desc: string): Token<T> { return Symbol(desc) as Token<T>; }\n\nPre-defined tokens\n- export const Tokens = {\n-   ApiClient: createToken<{ get: Function; post: Function; put: Function; delete: Function }>('ApiClient'),\n-   AuthService: createToken<{ login: Function; logout: Function; getCurrentUser: Function }>('AuthService'),\n-   StorageService: createToken<{ getItem: (k: string) => any; setItem: (k: string, v: any) => void; removeItem: (k: string) => void }>('StorageService'),\n-   WebSocketService: createToken<{ publish: Function; subscribe: Function; unsubscribe: Function }>('WebSocketService')\n- } as const;\n\nContainer implementation\n- export class DIContainer {\n-   private registry = new Map<Token<any>, any>();\n-\n-   register<T>(token: Token<T>, impl: T, { overwrite = false } = {}) {\n-     if (!overwrite && this.registry.has(token)) throw new Error('Token already registered');\n-     this.registry.set(token, impl);\n-   }\n-\n-   resolve<T>(token: Token<T>): T {\n-     if (!this.registry.has(token)) throw new Error('No provider registered for token');\n-     return this.registry.get(token) as T;\n-   }\n-\n-   clear() { this.registry.clear(); }\n- }\n\nSingleton container helpers\n- export const container = new DIContainer();\n- export const register = container.register.bind(container);\n- export const resolve = container.resolve.bind(container);\n- export const clearRegistry = container.clear.bind(container);\n\nUsage pattern\n- Service implementation registers at app bootstrap (main.tsx or providers):\n  register(Tokens.ApiClient, apiClientInstance);\n  register(Tokens.StorageService, localStorageAdapter);\n\n- Consumers resolve in modules that must be swappable (rare):\n  const api = resolve(Tokens.ApiClient);\n  await api.get('/api/appointments');\n\nType-safety guidance\n- Prefer to import the concrete apiClient or pass implementations via React Context. Use DI only for true global swappables or when writing tests that need to swap implementations without mounting providers.\n\nIntegration points\n- main.tsx: register real implementations, and during development main.tsx can register mock implementations (mock apiClient, mock websocket) before app mounts.\n- tests: tests can call register(token, mockImpl, { overwrite: true }) and restore/clearRegistry after tests.\n"
    },
    {
      "file_path": "core/utils.ts",
      "purpose": "Small set of zero-dependency runtime utilities used by core kernel files and safe to import everywhere (safeJSON, noop, sleep, fetchWithTimeout, small logger). Keep this file tiny \u2014 avoid pulling in 3rd-party libs.",
      "exports": [
        "safeJSON",
        "noop",
        "sleep",
        "fetchWithTimeout",
        "log",
        "parseISODate",
        "isISODate",
        "deepClone"
      ],
      "content": "Summary\n- Purpose: small, dependency-free helpers used by kernel code (e.g., EventBus, HookRegistry) and safe to import anywhere including build-tooling.\n\nFunctions to implement\n1) noop\n- export const noop = (): void => {};\n\n2) safeJSON\n- export function safeJSON<T = any>(str: string | undefined | null, fallback: T | null = null): T | null {\n-   if (str == null) return fallback;\n-   try { return JSON.parse(str) as T; } catch (err) { log('warn', 'safeJSON parse failed', { str }); return fallback; }\n- }\n\n3) sleep\n- export const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n\n4) fetchWithTimeout\n- export async function fetchWithTimeout(input: RequestInfo, init: RequestInit = {}, timeout = 10000) {\n-   const controller = new AbortController();\n-   const timer = setTimeout(() => controller.abort(), timeout);\n-   try {\n-     const res = await fetch(input, { ...init, signal: controller.signal });\n-     clearTimeout(timer);\n-     return res;\n-   } catch (err) {\n-     clearTimeout(timer);\n-     throw err;\n-   }\n- }\n\n5) log\n- Lightweight logging wrapper that respects NODE_ENV: in production log only errors. Provide log(level, message, meta?).\n- export const log = (level: 'debug' | 'info' | 'warn' | 'error', message: string, meta?: any) => { if (process.env.NODE_ENV === 'production' && level === 'debug') return; /* prefer console for now */ console[level === 'debug' ? 'debug' : level === 'info' ? 'info' : level === 'warn' ? 'warn' : 'error'](`[${level.toUpperCase()}] ${message}`, meta ?? ''); };\n\n6) date helpers (tiny)\n- export function isISODate(value: string): boolean { return /^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}/.test(value); }\n- export function parseISODate(s: string): Date | null { try { const d = new Date(s); return Number.isNaN(d.getTime()) ? null : d; } catch { return null; } }\n\n7) deepClone\n- export function deepClone<T>(obj: T): T { return JSON.parse(JSON.stringify(obj)); }\n\nPatterns and conventions\n- Keep this file small to avoid increasing bundle size. When adding utilities, prefer to keep them pure and well-tested.\n- All functions are side-effect free except log().\n\nExample usage\n- import { safeJSON, fetchWithTimeout, sleep, log } from '@/core/utils';\n- const parsed = safeJSON<MyType>(raw, null);\n- await fetchWithTimeout('/api/ping', {}, 5000).catch(err => log('error', 'ping failed', err));\n\nIntegration points\n- events.ts: uses log() and safeJSON for serializing handler errors.\n- hooks.ts and di.ts: use noop, sleep for testing and safe shutdown flows.\n"
    }
  ],
  "usage_guidelines": [
    "Import domain types from '@/core/contracts' everywhere (services, providers, components). Keep the contracts file dependency-free of runtime services.",
    "Read all runtime configuration only from '@/app/config'. Do not access process.env directly across the codebase except in config.ts.",
    "Use the exported singleton event bus from '@/core/events' to publish cross-cutting events (incomingCall, appointmentUpdated, globalError). Prefer typed event names defined in EventMap.",
    "Register lifecycle hooks via '@/core/hooks'. ApiClient and providers will call runHooks at appropriate points (beforeApiRequest, afterApiResponse, onLogin, onLogout, onRouteChange).",
    "Use the DI container '@/core/di' only for global swappable implementations (api client, storage, websocket). Prefer React Context for most injection needs.",
    "Use small, pure utilities in '@/core/utils' for safe JSON parsing, fetch timeouts and logging. Keep kernel utilities side-effect free.",
    "In development, use config.shouldUseMockData and config.mockAuthUsers to bootstrap the mock server and seed auth users. Register mock implementations into DI before app renders.",
    "When adding new events, hook points or DI tokens: extend core contracts/types and add integration call sites (apiClient, providers, mockServer) to preserve type safety across the app."
  ]
}