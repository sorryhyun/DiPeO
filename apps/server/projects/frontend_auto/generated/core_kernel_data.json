{
  "kernel": {
    "overview": "Core kernel provides the single source of truth for domain contracts, application configuration, a typed event bus, hook registry for extension points, a lightweight dependency-injection container, and common utilities. These files are designed to be imported by all feature sections (e.g., appointments, prescriptions, lab results, telemedicine) and by shared providers (AuthProvider, ApiClient, WebSocketService). They are fully typed, self-contained, and ready for production use.",
    "files": [
      {
        "file_path": "core/contracts.ts",
        "purpose": "Domain types and API contracts used across the application: users, healthcare models, API response shapes, websocket events, and common UI state types.",
        "exports": [
          "Id",
          "Role",
          "Address",
          "ContactInfo",
          "User",
          "Patient",
          "Doctor",
          "Nurse",
          "Admin",
          "AppointmentStatus",
          "Appointment",
          "MedicalRecord",
          "PrescriptionStatus",
          "Prescription",
          "LabResultStatus",
          "LabResult",
          "ApiError",
          "ApiResult",
          "PaginatedResponse",
          "WebSocketChatMessageEvent",
          "WebSocketAppointmentEvent",
          "WebSocketLabResultEvent",
          "WebSocketEvent",
          "LoadingState",
          "FormState"
        ],
        "content": "/**\n * core/contracts.ts\n *\n * Canonical domain contracts for the HealthPortal application. Import these\n * types across features to ensure a single source of truth.\n *\n * Example:\n *  import { Appointment, Patient } from '@/core/contracts'\n */\n\n/** Generic identifier alias for entities */\nexport type Id = string;\n\n/** System roles (must align with app/config.ts.roles) */\nexport type Role = 'patient' | 'doctor' | 'nurse' | 'admin';\n\n/** Postal address */\nexport interface Address {\n  line1: string;\n  line2?: string;\n  city: string;\n  state?: string;\n  postalCode?: string;\n  country?: string;\n}\n\n/** Contact information */\nexport interface ContactInfo {\n  email?: string;\n  phone?: string;\n  preferred?: 'email' | 'phone' | 'sms';\n}\n\n/** Base user type */\nexport interface User {\n  id: Id;\n  email: string;\n  fullName: string;\n  role: Role;\n  avatarUrl?: string;\n  contact?: ContactInfo;\n  createdAt: string; // ISO timestamp\n  updatedAt?: string; // ISO timestamp\n}\n\n/** Patient-specific fields */\nexport interface Patient extends User {\n  role: 'patient';\n  dateOfBirth?: string; // ISO date\n  gender?: 'male' | 'female' | 'other' | 'unknown';\n  primaryPhysicianId?: Id;\n  address?: Address;\n  medicalRecordId?: Id;\n}\n\n/** Doctor-specific fields */\nexport interface Doctor extends User {\n  role: 'doctor';\n  specialty?: string;\n  licenseNumber?: string;\n  clinicLocation?: Address;\n  acceptsTelemedicine?: boolean;\n}\n\n/** Nurse-specific fields */\nexport interface Nurse extends User {\n  role: 'nurse';\n  department?: string;\n  supervisingPhysicianId?: Id;\n}\n\n/** Admin user */\nexport interface Admin extends User {\n  role: 'admin';\n  permissions?: string[];\n}\n\n/** Appointment domain model */\nexport type AppointmentStatus = 'scheduled' | 'checked_in' | 'in_progress' | 'completed' | 'cancelled' | 'no_show';\n\nexport interface Appointment {\n  id: Id;\n  patientId: Id;\n  doctorId: Id;\n  scheduledAt: string; // ISO timestamp\n  durationMinutes?: number;\n  status: AppointmentStatus;\n  location?: {\n    type: 'clinic' | 'telemedicine';\n    room?: string;\n    videoUrl?: string;\n    notes?: string;\n  };\n  reason?: string;\n  notes?: string;\n  createdAt: string;\n  updatedAt?: string;\n}\n\n/** Medical record */\nexport interface MedicalRecord {\n  id: Id;\n  patientId: Id;\n  allergies?: string[];\n  conditions?: string[];\n  medications?: Prescription[];\n  notes?: string;\n  lastUpdated: string; // ISO timestamp\n}\n\n/** Prescription model */\nexport type PrescriptionStatus = 'active' | 'fulfilled' | 'cancelled' | 'expired' | 'pending';\n\nexport interface Prescription {\n  id: Id;\n  patientId: Id;\n  prescriberId: Id; // doctor or provider\n  medicationName: string;\n  dosage: string; // e.g., \"5 mg\"\n  frequency: string; // e.g., \"once daily\"\n  quantity?: number;\n  refills?: number;\n  status: PrescriptionStatus;\n  issuedAt: string; // ISO timestamp\n  expiresAt?: string; // ISO timestamp\n  notes?: string;\n}\n\n/** Lab result model */\nexport type LabResultStatus = 'pending' | 'available' | 'reviewed' | 'amended';\n\nexport interface LabResult {\n  id: Id;\n  patientId: Id;\n  orderedById?: Id;\n  testName: string;\n  resultValue?: string;\n  resultUnit?: string;\n  referenceRange?: string;\n  status: LabResultStatus;\n  collectedAt?: string; // ISO timestamp\n  availableAt?: string; // ISO timestamp\n  notes?: string;\n}\n\n/** API error shape */\nexport interface ApiError {\n  code: string;\n  message: string;\n  details?: Record<string, unknown>;\n  status?: number;\n}\n\n/** Generic API result wrapper */\nexport interface ApiResult<T> {\n  ok: boolean;\n  data?: T;\n  error?: ApiError;\n}\n\n/** Standard paginated response */\nexport interface PaginatedResponse<T> {\n  items: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n}\n\n/** WebSocket events used in the app. These are consumed when the 'websockets' feature is enabled.\n * Examples: 'chat:message', 'appointment:status_changed', 'lab:result_available'\n */\nexport interface WebSocketChatMessageEvent {\n  type: 'chat:message';\n  messageId: Id;\n  conversationId: Id;\n  fromUserId: Id;\n  toUserId?: Id; // optional for group chats\n  text: string;\n  sentAt: string; // ISO timestamp\n}\n\nexport interface WebSocketAppointmentEvent {\n  type: 'appointment:status_changed';\n  appointmentId: Id;\n  oldStatus: AppointmentStatus;\n  newStatus: AppointmentStatus;\n  occurredAt: string; // ISO timestamp\n}\n\nexport interface WebSocketLabResultEvent {\n  type: 'lab:result_available';\n  labResultId: Id;\n  patientId: Id;\n  availableAt: string; // ISO timestamp\n}\n\nexport type WebSocketEvent = WebSocketChatMessageEvent | WebSocketAppointmentEvent | WebSocketLabResultEvent;\n\n/** Common UI states */\nexport type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\nexport interface FormState<TForm extends Record<string, unknown>> {\n  values: TForm;\n  errors: Partial<Record<keyof TForm, string>>;\n  touched: Partial<Record<keyof TForm, boolean>>;\n  isSubmitting: boolean;\n  isValid: boolean;\n}\n"
      },
      {
        "file_path": "app/config.ts",
        "purpose": "Materialized application configuration with typed settings, computed flags, feature toggles, and optional mock data for development.",
        "exports": [
          "Config",
          "AppConfig",
          "isDevelopment",
          "shouldUseMockData",
          "hasFeature",
          "MOCK_USERS"
        ],
        "content": "/**\n * app/config.ts\n *\n * Materialized runtime configuration. This should be treated as the single\n * authoritative source for feature toggles and environment flags.\n *\n * Example:\n *   import { AppConfig, hasFeature } from '@/app/config'\n */\n\nimport { Patient, Doctor, Nurse, Admin, User } from '../core/contracts';\n\n/** Configuration shape */\nexport interface Config {\n  appName: string;\n  env: 'development' | 'staging' | 'production';\n  apiBaseUrl: string;\n  websocketUrl?: string;\n  defaultPageSize: number;\n  roles: Array<'patient' | 'doctor' | 'nurse' | 'admin'>;\n  features: string[];\n  development_mode: {\n    enable_mock_data: boolean;\n    enable_verbose_logging: boolean;\n  };\n  sentryDsn?: string | null;\n}\n\n/** Concrete runtime configuration. Modify via environment variables or build-time replacement.\n * Note: In many build systems, this file may be replaced or values injected at build time.\n */\nexport const AppConfig: Config = {\n  appName: 'HealthPortal',\n  // default to development unless NODE_ENV === 'production'\n  env: process.env.NODE_ENV === 'production' ? 'production' : 'development',\n  apiBaseUrl: process.env.API_BASE_URL ?? 'https://api.healthportal.example.com',\n  websocketUrl: process.env.WS_URL ?? 'wss://ws.healthportal.example.com',\n  defaultPageSize: 20,\n  roles: ['patient', 'doctor', 'nurse', 'admin'],\n  // Feature list used by hasFeature() helper and to conditionally enable modules\n  features: [\n    'appointments',\n    'prescriptions',\n    'lab_results',\n    'telemedicine',\n    'notifications',\n    'websockets'\n  ],\n  development_mode: {\n    enable_mock_data: process.env.ENABLE_MOCK_DATA === 'true' || true,\n    enable_verbose_logging: process.env.ENABLE_VERBOSE_LOGGING === 'true' || true\n  },\n  sentryDsn: process.env.SENTRY_DSN ?? null\n};\n\n/** Computed flags */\nexport const isDevelopment: boolean = AppConfig.env === 'development';\nexport const shouldUseMockData: boolean = isDevelopment && AppConfig.development_mode.enable_mock_data;\n\n/** Feature toggle helper */\nexport function hasFeature(featureName: string): boolean {\n  return AppConfig.features.includes(featureName);\n}\n\n/**\n * Built-in mock data available when development_mode.enable_mock_data is true.\n * These structures mirror core/contracts types and are safe for use by mock server\n * and components during local development.\n */\nexport const MOCK_USERS: Array<User | Patient | Doctor | Nurse | Admin> = shouldUseMockData\n  ? [\n      {\n        id: 'mock-patient-1',\n        email: 'jane.patient@example.test',\n        fullName: 'Jane Patient',\n        role: 'patient',\n        contact: { email: 'jane.patient@example.test', phone: '555-0100', preferred: 'email' },\n        createdAt: new Date().toISOString(),\n        dateOfBirth: '1988-04-12'\n      } as Patient,\n      {\n        id: 'mock-doctor-1',\n        email: 'dr.smith@example.test',\n        fullName: 'Dr. John Smith',\n        role: 'doctor',\n        specialty: 'Family Medicine',\n        acceptsTelemedicine: true,\n        createdAt: new Date().toISOString()\n      } as Doctor,\n      {\n        id: 'mock-nurse-1',\n        email: 'nurse.adams@example.test',\n        fullName: 'Nurse Adams',\n        role: 'nurse',\n        department: 'Primary Care',\n        createdAt: new Date().toISOString()\n      } as Nurse,\n      {\n        id: 'mock-admin-1',\n        email: 'admin@example.test',\n        fullName: 'System Admin',\n        role: 'admin',\n        permissions: ['manage:users', 'manage:appointments'],\n        createdAt: new Date().toISOString()\n      } as Admin\n    ]\n  : [];\n"
      },
      {
        "file_path": "core/events.ts",
        "purpose": "Typed lightweight event bus for synchronous and asynchronous inter-component communication. Exports a singleton EventBus instance.",
        "exports": [
          "CoreEventMap",
          "EventHandler",
          "Unsubscribe",
          "EventBus",
          "defaultEventBus"
        ],
        "content": "/**\n * core/events.ts\n *\n * Lightweight typed event bus that supports synchronous and asynchronous handlers.\n * Use the exported singleton defaultEventBus for application-level events or\n * instantiate EventBus<T> for smaller scoped event maps.\n *\n * Example:\n *   import { defaultEventBus } from '@/core/events'\n *   defaultEventBus.on('appointment:created', (appt) => { ... })\n */\n\nimport { Appointment, LabResult, Prescription, User, WebSocketEvent } from './contracts';\n\n/** Core event names and their payloads. Extend this map when adding cross-cutting events. */\nexport interface CoreEventMap {\n  'user:login': { user: User };\n  'user:logout': { userId: string } | void;\n  'appointment:created': Appointment;\n  'appointment:updated': Appointment;\n  'appointment:cancelled': { appointmentId: string; reason?: string };\n  'lab:result:available': LabResult;\n  'prescription:issued': Prescription;\n  'notification:push': { message: string; level: 'info' | 'warning' | 'error' };\n  // raw websocket events forwarded to consumers\n  'ws:message': WebSocketEvent;\n}\n\n/** Handler type for event payload T */\nexport type EventHandler<T> = (payload: T) => void | Promise<void>;\n\n/** Unsubscribe callback returned by EventBus.on */\nexport type Unsubscribe = () => void;\n\n/**\n * EventBus implementation. Handlers are executed sequentially in registration order.\n * If a handler throws or rejects, it is caught and logged to avoid breaking other handlers.\n */\nexport class EventBus<E extends Record<string, unknown> = CoreEventMap> {\n  private handlers: Map<keyof E, Array<EventHandler<unknown>>> = new Map();\n\n  /** Subscribe to an event. Returns an unsubscribe function. */\n  public on<K extends keyof E>(event: K, handler: EventHandler<E[K]>): Unsubscribe {\n    const list = (this.handlers.get(event) ?? []) as Array<EventHandler<E[K]>>;\n    list.push(handler as EventHandler<unknown>);\n    this.handlers.set(event, list as Array<EventHandler<unknown>>);\n    return () => this.off(event, handler);\n  }\n\n  /** Unsubscribe a handler for an event. Safe to call multiple times. */\n  public off<K extends keyof E>(event: K, handler: EventHandler<E[K]>): void {\n    const list = this.handlers.get(event) as Array<EventHandler<E[K]>> | undefined;\n    if (!list) return;\n    const idx = list.indexOf(handler as EventHandler<E[K]>);\n    if (idx !== -1) list.splice(idx, 1);\n    if (list.length === 0) this.handlers.delete(event);\n  }\n\n  /**\n   * Emit an event and await each handler in registration order. Errors from handlers are logged and do not stop the emission.\n   */\n  public async emit<K extends keyof E>(event: K, payload: E[K]): Promise<void> {\n    const list = this.handlers.get(event) as Array<EventHandler<E[K]>> | undefined;\n    if (!list || list.length === 0) return;\n    for (const handler of Array.from(list)) {\n      try {\n        // await to preserve ordering and allow async handlers to complete\n        await handler(payload);\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error(`Error in event handler for ${String(event)}:`, error);\n      }\n    }\n  }\n}\n\n/** Default application-wide event bus */\nexport const defaultEventBus = new EventBus<CoreEventMap>();\n"
      },
      {
        "file_path": "core/hooks.ts",
        "purpose": "Hook registry for extension points. Allows registering sync/async hook handlers and running them with a shared context.",
        "exports": [
          "HookPoint",
          "HookContext",
          "HookHandler",
          "HookRegistry",
          "globalHooks"
        ],
        "content": "/**\n * core/hooks.ts\n *\n * Extension hook registry. Components and services may register handlers for\n * common extension points. Handlers may be synchronous or asynchronous and\n * are executed in registration order. Results are collected and returned to callers.\n *\n * Example:\n *   import { globalHooks } from '@/core/hooks'\n *   globalHooks.register('beforeApiRequest', async (ctx, payload) => { ... })\n */\n\nimport { User } from './contracts';\nimport { ApiClient } from './di';\n\n/** Supported hook names for the application */\nexport type HookPoint = 'beforeApiRequest' | 'afterApiResponse' | 'onLogin' | 'onLogout' | 'onRouteChange';\n\n/** Context available to hook handlers. Callers may pass additional properties via meta. */\nexport interface HookContext {\n  user?: User | null;\n  route?: string;\n  apiClient?: ApiClient; // optional helper for handlers that need to make API calls\n  meta?: Record<string, unknown>;\n}\n\n/** Hook handler signature. TPayload is the payload passed by the caller and TResult is the optional result type. */\nexport type HookHandler<TPayload = unknown, TResult = unknown> = (\n  ctx: HookContext,\n  payload?: TPayload\n) => TResult | Promise<TResult>;\n\n/** Registry that manages handlers for named hook points */\nexport class HookRegistry {\n  private registry: Map<HookPoint, Array<HookHandler<unknown, unknown>>> = new Map();\n\n  /** Register a handler for a hook point. Returns an unregister function. */\n  public register<TPayload = unknown, TResult = unknown>(\n    hook: HookPoint,\n    handler: HookHandler<TPayload, TResult>\n  ): () => void {\n    const list = this.registry.get(hook) ?? [];\n    list.push(handler as HookHandler<unknown, unknown>);\n    this.registry.set(hook, list);\n    return () => this.unregister(hook, handler as HookHandler<unknown, unknown>);\n  }\n\n  /** Unregister a specific handler. */\n  private unregister(hook: HookPoint, handler: HookHandler<unknown, unknown>): void {\n    const list = this.registry.get(hook);\n    if (!list) return;\n    const idx = list.indexOf(handler);\n    if (idx >= 0) list.splice(idx, 1);\n    if (list.length === 0) this.registry.delete(hook);\n  }\n\n  /** Run all handlers for a hook point. Returns results in registration order. */\n  public async run<TPayload = unknown, TResult = unknown>(\n    hook: HookPoint,\n    ctx: HookContext,\n    payload?: TPayload\n  ): Promise<Array<TResult | undefined>> {\n    const list = (this.registry.get(hook) ?? []) as Array<HookHandler<TPayload, TResult>>;\n    const results: Array<TResult | undefined> = [];\n    for (const handler of list) {\n      try {\n        // Await each handler to preserve order and allow async operations\n        // eslint-disable-next-line @typescript-eslint/await-thenable\n        const res = await handler(ctx, payload);\n        results.push(res as TResult);\n      } catch (error) {\n        // Log and continue with next handler\n        // eslint-disable-next-line no-console\n        console.error(`Hook handler failed for ${hook}:`, error);\n        results.push(undefined);\n      }\n    }\n    return results;\n  }\n\n  /** Returns number of handlers registered for a hook */\n  public count(hook: HookPoint): number {\n    return (this.registry.get(hook) ?? []).length;\n  }\n}\n\n/** Global hook registry instance used throughout the app */\nexport const globalHooks = new HookRegistry();\n"
      },
      {
        "file_path": "core/di.ts",
        "purpose": "Lightweight dependency injection container with type-safe tokens and commonly used service interfaces (ApiClient, AuthService, StorageService, WebSocketService).",
        "exports": [
          "Token",
          "createToken",
          "ApiClient",
          "AuthService",
          "StorageService",
          "WebSocketService",
          "API_CLIENT_TOKEN",
          "AUTH_SERVICE_TOKEN",
          "STORAGE_SERVICE_TOKEN",
          "WEBSOCKET_SERVICE_TOKEN",
          "Container"
        ],
        "content": "/**\n * core/di.ts\n *\n * Small, type-safe DI container and tokens for commonly used services. Tokens are\n * strongly typed to ensure compile-time safety when registering and resolving services.\n *\n * Example:\n *   import { Container, API_CLIENT_TOKEN } from '@/core/di'\n *   container.register(API_CLIENT_TOKEN, myApiClient)\n */\n\nimport { User } from './contracts';\nimport { ApiResult, Prescription, Appointment, LabResult } from './contracts';\n\n/** Opaque token type for service registration */\nexport interface Token<T> {\n  readonly key: symbol;\n  readonly description?: string;\n}\n\n/** Create a unique token for a given service type */\nexport function createToken<T>(description?: string): Token<T> {\n  return { key: Symbol(description), description };\n}\n\n/** API client interface used across the app */\nexport interface ApiClient {\n  get<T>(path: string, params?: Record<string, unknown>): Promise<ApiResult<T>>;\n  post<T, B = unknown>(path: string, body?: B): Promise<ApiResult<T>>;\n  patch<T, B = unknown>(path: string, body?: B): Promise<ApiResult<T>>;\n  delete<T>(path: string): Promise<ApiResult<T>>;\n  // Optional helper to set auth token (implementation-defined)\n  setAuthToken?(token: string | null): void;\n}\n\n/** Authentication service interface */\nexport interface AuthService {\n  login(email: string, password: string): Promise<ApiResult<{ token: string; user: User }>>;\n  logout(): Promise<void>;\n  getCurrentUser(): Promise<ApiResult<User | null>>;\n}\n\n/** Abstraction over persistent storage used by app (localStorage/sessionStorage wrappers) */\nexport interface StorageService {\n  setItem<T>(key: string, value: T): Promise<void>;\n  getItem<T>(key: string): Promise<T | null>;\n  removeItem(key: string): Promise<void>;\n}\n\n/** WebSocket service interface */\nexport interface WebSocketService {\n  connect(): Promise<void>;\n  disconnect(): Promise<void>;\n  send(event: unknown): Promise<void>;\n  isConnected(): boolean;\n}\n\n/** Common tokens used by application modules */\nexport const API_CLIENT_TOKEN = createToken<ApiClient>('API_CLIENT');\nexport const AUTH_SERVICE_TOKEN = createToken<AuthService>('AUTH_SERVICE');\nexport const STORAGE_SERVICE_TOKEN = createToken<StorageService>('STORAGE_SERVICE');\nexport const WEBSOCKET_SERVICE_TOKEN = createToken<WebSocketService>('WEBSOCKET_SERVICE');\n\n/** Simple DI container implementation. Throws on duplicate registration or missing resolution. */\nexport class Container {\n  private readonly map = new Map<symbol, unknown>();\n\n  /** Register an instance for a token. Throws if token already registered. */\n  public register<T>(token: Token<T>, instance: T): void {\n    if (this.map.has(token.key)) {\n      throw new Error(`Token already registered: ${String(token.description ?? token.key.toString())}`);\n    }\n    this.map.set(token.key, instance as unknown);\n  }\n\n  /** Resolve a registered instance. Throws if not found. */\n  public resolve<T>(token: Token<T>): T {\n    const instance = this.map.get(token.key);\n    if (instance === undefined) {\n      throw new Error(`No provider registered for token: ${String(token.description ?? token.key.toString())}`);\n    }\n    return instance as T;\n  }\n\n  /** Resolve optional: returns the instance or null when not registered. */\n  public resolveOptional<T>(token: Token<T>): T | null {\n    const instance = this.map.get(token.key);\n    return (instance as T) ?? null;\n  }\n\n  /** Clears all registered tokens. Useful for tests and reset scenarios. */\n  public clear(): void {\n    this.map.clear();\n  }\n}\n"
      },
      {
        "file_path": "core/utils.ts",
        "purpose": "Common utilities: date formatting, validation helpers, safe JSON parse/stringify, UUID generator, and debug logging utilities.",
        "exports": [
          "formatDateShort",
          "formatDateTime",
          "parseISODate",
          "validateEmail",
          "uuidv4",
          "safeJsonParse",
          "safeJsonStringify",
          "debugLog"
        ],
        "content": "/**\n * core/utils.ts\n *\n * Lightweight utilities used across the codebase. These functions are small and\n * side-effect-free (except debugLog which writes to console in development).\n */\n\nimport { isDevelopment } from '../app/config';\n\n/** Format ISO date (YYYY-MM-DD) or return empty string for invalid input */\nexport function formatDateShort(iso?: string | null): string {\n  if (!iso) return '';\n  const d = new Date(iso);\n  if (Number.isNaN(d.getTime())) return '';\n  const year = d.getUTCFullYear();\n  const month = String(d.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(d.getUTCDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\n/** Format ISO timestamp to a localized date-time string */\nexport function formatDateTime(iso?: string | null): string {\n  if (!iso) return '';\n  const d = new Date(iso);\n  if (Number.isNaN(d.getTime())) return '';\n  return d.toLocaleString();\n}\n\n/** Parse an ISO string into a Date or return null for invalid input */\nexport function parseISODate(iso?: string | null): Date | null {\n  if (!iso) return null;\n  const d = new Date(iso);\n  return Number.isNaN(d.getTime()) ? null : d;\n}\n\n/** Basic email validation used by forms */\nexport function validateEmail(email: string): boolean {\n  const re = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n  return re.test(email);\n}\n\n/** RFC4122 v4 UUID generator for client-side ids */\nexport function uuidv4(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n/** Safe JSON parse that returns null on failure */\nexport function safeJsonParse<T = unknown>(text: string | null | undefined): T | null {\n  if (text == null) return null;\n  try {\n    return JSON.parse(text) as T;\n  } catch {\n    return null;\n  }\n}\n\n/** Safe stringify that handles circular references gracefully */\nexport function safeJsonStringify(value: unknown, space?: number): string {\n  try {\n    return JSON.stringify(value, getCircularReplacer(), space);\n  } catch {\n    return String(value);\n  }\n}\n\nfunction getCircularReplacer() {\n  const seen = new WeakSet<object>();\n  return (_key: string, value: unknown) => {\n    if (typeof value === 'object' && value !== null) {\n      if (seen.has(value as object)) {\n        return '[Circular]';\n      }\n      seen.add(value as object);\n    }\n    return value;\n  };\n}\n\n/** Debug logger enabled only in development mode */\nexport function debugLog(...args: unknown[]): void {\n  if (isDevelopment) {\n    // eslint-disable-next-line no-console\n    console.debug('[HealthPortal]', ...args);\n  }\n}\n"
      }
    ],
    "usage_guidelines": [
      "Import domain types from core/contracts.ts (e.g., import { User, Appointment } from '@/core/contracts')",
      "Use AppConfig and helpers from app/config.ts for feature toggles and runtime flags (import { AppConfig, hasFeature } from '@/app/config')",
      "Use the singleton event bus for decoupled communication (import { defaultEventBus } from '@/core/events')",
      "Register extension points with the global hook registry (import { globalHooks } from '@/core/hooks')",
      "Register shared services in the DI container using tokens from core/di.ts (import { Container, API_CLIENT_TOKEN } from '@/core/di')",
      "Use core/utils.ts for small helpers like formatDateTime, uuidv4, safeJsonParse and debugLog",
      "Examples in comments show '@/core/*' import paths which align with a typical baseUrl / path alias configured in tsconfig.json"
    ]
  },
  "inputs": {
    "kernel": {
      "overview": "Core kernel provides the single source of truth for domain contracts, application configuration, a typed event bus, hook registry for extension points, a lightweight dependency-injection container, and common utilities. These files are designed to be imported by all feature sections (e.g., appointments, prescriptions, lab results, telemedicine) and by shared providers (AuthProvider, ApiClient, WebSocketService). They are fully typed, self-contained, and ready for production use.",
      "files": [
        {
          "file_path": "core/contracts.ts",
          "purpose": "Domain types and API contracts used across the application: users, healthcare models, API response shapes, websocket events, and common UI state types.",
          "exports": [
            "Id",
            "Role",
            "Address",
            "ContactInfo",
            "User",
            "Patient",
            "Doctor",
            "Nurse",
            "Admin",
            "AppointmentStatus",
            "Appointment",
            "MedicalRecord",
            "PrescriptionStatus",
            "Prescription",
            "LabResultStatus",
            "LabResult",
            "ApiError",
            "ApiResult",
            "PaginatedResponse",
            "WebSocketChatMessageEvent",
            "WebSocketAppointmentEvent",
            "WebSocketLabResultEvent",
            "WebSocketEvent",
            "LoadingState",
            "FormState"
          ],
          "content": "/**\n * core/contracts.ts\n *\n * Canonical domain contracts for the HealthPortal application. Import these\n * types across features to ensure a single source of truth.\n *\n * Example:\n *  import { Appointment, Patient } from '@/core/contracts'\n */\n\n/** Generic identifier alias for entities */\nexport type Id = string;\n\n/** System roles (must align with app/config.ts.roles) */\nexport type Role = 'patient' | 'doctor' | 'nurse' | 'admin';\n\n/** Postal address */\nexport interface Address {\n  line1: string;\n  line2?: string;\n  city: string;\n  state?: string;\n  postalCode?: string;\n  country?: string;\n}\n\n/** Contact information */\nexport interface ContactInfo {\n  email?: string;\n  phone?: string;\n  preferred?: 'email' | 'phone' | 'sms';\n}\n\n/** Base user type */\nexport interface User {\n  id: Id;\n  email: string;\n  fullName: string;\n  role: Role;\n  avatarUrl?: string;\n  contact?: ContactInfo;\n  createdAt: string; // ISO timestamp\n  updatedAt?: string; // ISO timestamp\n}\n\n/** Patient-specific fields */\nexport interface Patient extends User {\n  role: 'patient';\n  dateOfBirth?: string; // ISO date\n  gender?: 'male' | 'female' | 'other' | 'unknown';\n  primaryPhysicianId?: Id;\n  address?: Address;\n  medicalRecordId?: Id;\n}\n\n/** Doctor-specific fields */\nexport interface Doctor extends User {\n  role: 'doctor';\n  specialty?: string;\n  licenseNumber?: string;\n  clinicLocation?: Address;\n  acceptsTelemedicine?: boolean;\n}\n\n/** Nurse-specific fields */\nexport interface Nurse extends User {\n  role: 'nurse';\n  department?: string;\n  supervisingPhysicianId?: Id;\n}\n\n/** Admin user */\nexport interface Admin extends User {\n  role: 'admin';\n  permissions?: string[];\n}\n\n/** Appointment domain model */\nexport type AppointmentStatus = 'scheduled' | 'checked_in' | 'in_progress' | 'completed' | 'cancelled' | 'no_show';\n\nexport interface Appointment {\n  id: Id;\n  patientId: Id;\n  doctorId: Id;\n  scheduledAt: string; // ISO timestamp\n  durationMinutes?: number;\n  status: AppointmentStatus;\n  location?: {\n    type: 'clinic' | 'telemedicine';\n    room?: string;\n    videoUrl?: string;\n    notes?: string;\n  };\n  reason?: string;\n  notes?: string;\n  createdAt: string;\n  updatedAt?: string;\n}\n\n/** Medical record */\nexport interface MedicalRecord {\n  id: Id;\n  patientId: Id;\n  allergies?: string[];\n  conditions?: string[];\n  medications?: Prescription[];\n  notes?: string;\n  lastUpdated: string; // ISO timestamp\n}\n\n/** Prescription model */\nexport type PrescriptionStatus = 'active' | 'fulfilled' | 'cancelled' | 'expired' | 'pending';\n\nexport interface Prescription {\n  id: Id;\n  patientId: Id;\n  prescriberId: Id; // doctor or provider\n  medicationName: string;\n  dosage: string; // e.g., \"5 mg\"\n  frequency: string; // e.g., \"once daily\"\n  quantity?: number;\n  refills?: number;\n  status: PrescriptionStatus;\n  issuedAt: string; // ISO timestamp\n  expiresAt?: string; // ISO timestamp\n  notes?: string;\n}\n\n/** Lab result model */\nexport type LabResultStatus = 'pending' | 'available' | 'reviewed' | 'amended';\n\nexport interface LabResult {\n  id: Id;\n  patientId: Id;\n  orderedById?: Id;\n  testName: string;\n  resultValue?: string;\n  resultUnit?: string;\n  referenceRange?: string;\n  status: LabResultStatus;\n  collectedAt?: string; // ISO timestamp\n  availableAt?: string; // ISO timestamp\n  notes?: string;\n}\n\n/** API error shape */\nexport interface ApiError {\n  code: string;\n  message: string;\n  details?: Record<string, unknown>;\n  status?: number;\n}\n\n/** Generic API result wrapper */\nexport interface ApiResult<T> {\n  ok: boolean;\n  data?: T;\n  error?: ApiError;\n}\n\n/** Standard paginated response */\nexport interface PaginatedResponse<T> {\n  items: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n}\n\n/** WebSocket events used in the app. These are consumed when the 'websockets' feature is enabled.\n * Examples: 'chat:message', 'appointment:status_changed', 'lab:result_available'\n */\nexport interface WebSocketChatMessageEvent {\n  type: 'chat:message';\n  messageId: Id;\n  conversationId: Id;\n  fromUserId: Id;\n  toUserId?: Id; // optional for group chats\n  text: string;\n  sentAt: string; // ISO timestamp\n}\n\nexport interface WebSocketAppointmentEvent {\n  type: 'appointment:status_changed';\n  appointmentId: Id;\n  oldStatus: AppointmentStatus;\n  newStatus: AppointmentStatus;\n  occurredAt: string; // ISO timestamp\n}\n\nexport interface WebSocketLabResultEvent {\n  type: 'lab:result_available';\n  labResultId: Id;\n  patientId: Id;\n  availableAt: string; // ISO timestamp\n}\n\nexport type WebSocketEvent = WebSocketChatMessageEvent | WebSocketAppointmentEvent | WebSocketLabResultEvent;\n\n/** Common UI states */\nexport type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\nexport interface FormState<TForm extends Record<string, unknown>> {\n  values: TForm;\n  errors: Partial<Record<keyof TForm, string>>;\n  touched: Partial<Record<keyof TForm, boolean>>;\n  isSubmitting: boolean;\n  isValid: boolean;\n}\n"
        },
        {
          "file_path": "app/config.ts",
          "purpose": "Materialized application configuration with typed settings, computed flags, feature toggles, and optional mock data for development.",
          "exports": [
            "Config",
            "AppConfig",
            "isDevelopment",
            "shouldUseMockData",
            "hasFeature",
            "MOCK_USERS"
          ],
          "content": "/**\n * app/config.ts\n *\n * Materialized runtime configuration. This should be treated as the single\n * authoritative source for feature toggles and environment flags.\n *\n * Example:\n *   import { AppConfig, hasFeature } from '@/app/config'\n */\n\nimport { Patient, Doctor, Nurse, Admin, User } from '../core/contracts';\n\n/** Configuration shape */\nexport interface Config {\n  appName: string;\n  env: 'development' | 'staging' | 'production';\n  apiBaseUrl: string;\n  websocketUrl?: string;\n  defaultPageSize: number;\n  roles: Array<'patient' | 'doctor' | 'nurse' | 'admin'>;\n  features: string[];\n  development_mode: {\n    enable_mock_data: boolean;\n    enable_verbose_logging: boolean;\n  };\n  sentryDsn?: string | null;\n}\n\n/** Concrete runtime configuration. Modify via environment variables or build-time replacement.\n * Note: In many build systems, this file may be replaced or values injected at build time.\n */\nexport const AppConfig: Config = {\n  appName: 'HealthPortal',\n  // default to development unless NODE_ENV === 'production'\n  env: process.env.NODE_ENV === 'production' ? 'production' : 'development',\n  apiBaseUrl: process.env.API_BASE_URL ?? 'https://api.healthportal.example.com',\n  websocketUrl: process.env.WS_URL ?? 'wss://ws.healthportal.example.com',\n  defaultPageSize: 20,\n  roles: ['patient', 'doctor', 'nurse', 'admin'],\n  // Feature list used by hasFeature() helper and to conditionally enable modules\n  features: [\n    'appointments',\n    'prescriptions',\n    'lab_results',\n    'telemedicine',\n    'notifications',\n    'websockets'\n  ],\n  development_mode: {\n    enable_mock_data: process.env.ENABLE_MOCK_DATA === 'true' || true,\n    enable_verbose_logging: process.env.ENABLE_VERBOSE_LOGGING === 'true' || true\n  },\n  sentryDsn: process.env.SENTRY_DSN ?? null\n};\n\n/** Computed flags */\nexport const isDevelopment: boolean = AppConfig.env === 'development';\nexport const shouldUseMockData: boolean = isDevelopment && AppConfig.development_mode.enable_mock_data;\n\n/** Feature toggle helper */\nexport function hasFeature(featureName: string): boolean {\n  return AppConfig.features.includes(featureName);\n}\n\n/**\n * Built-in mock data available when development_mode.enable_mock_data is true.\n * These structures mirror core/contracts types and are safe for use by mock server\n * and components during local development.\n */\nexport const MOCK_USERS: Array<User | Patient | Doctor | Nurse | Admin> = shouldUseMockData\n  ? [\n      {\n        id: 'mock-patient-1',\n        email: 'jane.patient@example.test',\n        fullName: 'Jane Patient',\n        role: 'patient',\n        contact: { email: 'jane.patient@example.test', phone: '555-0100', preferred: 'email' },\n        createdAt: new Date().toISOString(),\n        dateOfBirth: '1988-04-12'\n      } as Patient,\n      {\n        id: 'mock-doctor-1',\n        email: 'dr.smith@example.test',\n        fullName: 'Dr. John Smith',\n        role: 'doctor',\n        specialty: 'Family Medicine',\n        acceptsTelemedicine: true,\n        createdAt: new Date().toISOString()\n      } as Doctor,\n      {\n        id: 'mock-nurse-1',\n        email: 'nurse.adams@example.test',\n        fullName: 'Nurse Adams',\n        role: 'nurse',\n        department: 'Primary Care',\n        createdAt: new Date().toISOString()\n      } as Nurse,\n      {\n        id: 'mock-admin-1',\n        email: 'admin@example.test',\n        fullName: 'System Admin',\n        role: 'admin',\n        permissions: ['manage:users', 'manage:appointments'],\n        createdAt: new Date().toISOString()\n      } as Admin\n    ]\n  : [];\n"
        },
        {
          "file_path": "core/events.ts",
          "purpose": "Typed lightweight event bus for synchronous and asynchronous inter-component communication. Exports a singleton EventBus instance.",
          "exports": [
            "CoreEventMap",
            "EventHandler",
            "Unsubscribe",
            "EventBus",
            "defaultEventBus"
          ],
          "content": "/**\n * core/events.ts\n *\n * Lightweight typed event bus that supports synchronous and asynchronous handlers.\n * Use the exported singleton defaultEventBus for application-level events or\n * instantiate EventBus<T> for smaller scoped event maps.\n *\n * Example:\n *   import { defaultEventBus } from '@/core/events'\n *   defaultEventBus.on('appointment:created', (appt) => { ... })\n */\n\nimport { Appointment, LabResult, Prescription, User, WebSocketEvent } from './contracts';\n\n/** Core event names and their payloads. Extend this map when adding cross-cutting events. */\nexport interface CoreEventMap {\n  'user:login': { user: User };\n  'user:logout': { userId: string } | void;\n  'appointment:created': Appointment;\n  'appointment:updated': Appointment;\n  'appointment:cancelled': { appointmentId: string; reason?: string };\n  'lab:result:available': LabResult;\n  'prescription:issued': Prescription;\n  'notification:push': { message: string; level: 'info' | 'warning' | 'error' };\n  // raw websocket events forwarded to consumers\n  'ws:message': WebSocketEvent;\n}\n\n/** Handler type for event payload T */\nexport type EventHandler<T> = (payload: T) => void | Promise<void>;\n\n/** Unsubscribe callback returned by EventBus.on */\nexport type Unsubscribe = () => void;\n\n/**\n * EventBus implementation. Handlers are executed sequentially in registration order.\n * If a handler throws or rejects, it is caught and logged to avoid breaking other handlers.\n */\nexport class EventBus<E extends Record<string, unknown> = CoreEventMap> {\n  private handlers: Map<keyof E, Array<EventHandler<unknown>>> = new Map();\n\n  /** Subscribe to an event. Returns an unsubscribe function. */\n  public on<K extends keyof E>(event: K, handler: EventHandler<E[K]>): Unsubscribe {\n    const list = (this.handlers.get(event) ?? []) as Array<EventHandler<E[K]>>;\n    list.push(handler as EventHandler<unknown>);\n    this.handlers.set(event, list as Array<EventHandler<unknown>>);\n    return () => this.off(event, handler);\n  }\n\n  /** Unsubscribe a handler for an event. Safe to call multiple times. */\n  public off<K extends keyof E>(event: K, handler: EventHandler<E[K]>): void {\n    const list = this.handlers.get(event) as Array<EventHandler<E[K]>> | undefined;\n    if (!list) return;\n    const idx = list.indexOf(handler as EventHandler<E[K]>);\n    if (idx !== -1) list.splice(idx, 1);\n    if (list.length === 0) this.handlers.delete(event);\n  }\n\n  /**\n   * Emit an event and await each handler in registration order. Errors from handlers are logged and do not stop the emission.\n   */\n  public async emit<K extends keyof E>(event: K, payload: E[K]): Promise<void> {\n    const list = this.handlers.get(event) as Array<EventHandler<E[K]>> | undefined;\n    if (!list || list.length === 0) return;\n    for (const handler of Array.from(list)) {\n      try {\n        // await to preserve ordering and allow async handlers to complete\n        await handler(payload);\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error(`Error in event handler for ${String(event)}:`, error);\n      }\n    }\n  }\n}\n\n/** Default application-wide event bus */\nexport const defaultEventBus = new EventBus<CoreEventMap>();\n"
        },
        {
          "file_path": "core/hooks.ts",
          "purpose": "Hook registry for extension points. Allows registering sync/async hook handlers and running them with a shared context.",
          "exports": [
            "HookPoint",
            "HookContext",
            "HookHandler",
            "HookRegistry",
            "globalHooks"
          ],
          "content": "/**\n * core/hooks.ts\n *\n * Extension hook registry. Components and services may register handlers for\n * common extension points. Handlers may be synchronous or asynchronous and\n * are executed in registration order. Results are collected and returned to callers.\n *\n * Example:\n *   import { globalHooks } from '@/core/hooks'\n *   globalHooks.register('beforeApiRequest', async (ctx, payload) => { ... })\n */\n\nimport { User } from './contracts';\nimport { ApiClient } from './di';\n\n/** Supported hook names for the application */\nexport type HookPoint = 'beforeApiRequest' | 'afterApiResponse' | 'onLogin' | 'onLogout' | 'onRouteChange';\n\n/** Context available to hook handlers. Callers may pass additional properties via meta. */\nexport interface HookContext {\n  user?: User | null;\n  route?: string;\n  apiClient?: ApiClient; // optional helper for handlers that need to make API calls\n  meta?: Record<string, unknown>;\n}\n\n/** Hook handler signature. TPayload is the payload passed by the caller and TResult is the optional result type. */\nexport type HookHandler<TPayload = unknown, TResult = unknown> = (\n  ctx: HookContext,\n  payload?: TPayload\n) => TResult | Promise<TResult>;\n\n/** Registry that manages handlers for named hook points */\nexport class HookRegistry {\n  private registry: Map<HookPoint, Array<HookHandler<unknown, unknown>>> = new Map();\n\n  /** Register a handler for a hook point. Returns an unregister function. */\n  public register<TPayload = unknown, TResult = unknown>(\n    hook: HookPoint,\n    handler: HookHandler<TPayload, TResult>\n  ): () => void {\n    const list = this.registry.get(hook) ?? [];\n    list.push(handler as HookHandler<unknown, unknown>);\n    this.registry.set(hook, list);\n    return () => this.unregister(hook, handler as HookHandler<unknown, unknown>);\n  }\n\n  /** Unregister a specific handler. */\n  private unregister(hook: HookPoint, handler: HookHandler<unknown, unknown>): void {\n    const list = this.registry.get(hook);\n    if (!list) return;\n    const idx = list.indexOf(handler);\n    if (idx >= 0) list.splice(idx, 1);\n    if (list.length === 0) this.registry.delete(hook);\n  }\n\n  /** Run all handlers for a hook point. Returns results in registration order. */\n  public async run<TPayload = unknown, TResult = unknown>(\n    hook: HookPoint,\n    ctx: HookContext,\n    payload?: TPayload\n  ): Promise<Array<TResult | undefined>> {\n    const list = (this.registry.get(hook) ?? []) as Array<HookHandler<TPayload, TResult>>;\n    const results: Array<TResult | undefined> = [];\n    for (const handler of list) {\n      try {\n        // Await each handler to preserve order and allow async operations\n        // eslint-disable-next-line @typescript-eslint/await-thenable\n        const res = await handler(ctx, payload);\n        results.push(res as TResult);\n      } catch (error) {\n        // Log and continue with next handler\n        // eslint-disable-next-line no-console\n        console.error(`Hook handler failed for ${hook}:`, error);\n        results.push(undefined);\n      }\n    }\n    return results;\n  }\n\n  /** Returns number of handlers registered for a hook */\n  public count(hook: HookPoint): number {\n    return (this.registry.get(hook) ?? []).length;\n  }\n}\n\n/** Global hook registry instance used throughout the app */\nexport const globalHooks = new HookRegistry();\n"
        },
        {
          "file_path": "core/di.ts",
          "purpose": "Lightweight dependency injection container with type-safe tokens and commonly used service interfaces (ApiClient, AuthService, StorageService, WebSocketService).",
          "exports": [
            "Token",
            "createToken",
            "ApiClient",
            "AuthService",
            "StorageService",
            "WebSocketService",
            "API_CLIENT_TOKEN",
            "AUTH_SERVICE_TOKEN",
            "STORAGE_SERVICE_TOKEN",
            "WEBSOCKET_SERVICE_TOKEN",
            "Container"
          ],
          "content": "/**\n * core/di.ts\n *\n * Small, type-safe DI container and tokens for commonly used services. Tokens are\n * strongly typed to ensure compile-time safety when registering and resolving services.\n *\n * Example:\n *   import { Container, API_CLIENT_TOKEN } from '@/core/di'\n *   container.register(API_CLIENT_TOKEN, myApiClient)\n */\n\nimport { User } from './contracts';\nimport { ApiResult, Prescription, Appointment, LabResult } from './contracts';\n\n/** Opaque token type for service registration */\nexport interface Token<T> {\n  readonly key: symbol;\n  readonly description?: string;\n}\n\n/** Create a unique token for a given service type */\nexport function createToken<T>(description?: string): Token<T> {\n  return { key: Symbol(description), description };\n}\n\n/** API client interface used across the app */\nexport interface ApiClient {\n  get<T>(path: string, params?: Record<string, unknown>): Promise<ApiResult<T>>;\n  post<T, B = unknown>(path: string, body?: B): Promise<ApiResult<T>>;\n  patch<T, B = unknown>(path: string, body?: B): Promise<ApiResult<T>>;\n  delete<T>(path: string): Promise<ApiResult<T>>;\n  // Optional helper to set auth token (implementation-defined)\n  setAuthToken?(token: string | null): void;\n}\n\n/** Authentication service interface */\nexport interface AuthService {\n  login(email: string, password: string): Promise<ApiResult<{ token: string; user: User }>>;\n  logout(): Promise<void>;\n  getCurrentUser(): Promise<ApiResult<User | null>>;\n}\n\n/** Abstraction over persistent storage used by app (localStorage/sessionStorage wrappers) */\nexport interface StorageService {\n  setItem<T>(key: string, value: T): Promise<void>;\n  getItem<T>(key: string): Promise<T | null>;\n  removeItem(key: string): Promise<void>;\n}\n\n/** WebSocket service interface */\nexport interface WebSocketService {\n  connect(): Promise<void>;\n  disconnect(): Promise<void>;\n  send(event: unknown): Promise<void>;\n  isConnected(): boolean;\n}\n\n/** Common tokens used by application modules */\nexport const API_CLIENT_TOKEN = createToken<ApiClient>('API_CLIENT');\nexport const AUTH_SERVICE_TOKEN = createToken<AuthService>('AUTH_SERVICE');\nexport const STORAGE_SERVICE_TOKEN = createToken<StorageService>('STORAGE_SERVICE');\nexport const WEBSOCKET_SERVICE_TOKEN = createToken<WebSocketService>('WEBSOCKET_SERVICE');\n\n/** Simple DI container implementation. Throws on duplicate registration or missing resolution. */\nexport class Container {\n  private readonly map = new Map<symbol, unknown>();\n\n  /** Register an instance for a token. Throws if token already registered. */\n  public register<T>(token: Token<T>, instance: T): void {\n    if (this.map.has(token.key)) {\n      throw new Error(`Token already registered: ${String(token.description ?? token.key.toString())}`);\n    }\n    this.map.set(token.key, instance as unknown);\n  }\n\n  /** Resolve a registered instance. Throws if not found. */\n  public resolve<T>(token: Token<T>): T {\n    const instance = this.map.get(token.key);\n    if (instance === undefined) {\n      throw new Error(`No provider registered for token: ${String(token.description ?? token.key.toString())}`);\n    }\n    return instance as T;\n  }\n\n  /** Resolve optional: returns the instance or null when not registered. */\n  public resolveOptional<T>(token: Token<T>): T | null {\n    const instance = this.map.get(token.key);\n    return (instance as T) ?? null;\n  }\n\n  /** Clears all registered tokens. Useful for tests and reset scenarios. */\n  public clear(): void {\n    this.map.clear();\n  }\n}\n"
        },
        {
          "file_path": "core/utils.ts",
          "purpose": "Common utilities: date formatting, validation helpers, safe JSON parse/stringify, UUID generator, and debug logging utilities.",
          "exports": [
            "formatDateShort",
            "formatDateTime",
            "parseISODate",
            "validateEmail",
            "uuidv4",
            "safeJsonParse",
            "safeJsonStringify",
            "debugLog"
          ],
          "content": "/**\n * core/utils.ts\n *\n * Lightweight utilities used across the codebase. These functions are small and\n * side-effect-free (except debugLog which writes to console in development).\n */\n\nimport { isDevelopment } from '../app/config';\n\n/** Format ISO date (YYYY-MM-DD) or return empty string for invalid input */\nexport function formatDateShort(iso?: string | null): string {\n  if (!iso) return '';\n  const d = new Date(iso);\n  if (Number.isNaN(d.getTime())) return '';\n  const year = d.getUTCFullYear();\n  const month = String(d.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(d.getUTCDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\n/** Format ISO timestamp to a localized date-time string */\nexport function formatDateTime(iso?: string | null): string {\n  if (!iso) return '';\n  const d = new Date(iso);\n  if (Number.isNaN(d.getTime())) return '';\n  return d.toLocaleString();\n}\n\n/** Parse an ISO string into a Date or return null for invalid input */\nexport function parseISODate(iso?: string | null): Date | null {\n  if (!iso) return null;\n  const d = new Date(iso);\n  return Number.isNaN(d.getTime()) ? null : d;\n}\n\n/** Basic email validation used by forms */\nexport function validateEmail(email: string): boolean {\n  const re = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n  return re.test(email);\n}\n\n/** RFC4122 v4 UUID generator for client-side ids */\nexport function uuidv4(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n/** Safe JSON parse that returns null on failure */\nexport function safeJsonParse<T = unknown>(text: string | null | undefined): T | null {\n  if (text == null) return null;\n  try {\n    return JSON.parse(text) as T;\n  } catch {\n    return null;\n  }\n}\n\n/** Safe stringify that handles circular references gracefully */\nexport function safeJsonStringify(value: unknown, space?: number): string {\n  try {\n    return JSON.stringify(value, getCircularReplacer(), space);\n  } catch {\n    return String(value);\n  }\n}\n\nfunction getCircularReplacer() {\n  const seen = new WeakSet<object>();\n  return (_key: string, value: unknown) => {\n    if (typeof value === 'object' && value !== null) {\n      if (seen.has(value as object)) {\n        return '[Circular]';\n      }\n      seen.add(value as object);\n    }\n    return value;\n  };\n}\n\n/** Debug logger enabled only in development mode */\nexport function debugLog(...args: unknown[]): void {\n  if (isDevelopment) {\n    // eslint-disable-next-line no-console\n    console.debug('[HealthPortal]', ...args);\n  }\n}\n"
        }
      ],
      "usage_guidelines": [
        "Import domain types from core/contracts.ts (e.g., import { User, Appointment } from '@/core/contracts')",
        "Use AppConfig and helpers from app/config.ts for feature toggles and runtime flags (import { AppConfig, hasFeature } from '@/app/config')",
        "Use the singleton event bus for decoupled communication (import { defaultEventBus } from '@/core/events')",
        "Register extension points with the global hook registry (import { globalHooks } from '@/core/hooks')",
        "Register shared services in the DI container using tokens from core/di.ts (import { Container, API_CLIENT_TOKEN } from '@/core/di')",
        "Use core/utils.ts for small helpers like formatDateTime, uuidv4, safeJsonParse and debugLog",
        "Examples in comments show '@/core/*' import paths which align with a typical baseUrl / path alias configured in tsconfig.json"
      ]
    }
  },
  "node_id": "node_5"
}