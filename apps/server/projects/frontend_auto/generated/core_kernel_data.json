{
  "overview": "The Core Kernel provides a single source of truth for domain contracts, runtime configuration, cross-cutting utilities (events, hooks, DI) and small helpers used across all app layers. It establishes typed DTOs for healthcare domain models, a materialized runtime config built from import.meta.env, a typed event bus for decoupled communication, a plugin-friendly hook registry for extension points, a lightweight type-safe dependency injection container, and reusable utility helpers. All other sections import from these files (use @/core/* and @/app/config) so there is one stable API for features, services, providers, and UI components.",
  "files": [
    {
      "file_path": "src/core/contracts.ts",
      "purpose": "Domain types, API contracts, UI state types and WebSocket event typings for the healthcare application. This file is the canonical type library used across services, components and providers.",
      "exports": [
        "User",
        "Patient",
        "Doctor",
        "Nurse",
        "Role",
        "Appointment",
        "MedicalRecord",
        "Prescription",
        "LabResult",
        "ApiResult",
        "ApiError",
        "PaginatedResponse",
        "WebSocketEvent",
        "LoadingState",
        "FormState",
        "AuthTokens",
        "LoginPayload",
        "RegisterPayload"
      ],
      "content": "Types & Interfaces to define:\n\n- Role union and basic identity types\n  - export type Role = 'patient' | 'doctor' | 'nurse' | 'admin';\n\n- User hierarchy\n  - export interface UserBase { id: string; email: string; name: string; avatarUrl?: string; roles: Role[]; createdAt: string; updatedAt?: string; }\n  - export interface Patient extends UserBase { dob?: string; gender?: 'male' | 'female' | 'other'; medicalRecordId?: string; primaryDoctorId?: string; }\n  - export interface Doctor extends UserBase { specialty?: string; licenseNumber?: string; clinicIds?: string[]; }\n  - export interface Nurse extends UserBase { department?: string; }\n  - export type User = Patient | Doctor | Nurse | UserBase;\n\n- Healthcare domain models\n  - Appointment: id, patientId, providerId, startAt, endAt, status ('scheduled'|'cancelled'|'completed'|'no_show'), location, type ('in_person'|'telemedicine'), notes?, metadata?: Record<string, unknown>\n  - MedicalRecord: id, patientId, diagnoses: {code:string; name:string; recordedAt:string; notes?:string}[], allergies: string[], medicationsSummary?: string, entries: MedicalRecordEntry[]\n  - MedicalRecordEntry: id, type ('note'|'lab'|'imaging'|'prescription'), authorId, createdAt, data: Record<string, any>\n  - Prescription: id, patientId, prescriberId, medication: string, dose: string, frequency: string, startDate?: string, endDate?: string, instructions?:string, refills?: number\n  - LabResult: id, patientId, testName: string, orderedById?: string, specimenDate?: string, resultDate?: string, value?: string | number, unit?: string, normalRange?: string, status: 'pending'|'completed'|'cancelled', attachments?: string[]\n\n- API response types\n  - export type ApiResult<T> = { success: true; data: T; meta?: Record<string, any> };\n  - export type ApiError = { success: false; error: { code: string; message: string; details?: any } };\n  - export type PaginatedResponse<T> = ApiResult<{ items: T[]; page: number; pageSize: number; total: number }>;\n\n- Auth and payload types\n  - export interface AuthTokens { accessToken: string; refreshToken?: string; expiresAt?: string | number }\n  - export interface LoginPayload { email: string; password: string; otp?: string }\n  - export interface RegisterPayload { name: string; email: string; password: string; role?: Role }\n\n- WebSocket & real-time event types (used when websocket feature is enabled)\n  - export type WebSocketEventMap = {\n      'appointment.updated': { appointment: Appointment };\n      'labresult.created': { lab: LabResult };\n      'message.received': { fromId: string; toId: string; message: string; sentAt: string };\n      'user.status': { userId: string; online: boolean };\n    };\n  - export type WebSocketEvent<K extends keyof WebSocketEventMap = keyof WebSocketEventMap> = { type: K; payload: WebSocketEventMap[K]; ts: string };\n\n- UI state and helpers\n  - export type LoadingState = 'idle' | 'loading' | 'succeeded' | 'failed';\n  - export interface FormState<T = any> { values: T; touched: Partial<Record<string, boolean>>; errors: Partial<Record<string, string>>; isValid: boolean; isSubmitting: boolean }\n\nFunctions/utility typing patterns to export (not implementations here):\n- Use these interfaces across services and components. Example usage:\n  - import { Appointment, ApiResult } from '@/core/contracts';\n  - const result: ApiResult<Appointment> = await apiClient.get('/appointments/123');\n\nIntegration points with other kernel files:\n- src/services/apiClient.ts and src/services/authService.ts must import AuthTokens, ApiResult, ApiError and domain models.\n- WebSocket service & DI tokens (src/core/di.ts) use WebSocketEvent and WebSocketEventMap.\n- Hooks (src/core/hooks.ts) use LoginPayload and AuthTokens in their context interfaces.\n\nPatterns and conventions:\n- All date/time fields are ISO strings.\n- IDs are strings (UUID v4 recommended).\n- API result uses a boolean success flag; errors follow a consistent {code, message} shape.\n- Keep types stable; prefer adding optional fields for backwards compatibility.\n\nExample snippet (consuming code):\n- const handleLab = (evt: WebSocketEvent<'labresult.created'>) => { console.log(evt.payload.lab.testName); }\n\nNotes:\n- Add domain-specific extensions here only; UI-only types should live in src/core/ui-types.ts if needed later."
    },
    {
      "file_path": "src/app/config.ts",
      "purpose": "Materialized runtime configuration constructed from import.meta.env with typed appConfig. Exposes computed flags, feature toggles and development mock fixtures when enabled. All code must reference this central appConfig for baseUrl, feature toggles and environment flags.",
      "exports": [
        "appConfig"
      ],
      "content": "What to define and export:\n\n- Config shape (interfaces)\n  - export interface RawEnv { VITE_APP_NAME?: string; VITE_API_BASE_URL?: string; VITE_ENABLE_MOCKS?: 'true' | 'false'; VITE_NODE_ENV?: 'development' | 'production' | 'test'; VITE_FEATURES?: string /* comma separated feature keys */; VITE_WS_URL?: string; }\n  - export interface AppFeatures { appointments: boolean; prescriptions: boolean; lab_results: boolean; telemedicine: boolean; analytics: boolean; mock_data: boolean; [key: string]: boolean }\n  - export interface AppConfig { appName: string; env: 'development' | 'production' | 'test'; isDevelopment: boolean; isProduction: boolean; apiBaseUrl: string; wsUrl?: string; features: AppFeatures; enableMockData: boolean; buildTimestamp?: string; }\n\n- Materialize config using import.meta.env\n  - const raw: RawEnv = import.meta.env;\n  - Parse features from VITE_FEATURES (CSV) into AppFeatures; ensure unknown features are present as false to preserve type-safety.\n  - Compute isDevelopment = import.meta.env.MODE === 'development' || raw.VITE_NODE_ENV === 'development';\n  - enableMockData is true when VITE_ENABLE_MOCKS === 'true' OR features.mock_data is true\n\n- Provide lightweight mock fixtures (only when enableMockData true). The mock data should be small, deterministic and exported inside appConfig.mock (optional) so other modules can import appConfig.mock.userForDev.\n  - Example:\n    appConfig.mock = {\n      currentUser: { id: 'mock-patient-1', name: 'Alex Mock', email: 'alex@example.test', roles: ['patient'], createdAt: new Date().toISOString() } as Patient,\n      patients: [ ... ]\n    }\n  - Mark this mock field as present only in development builds (union type) so production bundles don't rely on it.\n\n- Example export (pseudo code):\n  - export const appConfig: AppConfig & { mock?: { currentUser?: Patient } } = { appName: ..., env: ..., isDevelopment, isProduction, apiBaseUrl, wsUrl, features, enableMockData, buildTimestamp: import.meta.env.VITE_BUILD_TIME || new Date().toISOString(), ...(enableMockData ? { mock: { currentUser: MOCK_USER } } : {}) }\n\n- Important: always read environment variables using import.meta.env not process.env. Example: const base = (import.meta.env.VITE_API_BASE_URL || window.location.origin + '/api');\n\n- Example usage patterns:\n  - import { appConfig } from '@/app/config';\n  - const url = new URL('/appointments', appConfig.apiBaseUrl).toString();\n  - if (appConfig.features.analytics) { analytics.init(...) }\n  - if (appConfig.enableMockData) { console.debug('Using mock data'); }\n\n- Integration points:\n  - src/services/apiClient.ts reads appConfig.apiBaseUrl and appConfig.enableMockData to decide whether to proxy to mock handlers.\n  - src/core/di.ts can register a MockApiClient when appConfig.enableMockData is true.\n  - Providers (AuthProvider) read appConfig.mock.currentUser for local dev login flow.\n\n- Patterns and conventions:\n  - keep appConfig immutable at runtime; export as const.\n  - prefer boolean feature flags with explicit keys rather than raw CSV usage in app logic; translate CSV to typed AppFeatures immediately on boot.\n  - when adding new feature flags, update AppFeatures type so TypeScript will require handling branches across the app.\n\n- Example feature keys used here (ensure they match your real VITE_FEATURES): 'appointments', 'prescriptions', 'lab_results', 'telemedicine', 'analytics', 'mock_data'. Replace or extend with actual config.features when available."
    },
    {
      "file_path": "src/core/utils.ts",
      "purpose": "Collection of small, well-tested utility helpers used across services, providers and UI. Keep functions pure and free of app state. Designed to be small so they are easy to test and tree-shake.",
      "exports": [
        "formatDate",
        "classNames",
        "safeJsonParse",
        "sleep",
        "buildUrl",
        "debugLog"
      ],
      "content": "Functions and signatures to implement/export:\n\n- formatDate(date: string | Date, options?: Intl.DateTimeFormatOptions, locale?: string): string\n  - Purpose: normalize ISO date strings for UI display using Intl.DateTimeFormat.\n  - Behavior: if input invalid -> return empty string. Support 'short', 'long' presets via options argument.\n  - Example: formatDate('2025-09-01T12:00:00Z', { dateStyle: 'medium' }) -> 'Sep 1, 2025'\n\n- classNames(...chunks: Array<string | Record<string, boolean> | undefined | null>): string\n  - Purpose: compact helper for conditional CSS class concatenation.\n  - Behavior: supports objects where truthy values include the key.\n  - Example: classNames('btn', { 'btn--primary': isPrimary, 'hidden': !visible })\n\n- safeJsonParse<T = any>(input: string | undefined | null, fallback?: T): T\n  - Purpose: parse JSON with try/catch, return fallback on error.\n  - Example: safeJsonParse(localStorage.getItem('foo'), {})\n\n- sleep(ms: number): Promise<void>\n  - Purpose: simple async delay used in tests and mock flows.\n\n- buildUrl(base: string, path: string, params?: Record<string, string | number | boolean | undefined>): string\n  - Purpose: safe URL builder that handles leading/trailing slashes and query params.\n  - Behavior: skip undefined values, encode params with encodeURIComponent.\n  - Example: buildUrl(appConfig.apiBaseUrl, '/appointments', { patientId: '123', page: 2 })\n\n- debugLog(namespace: string, ...args: any[]): void\n  - Purpose: dev-only console logger that respects appConfig.isDevelopment. Use minimal formatting and guard against undefined console.\n  - Implementation: check import.meta.env.MODE === 'development' and return early otherwise.\n\nPatterns and conventions:\n- Keep functions strongly typed, exported as named exports.\n- Avoid DOM access in utils; if necessary, wrap it in small helpers exported separately and used only in UI layers.\n- Unit-test each util; keep behavior deterministic (no randomization).\n\nIntegration points:\n- src/core/events.ts uses sleep and debugLog for async handler utilities.\n- src/app/config.ts may use safeJsonParse when reading local storage for persisted partial config.\n- buildUrl is used by src/services/apiClient.ts to create full endpoint URLs.\n\nExample usages:\n- import { buildUrl, safeJsonParse } from '@/core/utils';\n- const url = buildUrl(appConfig.apiBaseUrl, `/patients/${id}`);\n- const persisted = safeJsonParse<Record<string, any>>(localStorage.getItem('prefs'), {});"
    },
    {
      "file_path": "src/core/events.ts",
      "purpose": "Typed EventBus for decoupled cross-app communication. Provides on/off/emit helpers, supports both synchronous and asynchronous handlers, and delivers strong typing via an EventMap. A singleton instance is exported for general use; also provide factory to create ephemeral buses for isolated features or tests.",
      "exports": [
        "eventBus",
        "on",
        "off",
        "emit",
        "createEventBus",
        "EventBus",
        "EventMap"
      ],
      "content": "Design and types:\n\n- EventMap generic type\n  - export type EventMap = {\n      'analytics.track': { event: string; payload?: Record<string, any> };\n      'user.login': { userId: string; tokens?: AuthTokens };\n      'user.logout': { userId?: string };\n      'appointment.created': { appointmentId: string };\n      'appointment.updated': { appointmentId: string; changes?: Partial<Appointment> };\n      'labresult.completed': { labId: string };\n      // Extendable: other modules can declare module augmentation to add events\n    };\n\n- EventHandler and AsyncEventHandler types\n  - export type EventHandler<T> = (payload: T, meta?: { ts: string }) => void | Promise<void>;\n\n- EventBus class\n  - class EventBus<EM extends Record<string, any> = EventMap> {\n      private handlers: Map<keyof EM, Set<EventHandler<any>>>;\n      on<K extends keyof EM>(event: K, handler: EventHandler<EM[K]>): () => void; // registers and returns unsubscribe\n      off<K extends keyof EM>(event: K, handler?: EventHandler<EM[K]>): void; // remove handler or clear all for event\n      emit<K extends keyof EM>(event: K, payload: EM[K], options?: { async?: boolean }): Promise<void> | void; // emit either sync or async; when async true returns Promise that awaits handlers\n      clear(): void; // remove all handlers\n    }\n\n- Behavior details\n  - synchronous emit: iterate handlers in registration order and call them; any thrown error should be caught and debug-logged but not re-thrown to avoid taking down app.\n  - asynchronous emit: run handlers in sequence awaiting each (configurable) or run in parallel; default runs handlers sequentially to preserve ordering for handlers that mutate shared resources; provide option to runParallel.\n  - on returns an unsubscribe function for convenience.\n  - off without handler removes all handlers for that event.\n\n- Exports and singleton\n  - export const eventBus = createEventBus() \u2014 a default app-wide instance.\n  - also export helpers: export const on = eventBus.on.bind(eventBus), off = eventBus.off.bind(eventBus), emit = eventBus.emit.bind(eventBus)\n\n- Example usage:\n  - import { on, emit } from '@/core/events';\n  - on('user.login', async ({ userId }) => { analytics.identify(userId); await cacheWarmup(userId); });\n  - emit('user.login', { userId: 'u1', tokens: {...} }, { async: true });\n\n- Integration points:\n  - src/providers/AuthProvider.tsx should emit 'user.login' and 'user.logout' events on successful auth transitions.\n  - Analytics and telemetry services register 'analytics.track' or listen to 'appointment.created' etc.\n  - src/core/di.ts may register eventBus in the container for test injection.\n\n- Extensibility and module augmentation:\n  - Recommend allowing other modules to augment EventMap via TypeScript declaration merging (declare module '@/core/events' { interface EventMap { 'myplugin.event': { ... } } }). Document this in comments.\n\n- Implementation hints:\n  - Keep EventBus lightweight and dependency-free. Use built-in Map/Set for performance. Use debugLog from utils for dev-only diagnostics.\n  - Ensure handlers registered while emitting don't affect current emission cycle (i.e., iterate a snapshot of handlers)."
    },
    {
      "file_path": "src/core/hooks.ts",
      "purpose": "Lightweight Hook Registry for extension points and plugins. Allows modules to register functions for named HookPoints, and for consumers to run hooks in a typed, ordered way. This enables cross-cutting extensions (analytics, feature flags, request augmentation) without hard dependencies.",
      "exports": [
        "registerHook",
        "useHook",
        "HookRegistry",
        "HookPoint",
        "HookContext",
        "runHooks"
      ],
      "content": "Types & Hook points:\n\n- HookPoint union\n  - export type HookPoint = 'beforeApiRequest' | 'afterApiResponse' | 'onLogin' | 'onLogout' | 'onRouteChange' | 'onAppBoot';\n\n- Hook function signatures / context objects\n  - export interface HookContext { appConfig: import('@/app/config').AppConfig; eventBus: import('./events').EventBus; diContainer: import('./di').Container }\n  - export type HookFn<TArgs extends any[] = any[], TRet = void> = (context: HookContext, ...args: TArgs) => TRet | Promise<TRet>;\n\n- HookRegistry class\n  - class HookRegistry {\n      register<P extends HookPoint>(point: P, fn: HookFn<any, any>, priority?: number): () => void; // returns unregister\n      list<P extends HookPoint>(point: P): Array<{ fn: HookFn<any, any>; priority: number }>; // snapshot\n      run<P extends HookPoint, TArgs extends any[]>(point: P, ...args: TArgs): Promise<void>; // runs registered fns in ascending priority order; awaits each\n    }\n\n- Convenience functions\n  - export const registerHook = (point, fn, priority?) => hookRegistry.register(point, fn, priority);\n  - export const useHook = (point, fn, priority?) => { /* react hook wrapper that registers on mount & unregister on unmount */ } \u2014 note: this is a small React-aware helper that expects React available in consumer libs. If used here, type it as (point: HookPoint, fn: HookFn, priority?: number) => void.\n  - export const runHooks = (point, ...args) => hookRegistry.run(point, ...args)\n\n- Behavior & semantics\n  - Hooks are ordered by numeric priority (lower numbers run earlier). Default priority = 100.\n  - run() awaits each hook sequentially; if a hook throws, catch the error, debugLog it, and continue running subsequent hooks (so a single plugin cannot block others).\n  - Hooks should be idempotent when possible.\n\n- Standard hooks implemented and expected usage\n  - beforeApiRequest: mutate request options (headers/params), add correlation IDs, or short-circuit in dev for mocks. Example args: (request: { url: string; init?: RequestInit })\n  - afterApiResponse: inspect responses for telemetry and error normalization. Example args: (response: Response | ApiError)\n  - onLogin: called when user successfully logs in (payload: { user, tokens })\n  - onLogout: (payload: { userId?: string })\n  - onRouteChange: called with route info { from: string | null; to: string; params?: Record<string, string> }\n\n- Integration points:\n  - src/services/apiClient.ts must call runHooks('beforeApiRequest', request) before dispatching and runHooks('afterApiResponse', response) after receiving.\n  - AuthProvider triggers runHooks('onLogin', { user, tokens }) when login succeeds.\n  - Router should call runHooks('onRouteChange', { from, to }) when navigation occurs.\n  - Plugins and features register hooks using registerHook. Example: registerHook('beforeApiRequest', async (ctx, req) => { req.init.headers = { ...req.init.headers, 'X-Correlation-Id': uuid() }; });\n\n- Example usage patterns:\n  - import { registerHook } from '@/core/hooks';\n  - const unregister = registerHook('afterApiResponse', async (ctx, resp) => { if (!resp.success) await sendToErrorTracker(resp); }, 50);\n  - // unregister when plugin is removed:\n  - unregister();\n\n- Implementation notes:\n  - Keep registry small and thread-safe for single-threaded JS. Use arrays per hook point ordered by priority. When run() is invoked, operate on a shallow copy to protect against concurrent register/unregister changes during execution.\n  - Provide TypeScript-friendly overloads for register/run so hook authors get proper contextual typing when possible."
    },
    {
      "file_path": "src/core/di.ts",
      "purpose": "A minimal type-safe Dependency Injection container used to register and resolve services (ApiClient, AuthService, StorageService, WebSocketService). Designed for testability (swap implementations during tests) and plugin injection. Tokens are typed symbols to guarantee resolution correctness.",
      "exports": [
        "Container",
        "register",
        "resolve",
        "TOKENS",
        "Token"
      ],
      "content": "Key components to implement/export:\n\n- Token type & tokens registry\n  - export type Token<T> = symbol & { __type?: T } // pattern for typed tokens\n  - export const TOKENS = {\n      ApiClient: Symbol('ApiClient') as Token<ApiClientShape>,\n      AuthService: Symbol('AuthService') as Token<AuthServiceShape>,\n      StorageService: Symbol('StorageService') as Token<StorageServiceShape>,\n      WebSocketService: Symbol('WebSocketService') as Token<WebSocketServiceShape>,\n      EventBus: Symbol('EventBus') as Token<import('./events').EventBus>,\n    } as const;\n\n- Service shapes (interfaces to reference in tokens)\n  - define small shapes locally in this file to avoid circular deps (or import only types):\n    - interface ApiClientShape { get<T>(path: string, opts?: any): Promise<T>; post<T>(path: string, body?: any, opts?: any): Promise<T>; put<T>(path: string, body?: any, opts?: any): Promise<T>; del<T>(path: string, opts?: any): Promise<T>; }\n    - interface AuthServiceShape { login(payload: import('@/core/contracts').LoginPayload): Promise<{ user: import('@/core/contracts').User; tokens: import('@/core/contracts').AuthTokens }>; logout(): Promise<void>; refresh(): Promise<import('@/core/contracts').AuthTokens>; getCurrentUser(): Promise<import('@/core/contracts').User | null> }\n    - interface StorageServiceShape { get<T>(key: string): Promise<T | null> | T | null; set<T>(key: string, value: T): Promise<void> | void; remove(key: string): Promise<void> | void }\n    - interface WebSocketServiceShape { connect(): Promise<void>; disconnect(): Promise<void>; send<E extends import('@/core/contracts').WebSocketEvent>(evt: E): void; on<E extends string>(event: E, handler: (payload: any) => void): () => void }\n\n- Container class\n  - class Container {\n      private registry: Map<symbol, any>;\n      register<T>(token: Token<T>, value: T): void; // registers a singleton\n      registerFactory<T>(token: Token<T>, factory: (c: Container) => T): void; // registers lazy factory\n      resolve<T>(token: Token<T>): T; // throws if not registered\n      has(token: Token<any>): boolean;\n      reset(): void; // clear registry - useful for tests\n    }\n\n- Top-level helpers\n  - export const container = new Container();\n  - export const register = container.register.bind(container);\n  - export const resolve = container.resolve.bind(container);\n\n- Patterns & semantics\n  - Register services at app boot (src/providers/Providers.tsx or main.tsx). Example: register(TOKENS.ApiClient, apiClientInstance)\n  - Prefer registering interfaces/shapes rather than concrete classes to allow mocking in tests. For example in tests: register(TOKENS.ApiClient, mockApiClient)\n  - For services that depend on other services, use registerFactory that receives container so you can resolve dependencies lazily and avoid circular init order problems.\n  - Container.resolve must be typed: const api = resolve(TOKENS.ApiClient) as ApiClientShape \u2014 with Token<T> typing users will get correct types.\n\n- Example usage:\n  - import { TOKENS, register, resolve } from '@/core/di';\n  - // boot\n  - register(TOKENS.ApiClient, apiClientInstance);\n  - registerFactory(TOKENS.AuthService, (c) => new AuthService(c.resolve(TOKENS.ApiClient)));\n  - // usage in a module\n  - const auth = resolve(TOKENS.AuthService);\n\n- Integration points:\n  - src/services/apiClient.ts registration: register(TOKENS.ApiClient, apiClient)\n  - src/providers/AuthProvider.tsx registers/wires AuthService\n  - src/core/events.ts may register eventBus into DI so consumers can resolve the same instance\n\n- Implementation details and safety:\n  - Keep Container implementation small and synchronous. Accept both concrete instances and factory functions.\n  - Provide clear error messages when resolving unregistered tokens to ease debugging.\n  - Allow resetting container for integration tests to avoid cross-test pollution.\n\n- Testing & mocking:\n  - In jest/ vitest setups, tests can call container.reset() in beforeEach and register test doubles as needed.\n\nNote: concrete service method signatures above are intentionally minimal; actual services may expose additional helpers. Keep shapes stable to avoid breaking consumers."
    }
  ],
  "usage_guidelines": [
    "Import domain types from '@/core/contracts' across services, providers and components to keep a single canonical type source.",
    "Use import.meta.env inside src/app/config.ts when materializing runtime configuration. Do not use process.env.",
    "Register concrete implementations into the DI container at app boot (main.tsx or Providers.tsx) using TOKENS; resolve them in feature modules.",
    "Emit auth and domain events via src/core/events.eventBus; subscribe to events in analytics or cross-cutting services.",
    "Use registerHook/useHook to add extension behavior (beforeApiRequest / afterApiResponse). Ensure hooks are idempotent and use priorities to order execution.",
    "Use small pure helpers in src/core/utils.ts for formatting, class concatenation, and safe parsing. Keep these utilities free of side effects.",
    "When enableMockData is true in appConfig, use appConfig.mock fixtures and allow DI to swap ApiClient for a MockApiClient registered via TOKENS.ApiClient.",
    "Prefer runHooks('beforeApiRequest', ...) in apiClient before sending network requests to allow logging, header injection, and mock short-circuiting by plugins."
  ]
}