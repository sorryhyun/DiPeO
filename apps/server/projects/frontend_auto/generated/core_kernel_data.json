{
  "kernel": {
    "overview": "Core Kernel provides the single source of truth for domain types, runtime configuration, typed event bus, extension hooks, dependency injection tokens/container, and shared utilities. All app sections should import types and helpers from these files (e.g. import { User } from '@/core/contracts' or import { appConfig, shouldUseMockData } from '@/app/config').",
    "files": [
      {
        "file_path": "src/core/contracts.ts",
        "purpose": "Domain types, API contracts and UI state shapes used across the entire application.",
        "exports": [
          "Role",
          "UserBase",
          "Patient",
          "Doctor",
          "Nurse",
          "User",
          "Address",
          "Contact",
          "AppointmentStatus",
          "Appointment",
          "MedicalRecord",
          "MedicalRecordEntry",
          "PrescriptionStatus",
          "Prescription",
          "LabResultStatus",
          "LabResult",
          "InsuranceClaimStatus",
          "InsuranceClaim",
          "Medication",
          "MedicationReminder",
          "ApiResult",
          "ApiError",
          "PaginatedResponse",
          "Pagination",
          "WebsocketEventType",
          "WebsocketPayloadMap",
          "DomainEventPayloadMap",
          "LoadingState",
          "FormState",
          "SortDirection",
          "SortOptions"
        ],
        "content": "/**\n * core/contracts.ts\n *\n * Comprehensive domain types and API contracts used by the app.\n * Import from '@/core/contracts' across features and services.\n */\n\n/** A fine-grained role union used for auth & RBAC. */\nexport type Role = 'patient' | 'doctor' | 'nurse' | 'admin' | 'staff';\n\n/** Standard address structure used on many domain objects. */\nexport interface Address {\n  line1: string;\n  line2?: string;\n  city: string;\n  state?: string;\n  postalCode?: string;\n  country?: string;\n}\n\n/** Contact info block. */\nexport interface Contact {\n  phone?: string;\n  email?: string;\n}\n\n/** Base user shape with discriminant role for narrowings. */\nexport interface UserBase {\n  id: string;\n  createdAt: string; // ISO\n  updatedAt?: string; // ISO\n  role: Role;\n  name: string;\n  contact?: Contact;\n  avatarUrl?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/** Patient-specific fields. */\nexport interface Patient extends UserBase {\n  role: 'patient';\n  dateOfBirth?: string; // ISO\n  gender?: 'male' | 'female' | 'other' | 'undisclosed';\n  primaryPhysicianId?: string;\n  address?: Address;\n  emergencyContact?: Contact & { name?: string };\n  medicalRecordNumber?: string;\n}\n\n/** Doctor-specific fields. */\nexport interface Doctor extends UserBase {\n  role: 'doctor';\n  specialty?: string;\n  licenseNumber?: string;\n  affiliatedHospital?: string;\n  availableSlots?: string[]; // ISO datetimes\n}\n\n/** Nurse-specific fields. */\nexport interface Nurse extends UserBase {\n  role: 'nurse';\n  department?: string;\n  shift?: 'day' | 'night' | 'swing' | string;\n}\n\n/** Generic User union to represent any authenticated account. */\nexport type User = Patient | Doctor | Nurse | (UserBase & { role: Exclude<Role, 'patient' | 'doctor' | 'nurse'> });\n\n/** Standard pagination metadata. */\nexport interface Pagination {\n  page: number;\n  perPage: number;\n  total: number;\n  totalPages: number;\n}\n\n/** Paginated response wrapper. */\nexport interface PaginatedResponse<T> {\n  data: T[];\n  meta: Pagination;\n}\n\n/** Generic API result wrapper for endpoints. */\nexport interface ApiResult<T> {\n  ok: boolean;\n  data?: T;\n  error?: ApiError;\n  status: number;\n}\n\n/** A structured API error returned from server or synthesized locally. */\nexport interface ApiError {\n  code?: string;\n  message: string;\n  details?: Record<string, unknown>;\n}\n\n/** Appointment lifecycle statuses. */\nexport type AppointmentStatus = 'pending' | 'confirmed' | 'checked_in' | 'completed' | 'cancelled' | 'no_show';\n\n/** Appointment domain model. */\nexport interface Appointment {\n  id: string;\n  patientId: string;\n  providerId: string; // doctor or nurse id\n  startAt: string; // ISO datetime\n  endAt?: string; // ISO datetime\n  status: AppointmentStatus;\n  location?: string | { type: 'in_person' | 'telemedicine'; details?: string };\n  reason?: string;\n  notes?: string;\n  createdBy?: string; // user id\n  createdAt: string; // ISO\n  updatedAt?: string; // ISO\n  metadata?: Record<string, unknown>;\n}\n\n/** Single entry inside a medical record (visit, note, allergy, immunization). */\nexport interface MedicalRecordEntry {\n  id: string;\n  type: 'visit' | 'note' | 'allergy' | 'immunization' | 'lab' | 'imaging' | string;\n  title?: string;\n  notes?: string;\n  recordedAt: string; // ISO\n  recordedBy?: string; // user id\n  attachments?: Array<{ id: string; url: string; fileName?: string; contentType?: string };\n  tags?: string[];\n}\n\n/** MedicalRecord groups entries for a patient. */\nexport interface MedicalRecord {\n  id: string;\n  patientId: string;\n  entries: MedicalRecordEntry[];\n  createdAt: string;\n  updatedAt?: string;\n  version?: number;\n  metadata?: Record<string, unknown>;\n}\n\n/** Prescription lifecycle statuses. */\nexport type PrescriptionStatus = 'active' | 'expired' | 'cancelled' | 'fulfilled' | 'pending';\n\n/** Prescription model. */\nexport interface Prescription {\n  id: string;\n  patientId: string;\n  prescriberId: string;\n  medicationName: string;\n  dosage: string; // e.g., \"5 mg\"\n  instructions?: string;\n  quantity?: number;\n  refills?: number;\n  issuedAt: string; // ISO\n  expiresAt?: string; // ISO\n  status: PrescriptionStatus;\n  notes?: string;\n  pharmacy?: { name?: string; phone?: string; address?: Address };\n}\n\n/** Lab result statuses. */\nexport type LabResultStatus = 'pending' | 'completed' | 'abnormal' | 'critical';\n\n/** LabResult model. */\nexport interface LabResult {\n  id: string;\n  patientId: string;\n  orderedById?: string;\n  testName: string;\n  resultValue?: string;\n  units?: string;\n  referenceRange?: string;\n  status: LabResultStatus;\n  performedAt?: string; // ISO\n  reportedAt?: string; // ISO\n  notes?: string;\n  attachments?: Array<{ id: string; url: string; fileName?: string }>;\n}\n\n/** Insurance claim statuses. */\nexport type InsuranceClaimStatus = 'draft' | 'submitted' | 'processing' | 'paid' | 'denied' | 'rejected';\n\n/** Insurance claim model. */\nexport interface InsuranceClaim {\n  id: string;\n  patientId: string;\n  policyNumber?: string;\n  amount: number; // minor units or decimals as required by back-end\n  currency?: string;\n  items: Array<{ code?: string; description?: string; amount: number }>;\n  status: InsuranceClaimStatus;\n  submittedAt?: string;\n  processedAt?: string;\n  notes?: string;\n}\n\n/** Medication model for active meds. */\nexport interface Medication {\n  id: string;\n  patientId: string;\n  name: string;\n  dose: string;\n  frequency?: string; // e.g., \"BID\"\n  startDate?: string;\n  endDate?: string;\n  prescribingProviderId?: string;\n  active: boolean;\n  notes?: string;\n}\n\n/** Medication reminder schedule. */\nexport interface MedicationReminder {\n  id: string;\n  medicationId: string;\n  patientId: string;\n  timeOfDay: string; // HH:mm or ISO time\n  daysOfWeek?: number[]; // 0=Sun..6=Sat\n  timezone?: string;\n  enabled: boolean;\n  nextDueAt?: string; // ISO\n}\n\n/** Websocket event types used by mock socket and real socket handlers. */\nexport type WebsocketEventType =\n  | 'appointment.created'\n  | 'appointment.updated'\n  | 'appointment.cancelled'\n  | 'prescription.created'\n  | 'labresult.available'\n  | 'notification'\n  | 'user.logged_in'\n  | 'user.logged_out'\n  | 'route.changed';\n\n/** Strongly typed payload map for websocket events. */\nexport interface WebsocketPayloadMap {\n  'appointment.created': { appointment: Appointment };\n  'appointment.updated': { appointment: Appointment };\n  'appointment.cancelled': { appointmentId: string; reason?: string };\n  'prescription.created': { prescription: Prescription };\n  'labresult.available': { labResult: LabResult };\n  'notification': { id: string; title: string; body?: string; data?: Record<string, unknown> };\n  'user.logged_in': { user: User };\n  'user.logged_out': { userId: string };\n  'route.changed': { from?: string; to: string };\n}\n\n/** Domain event payload map (used by event bus). */\nexport type DomainEventPayloadMap = WebsocketPayloadMap & {\n  // future server->client events can be added here\n};\n\n/** UI Loading state helper type. */\nexport type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\n/** Generic form state for components using forms. */\nexport interface FormState<TFieldValues extends Record<string, unknown> = Record<string, unknown>> {\n  values: TFieldValues;\n  touched: Partial<Record<keyof TFieldValues, boolean>>;\n  errors: Partial<Record<keyof TFieldValues, string>>;\n  isSubmitting: boolean;\n  isValid: boolean;\n}\n\n/** Common sorting options. */\nexport type SortDirection = 'asc' | 'desc';\nexport interface SortOptions {\n  by: string;\n  direction: SortDirection;\n}\n"
      },
      {
        "file_path": "src/app/config.ts",
        "purpose": "Materialized runtime configuration: feature toggles, computed flags and mock user data for development mode.",
        "exports": [
          "AppConfig",
          "appConfig",
          "isDevelopment",
          "shouldUseMockData",
          "disableWebsocketInDev",
          "useLocalStoragePersistence",
          "features",
          "featureFlags",
          "getApiBaseUrl",
          "MockUser",
          "mockUsers"
        ],
        "content": "/**\n * app/config.ts\n *\n * Materialized application configuration and computed flags.\n * Import as: import { appConfig, shouldUseMockData } from '@/app/config'\n */\n\n/** Runtime configuration shape. Keep in sync with deployment-level config if needed. */\nexport interface AppConfig {\n  appName: string;\n  appType: 'healthcare' | string;\n  framework: 'react' | string;\n  features: string[];\n  apiBaseUrl?: string;\n  env?: 'development' | 'production' | 'test';\n  development_mode: {\n    enable_mock_data: boolean;\n    mock_auth_users: Array<{ email: string; password: string; role: 'doctor' | 'patient' | 'nurse' | string }>;\n    mock_api_endpoints: string[];\n    disable_websocket_in_dev: boolean;\n    use_localstorage_persistence: boolean;\n  };\n}\n\n/**\n * The canonical app configuration used by the running app.\n * This file materializes the configuration provided in the architecture JSON.\n */\nexport const appConfig: AppConfig = {\n  appName: 'Patient Healthcare Portal',\n  appType: 'healthcare',\n  framework: 'react',\n  features: [\n    'appointment scheduling',\n    'medical records viewer',\n    'prescription management',\n    'telemedicine interface',\n    'health metrics dashboard',\n    'lab results display',\n    'insurance claim tracker',\n    'medication reminders'\n  ],\n  apiBaseUrl: typeof process !== 'undefined' && process.env && process.env.REACT_APP_API_BASE_URL\n    ? process.env.REACT_APP_API_BASE_URL\n    : '/api',\n  env: (typeof process !== 'undefined' && (process.env.NODE_ENV as AppConfig['env'])) || 'development',\n  development_mode: {\n    enable_mock_data: true,\n    mock_auth_users: [\n      { email: 'doctor@hospital.com', password: 'doc123', role: 'doctor' },\n      { email: 'patient@email.com', password: 'patient123', role: 'patient' },\n      { email: 'nurse@hospital.com', password: 'nurse123', role: 'nurse' }\n    ],\n    mock_api_endpoints: [\n      '/api/appointments',\n      '/api/medical-records',\n      '/api/prescriptions',\n      '/api/lab-results',\n      '/api/insurance',\n      '/api/medications'\n    ],\n    disable_websocket_in_dev: true,\n    use_localstorage_persistence: true\n  }\n};\n\n/** Basic computed flags to be used by services and providers. */\nexport const isDevelopment = appConfig.env === 'development';\nexport const shouldUseMockData = isDevelopment && appConfig.development_mode.enable_mock_data === true;\nexport const disableWebsocketInDev = isDevelopment && appConfig.development_mode.disable_websocket_in_dev === true;\nexport const useLocalStoragePersistence = isDevelopment && appConfig.development_mode.use_localstorage_persistence === true;\n\n/** Features and feature flag helpers derived from the configured features list. */\nexport const features = Object.freeze([...appConfig.features]);\n\n/** Map of feature toggles for quick lookups. */\nexport const featureFlags: Readonly<Record<string, boolean>> = Object.freeze(\n  features.reduce<Record<string, boolean>>((acc, f) => {\n    acc[f] = true;\n    return acc;\n  }, {})\n);\n\n/** Resolve API base url at runtime (supports relative and absolute). */\nexport function getApiBaseUrl(): string {\n  return appConfig.apiBaseUrl ?? '/api';\n}\n\n/** Mock user type exported for services that need to seed dev mode. */\nexport interface MockUser {\n  id: string;\n  email: string;\n  password: string;\n  role: 'doctor' | 'patient' | 'nurse' | string;\n  name?: string;\n}\n\n/** Mock users - available when development_mode.enable_mock_data is true. */\nexport const mockUsers: MockUser[] = ((): MockUser[] => {\n  if (!appConfig.development_mode.enable_mock_data) return [];\n  // Materialize unique IDs and optional names for the provided mocks.\n  return appConfig.development_mode.mock_auth_users.map((u, idx) => ({\n    id: `mock-user-${idx + 1}`,\n    email: u.email,\n    password: u.password,\n    role: u.role,\n    name: u.role === 'doctor' ? 'Dr. Mock' : u.role === 'patient' ? 'Mock Patient' : 'Mock Nurse'\n  }));\n})();\n"
      },
      {
        "file_path": "src/core/events.ts",
        "purpose": "Typed, lightweight EventBus for synchronous and asynchronous domain events used across providers and features.",
        "exports": [
          "EventHandler",
          "EventMap",
          "EventKey",
          "EventBus",
          "domainEventBus",
          "DomainEventPayloadMap"
        ],
        "content": "/**\n * core/events.ts\n *\n * Lightweight typed EventBus. Use this to emit and subscribe to cross-cutting events\n * without creating tight coupling between modules.\n *\n * Example:\n *   import { domainEventBus } from '@/core/events'\n *   domainEventBus.on('appointment.created', payload => { ... })\n */\n\nimport type { DomainEventPayloadMap } from '@/core/contracts';\n\n/** Generic event handler which may return void or a Promise<void> for async processing. */\nexport type EventHandler<T> = (payload: T) => void | Promise<void>;\n\n/** EventMap is the typed DomainEventPayloadMap from core/contracts. */\nexport type EventMap = DomainEventPayloadMap;\nexport type EventKey = keyof EventMap;\n\n/**\n * EventBus - typed pub/sub implementation supporting sync and async handlers.\n */\nexport class EventBus<EM extends Record<string, unknown>> {\n  private handlers: Map<keyof EM, Set<EventHandler<unknown>>> = new Map();\n\n  /** Subscribe to an event. Returns an unsubscribe function. */\n  public on<K extends keyof EM>(event: K, handler: EventHandler<EM[K]>): () => void {\n    const set = this.handlers.get(event) ?? new Set<EventHandler<unknown>>();\n    set.add(handler as EventHandler<unknown>);\n    this.handlers.set(event, set);\n    return () => this.off(event, handler as EventHandler<unknown>);\n  }\n\n  /** Remove a previously registered handler. */\n  public off<K extends keyof EM>(event: K, handler: EventHandler<EM[K]>): void {\n    const set = this.handlers.get(event);\n    if (!set) return;\n    set.delete(handler as EventHandler<unknown>);\n    if (set.size === 0) this.handlers.delete(event);\n  }\n\n  /**\n   * Emit an event. Handlers are invoked in registration order. If any handler returns a Promise,\n   * emit returns a Promise that resolves after all handlers complete. Callers may await if they\n   * need guaranteed processing.\n   */\n  public emit<K extends keyof EM>(event: K, payload: EM[K]): Promise<void> {\n    const set = this.handlers.get(event) ?? new Set();\n    // Copy to array to avoid mutation issues during iteration\n    const handlers = Array.from(set) as Array<EventHandler<EM[K]>>;\n    const results = handlers.map(h => {\n      try {\n        return Promise.resolve(h(payload));\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    });\n    return Promise.allSettled(results).then(() => undefined);\n  }\n\n  /** Remove all handlers for an event (or all events if no key provided). */\n  public clear(event?: keyof EM): void {\n    if (event) {\n      this.handlers.delete(event);\n    } else {\n      this.handlers.clear();\n    }\n  }\n}\n\n/** Export a singleton EventBus typed for application domain events. */\nexport const domainEventBus = new EventBus<EventMap>();\n\nexport type DomainEventPayloadMap = EventMap;\n"
      },
      {
        "file_path": "src/core/hooks.ts",
        "purpose": "Hook registry / extension-point system for registering and running pluggable hooks across the app.",
        "exports": [
          "HookPoint",
          "HookContext",
          "HookHandler",
          "HookRegistry",
          "hooks"
        ],
        "content": "/**\n * core/hooks.ts\n *\n * Extension hook registry. Services and features can register to run logic at\n * predefined hook points (before API requests, after responses, on login/logout, etc.).\n *\n * Usage:\n *   import { hooks } from '@/core/hooks'\n *   hooks.register('onLogin', ctx => { ... })\n *   await hooks.run('beforeApiRequest', { url, options })\n */\n\nimport type { ApiResult, User } from '@/core/contracts';\n\n/** Named hook points used across the application. */\nexport type HookPoint =\n  | 'beforeApiRequest'\n  | 'afterApiResponse'\n  | 'onLogin'\n  | 'onLogout'\n  | 'onRouteChange'\n  | 'onSocketMessage';\n\n/** Context provided to hook handlers. Each hook gets a different shape but share this base. */\nexport interface HookContext {\n  /** UTC ISO timestamp when the hook is executed. */\n  timestamp: string;\n  /** Optional current authenticated user (if available). */\n  currentUser?: User | null;\n  /** Arbitrary metadata passed by the caller. */\n  meta?: Record<string, unknown>;\n}\n\n/** Strongly typed hook handler signature. Each handler may be sync or async. */\nexport type HookHandler<T extends HookPoint> = (\n  ctx: HookContext & { // narrow ctx for some hook points\n    // Optional extra properties for specific hooks\n    request?: T extends 'beforeApiRequest' ? { url: string; options?: RequestInit } : never;\n    response?: T extends 'afterApiResponse' ? { url: string; result: ApiResult<unknown> } : never;\n    user?: T extends 'onLogin' | 'onLogout' ? User : never;\n    route?: T extends 'onRouteChange' ? { from?: string; to: string } : never;\n    socket?: T extends 'onSocketMessage' ? { event: string; payload: unknown } : never;\n  }\n) => void | Promise<void>;\n\n/**\n * HookRegistry manages registration and execution of hook handlers.\n * Handlers execute in registration order. run() returns when all handlers complete.\n */\nexport class HookRegistry {\n  private map: Map<HookPoint, Set<HookHandler<HookPoint>>> = new Map();\n\n  /** Register a handler. Returns an unsubscribe function. */\n  public register<T extends HookPoint>(point: T, handler: HookHandler<T>): () => void {\n    const set = this.map.get(point) ?? new Set<HookHandler<HookPoint>>();\n    set.add(handler as HookHandler<HookPoint>);\n    this.map.set(point, set);\n    return () => this.unregister(point, handler as HookHandler<HookPoint>);\n  }\n\n  /** Unregister a handler. */\n  public unregister<T extends HookPoint>(point: T, handler: HookHandler<T>): void {\n    const set = this.map.get(point);\n    if (!set) return;\n    set.delete(handler as HookHandler<HookPoint>);\n    if (set.size === 0) this.map.delete(point);\n  }\n\n  /** Run all handlers for a hook point with the provided context. */\n  public async run<T extends HookPoint>(point: T, ctx: Parameters<HookHandler<T>>[0]): Promise<void> {\n    const set = this.map.get(point) ?? new Set();\n    const handlers = Array.from(set) as Array<HookHandler<T>>;\n    const tasks = handlers.map(h => {\n      try {\n        return Promise.resolve(h(ctx as any));\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    });\n    await Promise.allSettled(tasks);\n  }\n\n  /** Clear all handlers for a hook point or all points. */\n  public clear(point?: HookPoint): void {\n    if (point) this.map.delete(point);\n    else this.map.clear();\n  }\n}\n\n/** Export a shared HookRegistry singleton. */\nexport const hooks = new HookRegistry();\n"
      },
      {
        "file_path": "src/core/di.ts",
        "purpose": "Simple, typed Dependency Injection tokens and container for registering and resolving services.",
        "exports": [
          "Token",
          "TokenDescription",
          "RegistrationOptions",
          "Container",
          "container",
          "ApiClientToken",
          "AuthServiceToken",
          "StorageServiceToken",
          "WebSocketServiceToken"
        ],
        "content": "/**\n * core/di.ts\n *\n * Minimal typed DI container used across the app for resolving core services.\n * Use tokens to register implementations in app bootstrap (e.g., providers) and\n * resolve them in features/services.\n *\n * Example:\n *   container.register(ApiClientToken, { useValue: apiClient })\n *   const api = container.resolve(ApiClientToken)\n */\n\n/** Unique token wrapper for type-safe registration/resolution. */\nexport class Token<T> {\n  public readonly id: symbol;\n  public readonly description?: string;\n  constructor(description?: string) {\n    this.id = Symbol(description);\n    this.description = description;\n  }\n}\n\nexport type TokenDescription = string | undefined;\n\n/** Options used when registering a token. Either useValue or useFactory must be provided. */\nexport type RegistrationOptions<T> =\n  | { useValue: T }\n  | { useFactory: (container: Container) => T };\n\n/**\n * Container - a small registry for tokens. Not recursive by default but supports factory-based lazy registration.\n */\nexport class Container {\n  private registry = new Map<symbol, unknown>();\n  private factories = new Map<symbol, (c: Container) => unknown>();\n\n  /** Register a concrete value or factory for a token. */\n  public register<T>(token: Token<T>, options: RegistrationOptions<T>): void {\n    if ('useValue' in options) {\n      this.registry.set(token.id, options.useValue);\n    } else if ('useFactory' in options) {\n      this.factories.set(token.id, options.useFactory as (c: Container) => unknown);\n    }\n  }\n\n  /** Resolve the registered value for a token. If a factory exists it will be invoked and stored. */\n  public resolve<T>(token: Token<T>): T {\n    if (this.registry.has(token.id)) {\n      return this.registry.get(token.id) as T;\n    }\n    if (this.factories.has(token.id)) {\n      const factory = this.factories.get(token.id) as (c: Container) => T;\n      const value = factory(this);\n      this.registry.set(token.id, value as unknown);\n      this.factories.delete(token.id);\n      return value as T;\n    }\n    throw new Error(`No registration for token: ${String(token.description ?? token.id.toString())}`);\n  }\n\n  /** Check whether a token has been registered (value or factory). */\n  public isRegistered<T>(token: Token<T>): boolean {\n    return this.registry.has(token.id) || this.factories.has(token.id);\n  }\n\n  /** Clear all registrations - used in tests or when tearing down dev bootstraps. */\n  public clear(): void {\n    this.registry.clear();\n    this.factories.clear();\n  }\n}\n\n/** Application-wide container instance. Providers can register concrete implementations here. */\nexport const container = new Container();\n\n/** Well-known tokens for core services. Use these tokens when registering implementations. */\nexport const ApiClientToken = new Token<{\n  request: <T = unknown>(path: string, init?: RequestInit) => Promise<{ result: ApiClientResponse<T> }>;\n}>('ApiClient');\n\n/** Lightweight API response contract used by the token contract. */\nexport interface ApiClientResponse<T> {\n  ok: boolean;\n  status: number;\n  data?: T;\n  error?: { code?: string; message: string };\n}\n\nexport const AuthServiceToken = new Token<{\n  login: (email: string, password: string) => Promise<{ user: unknown; token?: string }>;\n  logout: () => Promise<void>;\n  getCurrentUser: () => Promise<unknown | null>;\n}>('AuthService');\n\nexport const StorageServiceToken = new Token<{\n  getItem: <T = unknown>(key: string) => T | null;\n  setItem: <T = unknown>(key: string, value: T) => void;\n  removeItem: (key: string) => void;\n}>('StorageService');\n\nexport const WebSocketServiceToken = new Token<{\n  connect: () => Promise<void>;\n  disconnect: () => Promise<void>;\n  on: <E extends string>(event: E, handler: (payload: unknown) => void) => () => void;\n  emit: (event: string, payload?: unknown) => void | Promise<void>;\n}>('WebSocketService');\n"
      },
      {
        "file_path": "src/core/utils.ts",
        "purpose": "Common utilities: date formatting, safe JSON helpers, validators and lightweight logger used across the app.",
        "exports": [
          "formatDateISO",
          "formatDateLocal",
          "formatDateHuman",
          "safeJsonParse",
          "safeJsonStringify",
          "isValidEmail",
          "uid",
          "debounce",
          "deepFreeze",
          "logger"
        ],
        "content": "/**\n * core/utils.ts\n *\n * Small collection of utility helpers used across the app. These are intentionally\n * lightweight and dependency-free so they can be used in providers, services and hooks.\n */\n\n/** Format a Date or ISO string into canonical ISO with timezone (UTC). */\nexport function formatDateISO(input?: string | Date): string {\n  const d = typeof input === 'string' ? new Date(input) : input ?? new Date();\n  return d.toISOString();\n}\n\n/** Format date in user's local timezone (YYYY-MM-DD HH:mm). */\nexport function formatDateLocal(input?: string | Date): string {\n  const d = typeof input === 'string' ? new Date(input) : input ?? new Date();\n  const y = d.getFullYear();\n  const m = String(d.getMonth() + 1).padStart(2, '0');\n  const day = String(d.getDate()).padStart(2, '0');\n  const hh = String(d.getHours()).padStart(2, '0');\n  const mm = String(d.getMinutes()).padStart(2, '0');\n  return `${y}-${m}-${day} ${hh}:${mm}`;\n}\n\n/** Friendly human date formatting (e.g. \"Aug 21, 2025\"). Not localized beyond basic format. */\nexport function formatDateHuman(input?: string | Date): string {\n  const d = typeof input === 'string' ? new Date(input) : input ?? new Date();\n  return d.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });\n}\n\n/** Safe JSON parse returning null on failure instead of throwing. */\nexport function safeJsonParse<T = unknown>(text: string | null | undefined): T | null {\n  if (text === null || text === undefined) return null;\n  try {\n    return JSON.parse(text) as T;\n  } catch (_err) {\n    return null;\n  }\n}\n\n/** Safe stringify that falls back to a replacer-friendly result on circular references. */\nexport function safeJsonStringify(value: unknown, space?: number): string {\n  const cache = new Set<unknown>();\n  return JSON.stringify(value, (_key, val) => {\n    if (typeof val === 'object' && val !== null) {\n      if (cache.has(val)) return '[Circular]';\n      cache.add(val);\n    }\n    return val;\n  }, space);\n}\n\n/** Basic email validator. */\nexport function isValidEmail(email: string): boolean {\n  if (!email) return false;\n  // conservative RFC 5322-ish regex; good enough for client-side validation\n  const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return re.test(email);\n}\n\n/** Tiny uid generator (not cryptographically secure). */\nexport function uid(prefix = ''): string {\n  const p = prefix ? `${prefix}-` : '';\n  return `${p}${Math.random().toString(36).slice(2, 9)}${Date.now().toString(36)}`;\n}\n\n/** Debounce helper for callbacks. Returns a function that cancels previous calls. */\nexport function debounce<T extends (...args: unknown[]) => void>(fn: T, wait = 200) {\n  let t: number | undefined;\n  return (...args: Parameters<T>) => {\n    if (typeof window !== 'undefined') {\n      if (t) window.clearTimeout(t);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      t = window.setTimeout(() => fn(...args), wait);\n    } else {\n      // SSR fallback: call immediately\n      fn(...args);\n    }\n  };\n}\n\n/** Deep freeze a value to make it immutable at runtime (best-effort). */\nexport function deepFreeze<T>(obj: T): T {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  Object.freeze(obj as unknown as Record<string, unknown>);\n  // freeze properties recursively\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const propNames = Object.getOwnPropertyNames(obj as any);\n  for (const name of propNames) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const value = (obj as any)[name];\n    if (typeof value === 'object' && value !== null && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  }\n  return obj;\n}\n\n/** Tiny logger wrapper that can be silenced in production. */\nexport const logger = {\n  debug: (...args: unknown[]) => {\n    if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.debug('[debug]', ...args);\n    }\n  },\n  info: (...args: unknown[]) => {\n    // eslint-disable-next-line no-console\n    console.info('[info]', ...args);\n  },\n  warn: (...args: unknown[]) => {\n    // eslint-disable-next-line no-console\n    console.warn('[warn]', ...args);\n  },\n  error: (...args: unknown[]) => {\n    // eslint-disable-next-line no-console\n    console.error('[error]', ...args);\n  }\n};\n"
      }
    ],
    "usage_guidelines": [
      "Import domain types from '@/core/contracts' (e.g., import { Appointment, User } from '@/core/contracts')",
      "Read configuration from '@/app/config' and use shouldUseMockData / featureFlags to gate dev-only features",
      "Use domainEventBus from '@/core/events' to emit and listen for cross-cutting events (always await emit() when sequential ordering is required)",
      "Register cross-cutting extension logic with hooks.register() from '@/core/hooks' (e.g., instrumentation, analytics, auth side effects)",
      "Register implementations for core services (ApiClient, AuthService, StorageService, WebSocketService) into the DI container in '@/core/di' during app bootstrap",
      "Use utility helpers from '@/core/utils' for date formatting, safe JSON handling and logging to keep behaviour consistent across modules",
      "Keep all public API surface typed and avoid relying on concrete implementations \u2014 prefer DI tokens and hook points for extension"
    ]
  },
  "inputs": {
    "kernel": {
      "overview": "Core Kernel provides the single source of truth for domain types, runtime configuration, typed event bus, extension hooks, dependency injection tokens/container, and shared utilities. All app sections should import types and helpers from these files (e.g. import { User } from '@/core/contracts' or import { appConfig, shouldUseMockData } from '@/app/config').",
      "files": [
        {
          "file_path": "src/core/contracts.ts",
          "purpose": "Domain types, API contracts and UI state shapes used across the entire application.",
          "exports": [
            "Role",
            "UserBase",
            "Patient",
            "Doctor",
            "Nurse",
            "User",
            "Address",
            "Contact",
            "AppointmentStatus",
            "Appointment",
            "MedicalRecord",
            "MedicalRecordEntry",
            "PrescriptionStatus",
            "Prescription",
            "LabResultStatus",
            "LabResult",
            "InsuranceClaimStatus",
            "InsuranceClaim",
            "Medication",
            "MedicationReminder",
            "ApiResult",
            "ApiError",
            "PaginatedResponse",
            "Pagination",
            "WebsocketEventType",
            "WebsocketPayloadMap",
            "DomainEventPayloadMap",
            "LoadingState",
            "FormState",
            "SortDirection",
            "SortOptions"
          ],
          "content": "/**\n * core/contracts.ts\n *\n * Comprehensive domain types and API contracts used by the app.\n * Import from '@/core/contracts' across features and services.\n */\n\n/** A fine-grained role union used for auth & RBAC. */\nexport type Role = 'patient' | 'doctor' | 'nurse' | 'admin' | 'staff';\n\n/** Standard address structure used on many domain objects. */\nexport interface Address {\n  line1: string;\n  line2?: string;\n  city: string;\n  state?: string;\n  postalCode?: string;\n  country?: string;\n}\n\n/** Contact info block. */\nexport interface Contact {\n  phone?: string;\n  email?: string;\n}\n\n/** Base user shape with discriminant role for narrowings. */\nexport interface UserBase {\n  id: string;\n  createdAt: string; // ISO\n  updatedAt?: string; // ISO\n  role: Role;\n  name: string;\n  contact?: Contact;\n  avatarUrl?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/** Patient-specific fields. */\nexport interface Patient extends UserBase {\n  role: 'patient';\n  dateOfBirth?: string; // ISO\n  gender?: 'male' | 'female' | 'other' | 'undisclosed';\n  primaryPhysicianId?: string;\n  address?: Address;\n  emergencyContact?: Contact & { name?: string };\n  medicalRecordNumber?: string;\n}\n\n/** Doctor-specific fields. */\nexport interface Doctor extends UserBase {\n  role: 'doctor';\n  specialty?: string;\n  licenseNumber?: string;\n  affiliatedHospital?: string;\n  availableSlots?: string[]; // ISO datetimes\n}\n\n/** Nurse-specific fields. */\nexport interface Nurse extends UserBase {\n  role: 'nurse';\n  department?: string;\n  shift?: 'day' | 'night' | 'swing' | string;\n}\n\n/** Generic User union to represent any authenticated account. */\nexport type User = Patient | Doctor | Nurse | (UserBase & { role: Exclude<Role, 'patient' | 'doctor' | 'nurse'> });\n\n/** Standard pagination metadata. */\nexport interface Pagination {\n  page: number;\n  perPage: number;\n  total: number;\n  totalPages: number;\n}\n\n/** Paginated response wrapper. */\nexport interface PaginatedResponse<T> {\n  data: T[];\n  meta: Pagination;\n}\n\n/** Generic API result wrapper for endpoints. */\nexport interface ApiResult<T> {\n  ok: boolean;\n  data?: T;\n  error?: ApiError;\n  status: number;\n}\n\n/** A structured API error returned from server or synthesized locally. */\nexport interface ApiError {\n  code?: string;\n  message: string;\n  details?: Record<string, unknown>;\n}\n\n/** Appointment lifecycle statuses. */\nexport type AppointmentStatus = 'pending' | 'confirmed' | 'checked_in' | 'completed' | 'cancelled' | 'no_show';\n\n/** Appointment domain model. */\nexport interface Appointment {\n  id: string;\n  patientId: string;\n  providerId: string; // doctor or nurse id\n  startAt: string; // ISO datetime\n  endAt?: string; // ISO datetime\n  status: AppointmentStatus;\n  location?: string | { type: 'in_person' | 'telemedicine'; details?: string };\n  reason?: string;\n  notes?: string;\n  createdBy?: string; // user id\n  createdAt: string; // ISO\n  updatedAt?: string; // ISO\n  metadata?: Record<string, unknown>;\n}\n\n/** Single entry inside a medical record (visit, note, allergy, immunization). */\nexport interface MedicalRecordEntry {\n  id: string;\n  type: 'visit' | 'note' | 'allergy' | 'immunization' | 'lab' | 'imaging' | string;\n  title?: string;\n  notes?: string;\n  recordedAt: string; // ISO\n  recordedBy?: string; // user id\n  attachments?: Array<{ id: string; url: string; fileName?: string; contentType?: string };\n  tags?: string[];\n}\n\n/** MedicalRecord groups entries for a patient. */\nexport interface MedicalRecord {\n  id: string;\n  patientId: string;\n  entries: MedicalRecordEntry[];\n  createdAt: string;\n  updatedAt?: string;\n  version?: number;\n  metadata?: Record<string, unknown>;\n}\n\n/** Prescription lifecycle statuses. */\nexport type PrescriptionStatus = 'active' | 'expired' | 'cancelled' | 'fulfilled' | 'pending';\n\n/** Prescription model. */\nexport interface Prescription {\n  id: string;\n  patientId: string;\n  prescriberId: string;\n  medicationName: string;\n  dosage: string; // e.g., \"5 mg\"\n  instructions?: string;\n  quantity?: number;\n  refills?: number;\n  issuedAt: string; // ISO\n  expiresAt?: string; // ISO\n  status: PrescriptionStatus;\n  notes?: string;\n  pharmacy?: { name?: string; phone?: string; address?: Address };\n}\n\n/** Lab result statuses. */\nexport type LabResultStatus = 'pending' | 'completed' | 'abnormal' | 'critical';\n\n/** LabResult model. */\nexport interface LabResult {\n  id: string;\n  patientId: string;\n  orderedById?: string;\n  testName: string;\n  resultValue?: string;\n  units?: string;\n  referenceRange?: string;\n  status: LabResultStatus;\n  performedAt?: string; // ISO\n  reportedAt?: string; // ISO\n  notes?: string;\n  attachments?: Array<{ id: string; url: string; fileName?: string }>;\n}\n\n/** Insurance claim statuses. */\nexport type InsuranceClaimStatus = 'draft' | 'submitted' | 'processing' | 'paid' | 'denied' | 'rejected';\n\n/** Insurance claim model. */\nexport interface InsuranceClaim {\n  id: string;\n  patientId: string;\n  policyNumber?: string;\n  amount: number; // minor units or decimals as required by back-end\n  currency?: string;\n  items: Array<{ code?: string; description?: string; amount: number }>;\n  status: InsuranceClaimStatus;\n  submittedAt?: string;\n  processedAt?: string;\n  notes?: string;\n}\n\n/** Medication model for active meds. */\nexport interface Medication {\n  id: string;\n  patientId: string;\n  name: string;\n  dose: string;\n  frequency?: string; // e.g., \"BID\"\n  startDate?: string;\n  endDate?: string;\n  prescribingProviderId?: string;\n  active: boolean;\n  notes?: string;\n}\n\n/** Medication reminder schedule. */\nexport interface MedicationReminder {\n  id: string;\n  medicationId: string;\n  patientId: string;\n  timeOfDay: string; // HH:mm or ISO time\n  daysOfWeek?: number[]; // 0=Sun..6=Sat\n  timezone?: string;\n  enabled: boolean;\n  nextDueAt?: string; // ISO\n}\n\n/** Websocket event types used by mock socket and real socket handlers. */\nexport type WebsocketEventType =\n  | 'appointment.created'\n  | 'appointment.updated'\n  | 'appointment.cancelled'\n  | 'prescription.created'\n  | 'labresult.available'\n  | 'notification'\n  | 'user.logged_in'\n  | 'user.logged_out'\n  | 'route.changed';\n\n/** Strongly typed payload map for websocket events. */\nexport interface WebsocketPayloadMap {\n  'appointment.created': { appointment: Appointment };\n  'appointment.updated': { appointment: Appointment };\n  'appointment.cancelled': { appointmentId: string; reason?: string };\n  'prescription.created': { prescription: Prescription };\n  'labresult.available': { labResult: LabResult };\n  'notification': { id: string; title: string; body?: string; data?: Record<string, unknown> };\n  'user.logged_in': { user: User };\n  'user.logged_out': { userId: string };\n  'route.changed': { from?: string; to: string };\n}\n\n/** Domain event payload map (used by event bus). */\nexport type DomainEventPayloadMap = WebsocketPayloadMap & {\n  // future server->client events can be added here\n};\n\n/** UI Loading state helper type. */\nexport type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\n/** Generic form state for components using forms. */\nexport interface FormState<TFieldValues extends Record<string, unknown> = Record<string, unknown>> {\n  values: TFieldValues;\n  touched: Partial<Record<keyof TFieldValues, boolean>>;\n  errors: Partial<Record<keyof TFieldValues, string>>;\n  isSubmitting: boolean;\n  isValid: boolean;\n}\n\n/** Common sorting options. */\nexport type SortDirection = 'asc' | 'desc';\nexport interface SortOptions {\n  by: string;\n  direction: SortDirection;\n}\n"
        },
        {
          "file_path": "src/app/config.ts",
          "purpose": "Materialized runtime configuration: feature toggles, computed flags and mock user data for development mode.",
          "exports": [
            "AppConfig",
            "appConfig",
            "isDevelopment",
            "shouldUseMockData",
            "disableWebsocketInDev",
            "useLocalStoragePersistence",
            "features",
            "featureFlags",
            "getApiBaseUrl",
            "MockUser",
            "mockUsers"
          ],
          "content": "/**\n * app/config.ts\n *\n * Materialized application configuration and computed flags.\n * Import as: import { appConfig, shouldUseMockData } from '@/app/config'\n */\n\n/** Runtime configuration shape. Keep in sync with deployment-level config if needed. */\nexport interface AppConfig {\n  appName: string;\n  appType: 'healthcare' | string;\n  framework: 'react' | string;\n  features: string[];\n  apiBaseUrl?: string;\n  env?: 'development' | 'production' | 'test';\n  development_mode: {\n    enable_mock_data: boolean;\n    mock_auth_users: Array<{ email: string; password: string; role: 'doctor' | 'patient' | 'nurse' | string }>;\n    mock_api_endpoints: string[];\n    disable_websocket_in_dev: boolean;\n    use_localstorage_persistence: boolean;\n  };\n}\n\n/**\n * The canonical app configuration used by the running app.\n * This file materializes the configuration provided in the architecture JSON.\n */\nexport const appConfig: AppConfig = {\n  appName: 'Patient Healthcare Portal',\n  appType: 'healthcare',\n  framework: 'react',\n  features: [\n    'appointment scheduling',\n    'medical records viewer',\n    'prescription management',\n    'telemedicine interface',\n    'health metrics dashboard',\n    'lab results display',\n    'insurance claim tracker',\n    'medication reminders'\n  ],\n  apiBaseUrl: typeof process !== 'undefined' && process.env && process.env.REACT_APP_API_BASE_URL\n    ? process.env.REACT_APP_API_BASE_URL\n    : '/api',\n  env: (typeof process !== 'undefined' && (process.env.NODE_ENV as AppConfig['env'])) || 'development',\n  development_mode: {\n    enable_mock_data: true,\n    mock_auth_users: [\n      { email: 'doctor@hospital.com', password: 'doc123', role: 'doctor' },\n      { email: 'patient@email.com', password: 'patient123', role: 'patient' },\n      { email: 'nurse@hospital.com', password: 'nurse123', role: 'nurse' }\n    ],\n    mock_api_endpoints: [\n      '/api/appointments',\n      '/api/medical-records',\n      '/api/prescriptions',\n      '/api/lab-results',\n      '/api/insurance',\n      '/api/medications'\n    ],\n    disable_websocket_in_dev: true,\n    use_localstorage_persistence: true\n  }\n};\n\n/** Basic computed flags to be used by services and providers. */\nexport const isDevelopment = appConfig.env === 'development';\nexport const shouldUseMockData = isDevelopment && appConfig.development_mode.enable_mock_data === true;\nexport const disableWebsocketInDev = isDevelopment && appConfig.development_mode.disable_websocket_in_dev === true;\nexport const useLocalStoragePersistence = isDevelopment && appConfig.development_mode.use_localstorage_persistence === true;\n\n/** Features and feature flag helpers derived from the configured features list. */\nexport const features = Object.freeze([...appConfig.features]);\n\n/** Map of feature toggles for quick lookups. */\nexport const featureFlags: Readonly<Record<string, boolean>> = Object.freeze(\n  features.reduce<Record<string, boolean>>((acc, f) => {\n    acc[f] = true;\n    return acc;\n  }, {})\n);\n\n/** Resolve API base url at runtime (supports relative and absolute). */\nexport function getApiBaseUrl(): string {\n  return appConfig.apiBaseUrl ?? '/api';\n}\n\n/** Mock user type exported for services that need to seed dev mode. */\nexport interface MockUser {\n  id: string;\n  email: string;\n  password: string;\n  role: 'doctor' | 'patient' | 'nurse' | string;\n  name?: string;\n}\n\n/** Mock users - available when development_mode.enable_mock_data is true. */\nexport const mockUsers: MockUser[] = ((): MockUser[] => {\n  if (!appConfig.development_mode.enable_mock_data) return [];\n  // Materialize unique IDs and optional names for the provided mocks.\n  return appConfig.development_mode.mock_auth_users.map((u, idx) => ({\n    id: `mock-user-${idx + 1}`,\n    email: u.email,\n    password: u.password,\n    role: u.role,\n    name: u.role === 'doctor' ? 'Dr. Mock' : u.role === 'patient' ? 'Mock Patient' : 'Mock Nurse'\n  }));\n})();\n"
        },
        {
          "file_path": "src/core/events.ts",
          "purpose": "Typed, lightweight EventBus for synchronous and asynchronous domain events used across providers and features.",
          "exports": [
            "EventHandler",
            "EventMap",
            "EventKey",
            "EventBus",
            "domainEventBus",
            "DomainEventPayloadMap"
          ],
          "content": "/**\n * core/events.ts\n *\n * Lightweight typed EventBus. Use this to emit and subscribe to cross-cutting events\n * without creating tight coupling between modules.\n *\n * Example:\n *   import { domainEventBus } from '@/core/events'\n *   domainEventBus.on('appointment.created', payload => { ... })\n */\n\nimport type { DomainEventPayloadMap } from '@/core/contracts';\n\n/** Generic event handler which may return void or a Promise<void> for async processing. */\nexport type EventHandler<T> = (payload: T) => void | Promise<void>;\n\n/** EventMap is the typed DomainEventPayloadMap from core/contracts. */\nexport type EventMap = DomainEventPayloadMap;\nexport type EventKey = keyof EventMap;\n\n/**\n * EventBus - typed pub/sub implementation supporting sync and async handlers.\n */\nexport class EventBus<EM extends Record<string, unknown>> {\n  private handlers: Map<keyof EM, Set<EventHandler<unknown>>> = new Map();\n\n  /** Subscribe to an event. Returns an unsubscribe function. */\n  public on<K extends keyof EM>(event: K, handler: EventHandler<EM[K]>): () => void {\n    const set = this.handlers.get(event) ?? new Set<EventHandler<unknown>>();\n    set.add(handler as EventHandler<unknown>);\n    this.handlers.set(event, set);\n    return () => this.off(event, handler as EventHandler<unknown>);\n  }\n\n  /** Remove a previously registered handler. */\n  public off<K extends keyof EM>(event: K, handler: EventHandler<EM[K]>): void {\n    const set = this.handlers.get(event);\n    if (!set) return;\n    set.delete(handler as EventHandler<unknown>);\n    if (set.size === 0) this.handlers.delete(event);\n  }\n\n  /**\n   * Emit an event. Handlers are invoked in registration order. If any handler returns a Promise,\n   * emit returns a Promise that resolves after all handlers complete. Callers may await if they\n   * need guaranteed processing.\n   */\n  public emit<K extends keyof EM>(event: K, payload: EM[K]): Promise<void> {\n    const set = this.handlers.get(event) ?? new Set();\n    // Copy to array to avoid mutation issues during iteration\n    const handlers = Array.from(set) as Array<EventHandler<EM[K]>>;\n    const results = handlers.map(h => {\n      try {\n        return Promise.resolve(h(payload));\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    });\n    return Promise.allSettled(results).then(() => undefined);\n  }\n\n  /** Remove all handlers for an event (or all events if no key provided). */\n  public clear(event?: keyof EM): void {\n    if (event) {\n      this.handlers.delete(event);\n    } else {\n      this.handlers.clear();\n    }\n  }\n}\n\n/** Export a singleton EventBus typed for application domain events. */\nexport const domainEventBus = new EventBus<EventMap>();\n\nexport type DomainEventPayloadMap = EventMap;\n"
        },
        {
          "file_path": "src/core/hooks.ts",
          "purpose": "Hook registry / extension-point system for registering and running pluggable hooks across the app.",
          "exports": [
            "HookPoint",
            "HookContext",
            "HookHandler",
            "HookRegistry",
            "hooks"
          ],
          "content": "/**\n * core/hooks.ts\n *\n * Extension hook registry. Services and features can register to run logic at\n * predefined hook points (before API requests, after responses, on login/logout, etc.).\n *\n * Usage:\n *   import { hooks } from '@/core/hooks'\n *   hooks.register('onLogin', ctx => { ... })\n *   await hooks.run('beforeApiRequest', { url, options })\n */\n\nimport type { ApiResult, User } from '@/core/contracts';\n\n/** Named hook points used across the application. */\nexport type HookPoint =\n  | 'beforeApiRequest'\n  | 'afterApiResponse'\n  | 'onLogin'\n  | 'onLogout'\n  | 'onRouteChange'\n  | 'onSocketMessage';\n\n/** Context provided to hook handlers. Each hook gets a different shape but share this base. */\nexport interface HookContext {\n  /** UTC ISO timestamp when the hook is executed. */\n  timestamp: string;\n  /** Optional current authenticated user (if available). */\n  currentUser?: User | null;\n  /** Arbitrary metadata passed by the caller. */\n  meta?: Record<string, unknown>;\n}\n\n/** Strongly typed hook handler signature. Each handler may be sync or async. */\nexport type HookHandler<T extends HookPoint> = (\n  ctx: HookContext & { // narrow ctx for some hook points\n    // Optional extra properties for specific hooks\n    request?: T extends 'beforeApiRequest' ? { url: string; options?: RequestInit } : never;\n    response?: T extends 'afterApiResponse' ? { url: string; result: ApiResult<unknown> } : never;\n    user?: T extends 'onLogin' | 'onLogout' ? User : never;\n    route?: T extends 'onRouteChange' ? { from?: string; to: string } : never;\n    socket?: T extends 'onSocketMessage' ? { event: string; payload: unknown } : never;\n  }\n) => void | Promise<void>;\n\n/**\n * HookRegistry manages registration and execution of hook handlers.\n * Handlers execute in registration order. run() returns when all handlers complete.\n */\nexport class HookRegistry {\n  private map: Map<HookPoint, Set<HookHandler<HookPoint>>> = new Map();\n\n  /** Register a handler. Returns an unsubscribe function. */\n  public register<T extends HookPoint>(point: T, handler: HookHandler<T>): () => void {\n    const set = this.map.get(point) ?? new Set<HookHandler<HookPoint>>();\n    set.add(handler as HookHandler<HookPoint>);\n    this.map.set(point, set);\n    return () => this.unregister(point, handler as HookHandler<HookPoint>);\n  }\n\n  /** Unregister a handler. */\n  public unregister<T extends HookPoint>(point: T, handler: HookHandler<T>): void {\n    const set = this.map.get(point);\n    if (!set) return;\n    set.delete(handler as HookHandler<HookPoint>);\n    if (set.size === 0) this.map.delete(point);\n  }\n\n  /** Run all handlers for a hook point with the provided context. */\n  public async run<T extends HookPoint>(point: T, ctx: Parameters<HookHandler<T>>[0]): Promise<void> {\n    const set = this.map.get(point) ?? new Set();\n    const handlers = Array.from(set) as Array<HookHandler<T>>;\n    const tasks = handlers.map(h => {\n      try {\n        return Promise.resolve(h(ctx as any));\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    });\n    await Promise.allSettled(tasks);\n  }\n\n  /** Clear all handlers for a hook point or all points. */\n  public clear(point?: HookPoint): void {\n    if (point) this.map.delete(point);\n    else this.map.clear();\n  }\n}\n\n/** Export a shared HookRegistry singleton. */\nexport const hooks = new HookRegistry();\n"
        },
        {
          "file_path": "src/core/di.ts",
          "purpose": "Simple, typed Dependency Injection tokens and container for registering and resolving services.",
          "exports": [
            "Token",
            "TokenDescription",
            "RegistrationOptions",
            "Container",
            "container",
            "ApiClientToken",
            "AuthServiceToken",
            "StorageServiceToken",
            "WebSocketServiceToken"
          ],
          "content": "/**\n * core/di.ts\n *\n * Minimal typed DI container used across the app for resolving core services.\n * Use tokens to register implementations in app bootstrap (e.g., providers) and\n * resolve them in features/services.\n *\n * Example:\n *   container.register(ApiClientToken, { useValue: apiClient })\n *   const api = container.resolve(ApiClientToken)\n */\n\n/** Unique token wrapper for type-safe registration/resolution. */\nexport class Token<T> {\n  public readonly id: symbol;\n  public readonly description?: string;\n  constructor(description?: string) {\n    this.id = Symbol(description);\n    this.description = description;\n  }\n}\n\nexport type TokenDescription = string | undefined;\n\n/** Options used when registering a token. Either useValue or useFactory must be provided. */\nexport type RegistrationOptions<T> =\n  | { useValue: T }\n  | { useFactory: (container: Container) => T };\n\n/**\n * Container - a small registry for tokens. Not recursive by default but supports factory-based lazy registration.\n */\nexport class Container {\n  private registry = new Map<symbol, unknown>();\n  private factories = new Map<symbol, (c: Container) => unknown>();\n\n  /** Register a concrete value or factory for a token. */\n  public register<T>(token: Token<T>, options: RegistrationOptions<T>): void {\n    if ('useValue' in options) {\n      this.registry.set(token.id, options.useValue);\n    } else if ('useFactory' in options) {\n      this.factories.set(token.id, options.useFactory as (c: Container) => unknown);\n    }\n  }\n\n  /** Resolve the registered value for a token. If a factory exists it will be invoked and stored. */\n  public resolve<T>(token: Token<T>): T {\n    if (this.registry.has(token.id)) {\n      return this.registry.get(token.id) as T;\n    }\n    if (this.factories.has(token.id)) {\n      const factory = this.factories.get(token.id) as (c: Container) => T;\n      const value = factory(this);\n      this.registry.set(token.id, value as unknown);\n      this.factories.delete(token.id);\n      return value as T;\n    }\n    throw new Error(`No registration for token: ${String(token.description ?? token.id.toString())}`);\n  }\n\n  /** Check whether a token has been registered (value or factory). */\n  public isRegistered<T>(token: Token<T>): boolean {\n    return this.registry.has(token.id) || this.factories.has(token.id);\n  }\n\n  /** Clear all registrations - used in tests or when tearing down dev bootstraps. */\n  public clear(): void {\n    this.registry.clear();\n    this.factories.clear();\n  }\n}\n\n/** Application-wide container instance. Providers can register concrete implementations here. */\nexport const container = new Container();\n\n/** Well-known tokens for core services. Use these tokens when registering implementations. */\nexport const ApiClientToken = new Token<{\n  request: <T = unknown>(path: string, init?: RequestInit) => Promise<{ result: ApiClientResponse<T> }>;\n}>('ApiClient');\n\n/** Lightweight API response contract used by the token contract. */\nexport interface ApiClientResponse<T> {\n  ok: boolean;\n  status: number;\n  data?: T;\n  error?: { code?: string; message: string };\n}\n\nexport const AuthServiceToken = new Token<{\n  login: (email: string, password: string) => Promise<{ user: unknown; token?: string }>;\n  logout: () => Promise<void>;\n  getCurrentUser: () => Promise<unknown | null>;\n}>('AuthService');\n\nexport const StorageServiceToken = new Token<{\n  getItem: <T = unknown>(key: string) => T | null;\n  setItem: <T = unknown>(key: string, value: T) => void;\n  removeItem: (key: string) => void;\n}>('StorageService');\n\nexport const WebSocketServiceToken = new Token<{\n  connect: () => Promise<void>;\n  disconnect: () => Promise<void>;\n  on: <E extends string>(event: E, handler: (payload: unknown) => void) => () => void;\n  emit: (event: string, payload?: unknown) => void | Promise<void>;\n}>('WebSocketService');\n"
        },
        {
          "file_path": "src/core/utils.ts",
          "purpose": "Common utilities: date formatting, safe JSON helpers, validators and lightweight logger used across the app.",
          "exports": [
            "formatDateISO",
            "formatDateLocal",
            "formatDateHuman",
            "safeJsonParse",
            "safeJsonStringify",
            "isValidEmail",
            "uid",
            "debounce",
            "deepFreeze",
            "logger"
          ],
          "content": "/**\n * core/utils.ts\n *\n * Small collection of utility helpers used across the app. These are intentionally\n * lightweight and dependency-free so they can be used in providers, services and hooks.\n */\n\n/** Format a Date or ISO string into canonical ISO with timezone (UTC). */\nexport function formatDateISO(input?: string | Date): string {\n  const d = typeof input === 'string' ? new Date(input) : input ?? new Date();\n  return d.toISOString();\n}\n\n/** Format date in user's local timezone (YYYY-MM-DD HH:mm). */\nexport function formatDateLocal(input?: string | Date): string {\n  const d = typeof input === 'string' ? new Date(input) : input ?? new Date();\n  const y = d.getFullYear();\n  const m = String(d.getMonth() + 1).padStart(2, '0');\n  const day = String(d.getDate()).padStart(2, '0');\n  const hh = String(d.getHours()).padStart(2, '0');\n  const mm = String(d.getMinutes()).padStart(2, '0');\n  return `${y}-${m}-${day} ${hh}:${mm}`;\n}\n\n/** Friendly human date formatting (e.g. \"Aug 21, 2025\"). Not localized beyond basic format. */\nexport function formatDateHuman(input?: string | Date): string {\n  const d = typeof input === 'string' ? new Date(input) : input ?? new Date();\n  return d.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });\n}\n\n/** Safe JSON parse returning null on failure instead of throwing. */\nexport function safeJsonParse<T = unknown>(text: string | null | undefined): T | null {\n  if (text === null || text === undefined) return null;\n  try {\n    return JSON.parse(text) as T;\n  } catch (_err) {\n    return null;\n  }\n}\n\n/** Safe stringify that falls back to a replacer-friendly result on circular references. */\nexport function safeJsonStringify(value: unknown, space?: number): string {\n  const cache = new Set<unknown>();\n  return JSON.stringify(value, (_key, val) => {\n    if (typeof val === 'object' && val !== null) {\n      if (cache.has(val)) return '[Circular]';\n      cache.add(val);\n    }\n    return val;\n  }, space);\n}\n\n/** Basic email validator. */\nexport function isValidEmail(email: string): boolean {\n  if (!email) return false;\n  // conservative RFC 5322-ish regex; good enough for client-side validation\n  const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return re.test(email);\n}\n\n/** Tiny uid generator (not cryptographically secure). */\nexport function uid(prefix = ''): string {\n  const p = prefix ? `${prefix}-` : '';\n  return `${p}${Math.random().toString(36).slice(2, 9)}${Date.now().toString(36)}`;\n}\n\n/** Debounce helper for callbacks. Returns a function that cancels previous calls. */\nexport function debounce<T extends (...args: unknown[]) => void>(fn: T, wait = 200) {\n  let t: number | undefined;\n  return (...args: Parameters<T>) => {\n    if (typeof window !== 'undefined') {\n      if (t) window.clearTimeout(t);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      t = window.setTimeout(() => fn(...args), wait);\n    } else {\n      // SSR fallback: call immediately\n      fn(...args);\n    }\n  };\n}\n\n/** Deep freeze a value to make it immutable at runtime (best-effort). */\nexport function deepFreeze<T>(obj: T): T {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  Object.freeze(obj as unknown as Record<string, unknown>);\n  // freeze properties recursively\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const propNames = Object.getOwnPropertyNames(obj as any);\n  for (const name of propNames) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const value = (obj as any)[name];\n    if (typeof value === 'object' && value !== null && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  }\n  return obj;\n}\n\n/** Tiny logger wrapper that can be silenced in production. */\nexport const logger = {\n  debug: (...args: unknown[]) => {\n    if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.debug('[debug]', ...args);\n    }\n  },\n  info: (...args: unknown[]) => {\n    // eslint-disable-next-line no-console\n    console.info('[info]', ...args);\n  },\n  warn: (...args: unknown[]) => {\n    // eslint-disable-next-line no-console\n    console.warn('[warn]', ...args);\n  },\n  error: (...args: unknown[]) => {\n    // eslint-disable-next-line no-console\n    console.error('[error]', ...args);\n  }\n};\n"
        }
      ],
      "usage_guidelines": [
        "Import domain types from '@/core/contracts' (e.g., import { Appointment, User } from '@/core/contracts')",
        "Read configuration from '@/app/config' and use shouldUseMockData / featureFlags to gate dev-only features",
        "Use domainEventBus from '@/core/events' to emit and listen for cross-cutting events (always await emit() when sequential ordering is required)",
        "Register cross-cutting extension logic with hooks.register() from '@/core/hooks' (e.g., instrumentation, analytics, auth side effects)",
        "Register implementations for core services (ApiClient, AuthService, StorageService, WebSocketService) into the DI container in '@/core/di' during app bootstrap",
        "Use utility helpers from '@/core/utils' for date formatting, safe JSON handling and logging to keep behaviour consistent across modules",
        "Keep all public API surface typed and avoid relying on concrete implementations \u2014 prefer DI tokens and hook points for extension"
      ]
    }
  },
  "node_id": "node_5"
}