{
  "overview": "The Core Kernel defines the single source of truth for types, runtime configuration, cross-cutting services, events, hook extension points, and commonly used utilities. All application sections (providers, services, hooks, features and UI) import contracts, flags and service tokens from these files. The kernel is intentionally small, strongly typed, and framework-agnostic beyond providing React-friendly patterns (contexts, hooks).",
  "files": [
    {
      "file_path": "src/core/contracts.ts",
      "purpose": "Domain types, TypeScript interfaces, API response contracts, shared enums and union types used across the app. Although the product is an 'Ultra-Premium Landing Page for Absolutely Nothing\u2122', the contracts include a small healthcare domain (Appointment, MedicalRecord, Prescription, LabResult) because cross-team systems may reuse these contracts. The file also exposes request/response and UI helper types.",
      "exports": [
        "Enums/Types: Role, NothingFeature, Environment",
        "Interfaces: User, Patient, Doctor, Nurse, Address, PricingTier, Testimonial, CaseStudy, NewsletterPayload",
        "Healthcare domain: Appointment, MedicalRecord, Prescription, LabResult, LabResultType",
        "API types: ApiResult<T>, ApiError, PaginatedResponse<T>, WebSocketEvent, WebSocketPayload",
        "UI types: LoadingState, FormState, PaginationParams, SortDirection, VoidSimulationState",
        "Analytics/event types: AnalyticsEvent, AnalyticsPayload"
      ],
      "content": "Specification (core/contracts.ts)\n\n1) Purpose & Conventions\n- This file contains stable type contracts consumed throughout the application. Use absolute imports: import { User } from '@/core/contracts'. Every interface is fully specified and should not contain optional 'TODO' fields. Use readonly where appropriate to denote immutability for DTOs returned from services.\n\n2) Enums & Literal Unions\n- export enum Role { NOTHING_USER = 'nothing_user', PREMIUM = 'premium_nothing', ENTERPRISE = 'enterprise_nothing', PATIENT = 'patient', DOCTOR = 'doctor', NURSE = 'nurse' }\n- export type NothingFeature =\n    | 'epic hero section with parallax void animation'\n    | 'testimonials from satisfied users of nothing'\n    | 'pricing tiers for different levels of nothing (Basic Nothing, Pro Nothing, Enterprise Nothing)'\n    | 'animated counter showing \\\"0 features delivered\\\"'\n    | 'FAQ section answering questions about nothing'\n    | 'team section showcasing experts in nothing'\n    | 'interactive void simulator'\n    | 'newsletter signup for updates about nothing'\n    | 'live chat support that provides no help'\n    | 'product comparison chart (Nothing vs Something vs Everything)'\n    | 'case studies of successful nothing implementations'\n    | 'roadmap timeline showing future nothing releases'\n    | '3D rotating nothing showcase'\n    | 'customer reviews rating nothing 5 stars'\n    | 'money-back guarantee for unsatisfied nothing users'\n    | 'affiliate program for sharing nothing'\n    | 'press kit with nothing logos and assets'\n    | 'API documentation for integrating nothing'\n    | 'status page showing 100% nothing uptime'\n    | 'cookie banner warning about nothing cookies';\n- export enum Environment { PRODUCTION = 'production', DEVELOPMENT = 'development', TEST = 'test' }\n\n3) Core user & identity models\n- export interface Address { readonly line1: string; readonly line2?: string; readonly city: string; readonly state?: string; readonly postalCode?: string; readonly country: string; }\n\n- export interface User { readonly id: string; readonly email: string; readonly displayName?: string; readonly role: Role; readonly avatarUrl?: string; readonly createdAt: string; readonly metadata?: Record<string, unknown>; }\n\n- export interface Patient extends User { readonly role: Role.PATIENT; readonly dateOfBirth?: string; readonly medicalRecordId?: string; readonly emergencyContact?: { name: string; phone?: string }; }\n\n- export interface Doctor extends User { readonly role: Role.DOCTOR; readonly specialty: string[]; readonly licenseNumber?: string; readonly clinicAddress?: Address; }\n\n- export interface Nurse extends User { readonly role: Role.NURSE; readonly department?: string; readonly shift?: 'day' | 'night' | 'swing'; }\n\n4) Healthcare domain models (complete, self-contained)\n- export type LabResultType = 'blood' | 'imaging' | 'microbiology' | 'pathology' | 'other';\n\n- export interface LabResult { readonly id: string; readonly patientId: string; readonly type: LabResultType; readonly name: string; readonly value: string; readonly unit?: string; readonly referenceRange?: string; readonly recordedAt: string; readonly comments?: string; }\n\n- export interface Prescription { readonly id: string; readonly patientId: string; readonly prescriberId: string; readonly medication: string; readonly dosage: string; readonly frequency: string; readonly directions?: string; readonly issuedAt: string; readonly expiresAt?: string; }\n\n- export interface MedicalRecord { readonly id: string; readonly patientId: string; readonly diagnoses: string[]; readonly allergies: string[]; readonly medications: readonly Prescription[]; readonly labResults: readonly LabResult[]; readonly notes?: string; readonly updatedAt: string; }\n\n- export interface Appointment { readonly id: string; readonly patientId: string; readonly practitionerId?: string; readonly practitionerType?: 'doctor' | 'nurse' | 'other'; readonly start: string; readonly end?: string; readonly location?: Address | string; readonly status: 'scheduled' | 'confirmed' | 'cancelled' | 'completed' | 'no_show'; readonly reason?: string; }\n\n5) Pricing, Testimonials, Case studies and product models\n- export interface PricingTier { readonly id: string; readonly name: 'Basic Nothing' | 'Pro Nothing' | 'Enterprise Nothing' | string; readonly priceMonthlyCents: number; readonly priceYearlyCents?: number; readonly features: readonly string[]; readonly sku?: string; readonly description?: string; }\n\n- export interface Testimonial { readonly id: string; readonly authorName: string; readonly authorTitle?: string; readonly content: string; readonly rating: 1 | 2 | 3 | 4 | 5; readonly createdAt: string; readonly avatarUrl?: string; }\n\n- export interface CaseStudy { readonly id: string; readonly title: string; readonly summary: string; readonly contentHtml?: string; readonly publishedAt?: string; readonly authors?: string[]; readonly heroImageUrl?: string; readonly metrics?: Record<string, number>; }\n\n6) Newsletter / forms / UI DTOs\n- export interface NewsletterPayload { readonly email: string; readonly name?: string; readonly source?: string; readonly consent?: boolean; }\n\n- export interface ApiError { readonly code: string; readonly message: string; readonly details?: Record<string, unknown>; }\n\n- export interface ApiResult<T> { readonly success: boolean; readonly data?: T; readonly error?: ApiError; }\n\n- export interface PaginatedResponse<T> { readonly items: T[]; readonly page: number; readonly pageSize: number; readonly totalItems: number; readonly totalPages: number; }\n\n7) WebSocket / real-time event typing\n- export type WebSocketEventType = 'chat.message' | 'chat.presence' | 'analytics.event' | 'void.animation.command' | 'status.update' | 'heartbeat';\n\n- export interface WebSocketPayload<T = unknown> { readonly event: WebSocketEventType; readonly tenant?: string; readonly timestamp: string; readonly data: T; }\n\n- export interface WebSocketEvent<T = unknown> { readonly id: string; readonly payload: WebSocketPayload<T>; readonly ack?: boolean; }\n\n8) Analytics & event contracts\n- export type AnalyticsEvent = 'page.view' | 'cta.click' | 'newsletter.signup' | 'checkout.start' | 'checkout.complete' | 'testimonial.view' | 'abtest.assign' | 'error.report' | 'void.interaction';\n\n- export interface AnalyticsPayload { readonly event: AnalyticsEvent; readonly userId?: string; readonly sessionId?: string; readonly properties?: Record<string, unknown>; readonly timestamp: string; }\n\n9) UI helper types\n- export type LoadingState = 'idle' | 'loading' | 'success' | 'error';\n\n- export interface FormState<T = Record<string, any>> { readonly values: T; readonly touched: Partial<Record<keyof T, boolean>>; readonly errors: Partial<Record<keyof T, string>>; readonly isSubmitting: boolean; }\n\n- export interface PaginationParams { readonly page?: number; readonly pageSize?: number; readonly sortBy?: string; readonly sortDir?: 'asc' | 'desc'; }\n\n- export type SortDirection = 'asc' | 'desc';\n\n10) Void simulator state\n- export interface VoidSimulationState { readonly emptiness: number; readonly blackness: number; readonly silence: number; readonly particleCount: number; readonly recursionDepth: number; readonly lastUpdatedAt?: string; }\n\n11) Examples & Integration notes\n- Example import: import { User, ApiResult, PricingTier } from '@/core/contracts';\n- Example API usage signature: async function fetchTiers(): Promise<ApiResult<PricingTier[]>>;\n- The NothingFeature union is used by app/config to compute feature toggles and by UI components for gating.\n\n12) Stability guarantee\n- Avoid changing these contracts without a major version bump. When extending, prefer adding new interfaces instead of mutating existing ones.\n"
    },
    {
      "file_path": "src/app/config.ts",
      "purpose": "Materialized application configuration built from the project JSON. Exposes a typed APP_CONFIG constant, computed runtime flags, route definitions, feature toggles, pricing constants, and (when enabled) mock user fixtures consumed by the Auth/Mock providers.",
      "exports": [
        "APP_CONFIG (typed readonly)",
        "ROUTES constant",
        "DEV_MODE object",
        "FEATURES_SET (Set<NothingFeature>)",
        "MOCK_USERS (if enabled)",
        "isFeatureEnabled helper"
      ],
      "content": "Specification (app/config.ts)\n\n1) Top-level export: APP_CONFIG\n- export interface AppConfig {\n    readonly appType: 'landing' | 'spa' | 'dashboard' | string;\n    readonly framework: 'react' | 'vue' | 'angular' | string;\n    readonly targetFramework: string;\n    readonly stylingApproach: 'tailwind' | 'css-modules' | 'styled-components' | string;\n    readonly objective: string;\n    readonly features: readonly NothingFeature[]; // import from '@/core/contracts'\n    readonly targetAudience: string;\n    readonly outputDir: string;\n    readonly developmentMode: {\n      readonly enableMockData: boolean;\n      readonly mockAuthUsers: readonly { email: string; password: string; role: Role }[];\n      readonly mockApiEndpoints: readonly string[];\n      readonly disableWebsocketInDev: boolean;\n      readonly useLocalstoragePersistence: boolean;\n    };\n    readonly promptRequirements: readonly string[];\n    readonly evaluationCriteria: readonly string[];\n    readonly promptSections: readonly string[];\n  }\n\n- Export a const APP_CONFIG: readonly AppConfig = { ... } that materializes the large JSON from the prompt exactly. Use the Role enum from '@/core/contracts' when setting role values for mockAuthUsers.\n\n2) Computed runtime flags and derived exports\n- export const ENV: Environment = (process.env.NODE_ENV === 'production') ? Environment.PRODUCTION : ((process.env.NODE_ENV === 'test') ? Environment.TEST : Environment.DEVELOPMENT);\n- export const isDevelopment = ENV === Environment.DEVELOPMENT;\n- export const shouldUseMockData = isDevelopment && APP_CONFIG.developmentMode.enableMockData;\n- export const shouldDisableWebsocket = isDevelopment && APP_CONFIG.developmentMode.disableWebsocketInDev;\n- export const useLocalStoragePersistence = isDevelopment ? !!APP_CONFIG.developmentMode.useLocalstoragePersistence : true; // production default true\n\n3) Feature toggles\n- export const FEATURES_SET: ReadonlySet<NothingFeature> = new Set(APP_CONFIG.features);\n- export function isFeatureEnabled(feature: NothingFeature): boolean { return FEATURES_SET.has(feature); }\n\n4) Routes\n- Define a typed ROUTES constant used by Router provider and links.\n\n  export const ROUTES = Object.freeze({\n    home: '/',\n    pricing: '/pricing',\n    docs: '/docs',\n    status: '/status',\n    caseStudies: '/case-studies',\n    pressKit: '/press-kit',\n    apiDocs: '/api-docs',\n    checkout: '/checkout'\n  } as const);\n\n5) Pricing constants & A/B variants placeholder\n- Provide exported pricing constants used by pricingService default tiers (values are example defaults and may be replaced by mock server responses):\n  export const DEFAULT_PRICING: readonly PricingTier[] = [\n    { id: 'tier-basic', name: 'Basic Nothing', priceMonthlyCents: 0, priceYearlyCents: 0, features: ['0 features delivered', 'Access to nothing'] },\n    { id: 'tier-pro', name: 'Pro Nothing', priceMonthlyCents: 999, priceYearlyCents: 9999, features: ['Priority nothing', 'Pro nothing support'] },\n    { id: 'tier-enterprise', name: 'Enterprise Nothing', priceMonthlyCents: 4999, priceYearlyCents: 49999, features: ['Dedicated nothing', 'Enterprise nothing SLA'] }\n  ];\n\n- Provide a small AB test variants map for pricing hero (consumed by useABTest):\n  export const AB_TESTS = Object.freeze({ pricingHero: { variants: ['A', 'B'], seeded: true } });\n\n6) Mock data exports (only when development mode enables it)\n- If APP_CONFIG.developmentMode.enableMockData is true, export MOCK_USERS array typed as readonly User[] (using User and Role from '@/core/contracts'). The mock user objects must exactly mirror the 3 entries from development_mode.mock_auth_users in the prompt. For each mock user also include id, createdAt (ISO string), displayName computed from email and role where appropriate, and metadata { mock: true }.\n\n  export const MOCK_USERS: readonly User[] = shouldUseMockData ? [\n    { id: 'mock-1', email: 'nothing@void.com', displayName: 'Nothing User', role: Role.NOTHING_USER, avatarUrl: undefined, createdAt: '2024-01-01T00:00:00.000Z', metadata: { mock: true } },\n    { id: 'mock-2', email: 'premium@void.com', displayName: 'Premium Nothing', role: Role.PREMIUM, avatarUrl: undefined, createdAt: '2024-01-02T00:00:00.000Z', metadata: { mock: true } },\n    { id: 'mock-3', email: 'enterprise@void.com', displayName: 'Enterprise Nothing', role: Role.ENTERPRISE, avatarUrl: undefined, createdAt: '2024-01-03T00:00:00.000Z', metadata: { mock: true } }\n  ] : [];\n\n- Export MOCK_API_ENDPOINTS = APP_CONFIG.developmentMode.mockApiEndpoints (readonly string[])\n\n7) DEV_MODE object\n- export const DEV_MODE = Object.freeze({ isDevelopment, shouldUseMockData, disableWebsocketInDev: APP_CONFIG.developmentMode.disableWebsocketInDev, mockApiEndpoints: APP_CONFIG.developmentMode.mockApiEndpoints.slice(), mockUsers: MOCK_USERS });\n\n8) Example usage patterns\n- import { APP_CONFIG, isFeatureEnabled, MOCK_USERS, ROUTES } from '@/app/config';\n- if (isFeatureEnabled('interactive void simulator')) { mount simulator }\n- AuthProvider should use MOCK_USERS when shouldUseMockData === true\n\n9) Integration notes\n- This file depends on types (NothingFeature, Role, PricingTier, User, Environment) from '@/core/contracts'.\n- The mock servers and providers should read MOCK_API_ENDPOINTS and DEV_MODE flags to conditionally start interception.\n\n10) Stability & mutability\n- APP_CONFIG is exported as readonly; runtime computed flags are stable values derived from process.env and APP_CONFIG. Tests may override APP_CONFIG for integration tests but production deployments should be driven by environment variables or build-time injection."
    },
    {
      "file_path": "src/core/events.ts",
      "purpose": "A lightweight, strongly-typed EventBus used for decoupled communication across providers, services and components. AnalyticsProvider, features (void animation), and support/chat systems should use the EventBus instead of direct imports to reduce coupling.",
      "exports": [
        "EventBus class (generic typed)",
        "createEventBus helper",
        "globalEventBus singleton instance",
        "EventMap interface listing all high-level events and their payload types"
      ],
      "content": "Specification (core/events.ts)\n\n1) Overview & goals\n- Provide a typed publisher/subscriber pattern. Support synchronous handlers (void return) and asynchronous handlers (Promise<void>), allow wildcards if necessary and safe one-time subscriptions.\n- Consumers use a single globalEventBus by default, but createEventBus allows feature-local buses.\n\n2) EventMap - typed map of known event names to their payloads\n- export interface EventMap {\n    'auth.logged_in': { user: User; source?: string; timestamp: string };\n    'auth.logged_out': { userId?: string; timestamp: string };\n    'analytics.event': AnalyticsPayload; // from '@/core/contracts'\n    'newsletter.signup': { payload: NewsletterPayload; result?: ApiResult<null>; timestamp: string };\n    'support.message.sent': { conversationId: string; message: string; senderId?: string; timestamp: string };\n    'support.message.received': { conversationId: string; message: string; senderId?: string; timestamp: string };\n    'pricing.tiers.updated': { tiers: PricingTier[]; source?: string; timestamp: string };\n    'void.animation.command': { command: 'start' | 'stop' | 'reset' | 'tweak'; params?: Record<string, unknown>; timestamp: string };\n    'route.change': { path: string; from?: string; to: string; params?: Record<string, string | number> };\n    'error.report': { error: ApiError | Error; context?: Record<string, unknown>; timestamp: string };\n    /* Add more events here as needed */\n  }\n\n3) Event handler types\n- export type EventHandler<E> = (payload: E) => void | Promise<void>;\n- Support: on(eventName, handler, options?: { once?: boolean; scope?: string })\n- off(eventName, handler?) to remove a specific handler; if handler omitted, remove all handlers for the event (use carefully)\n\n4) EventBus class API\n- class EventBus<EM extends Record<string, any> = EventMap> {\n    // register a handler\n    on<K extends keyof EM>(event: K, handler: EventHandler<EM[K]>, options?: { once?: boolean; priority?: number }): () => void; // returns unsubscribe\n\n    // register a one-time handler\n    once<K extends keyof EM>(event: K, handler: EventHandler<EM[K]>): () => void;\n\n    // remove a specific handler\n    off<K extends keyof EM>(event: K, handler?: EventHandler<EM[K]>): void;\n\n    // emit - supports awaiting async handlers\n    emit<K extends keyof EM>(event: K, payload: EM[K]): Promise<void> | void; // implementation should always run handlers, return Promise if any handler returns a Promise\n\n    // utility: clear all handlers\n    clear(): void;\n  }\n\n- Behavior details: handlers registered with priority (number) should run in descending order; once-handlers auto-remove after first call; emit collects return values and if any are Promises, returns Promise<void> that resolves after all handlers settled. Errors thrown by handlers should not stop other handlers; errors are caught and re-emitted as 'error.report' events on the same bus (but to avoid loops, errors from error.report are logged to console).\n\n5) createEventBus helper & singleton\n- export function createEventBus<EM extends Record<string, any> = EventMap>(): EventBus<EM>;\n- export const globalEventBus = createEventBus<EventMap>();\n\n6) Example usage\n- Import global bus: import { globalEventBus } from '@/core/events';\n- Subscribe: const unsub = globalEventBus.on('newsletter.signup', async (p) => { await analyticsService.send(...); });\n- Emit: await globalEventBus.emit('auth.logged_in', { user, source: 'mock-login', timestamp: new Date().toISOString() });\n- One-time: globalEventBus.once('route.change', (r) => console.log('First route change', r));\n\n7) Integration points\n- AnalyticsProvider subscribes to 'analytics.event' and forwards to analyticsService\n- NewsletterService emits 'newsletter.signup' on success/failure\n- Void animation features use 'void.animation.command' to coordinate start/stop/reset among lazy components\n- core/di module may register services that itself will emit start/stop lifecycle events\n\n8) Patterns & conventions\n- Prefer event namespaced keys like 'domain.action' (auth.*, pricing.*, void.*)\n- Keep EventMap canonical in this file. When features add new event names they should extend the EventMap type via module augmentation or by defining their own local EventBus with a more specific EM type.\n"
    },
    {
      "file_path": "src/core/hooks.ts",
      "purpose": "Central hook registry for extension points and plugin-style callbacks. Providers and features register callbacks to hook points like life-cycle events, API request lifecycle, auth events and route changes. HookRegistry is not the React hooks system: it is a small synchronous/async registry for named hook points.",
      "exports": [
        "HookPoint union type",
        "HookContext interfaces",
        "HookHandler generic signature types",
        "HookRegistry class with register/run methods",
        "defaultHooks instance (singleton)"
      ],
      "content": "Specification (core/hooks.ts)\n\n1) Goal & usage\n- The HookRegistry provides named extension points to allow decoupled plugins and feature modules to run code at key lifecycle moments: before/after API calls, login/logout, route changes, app mount, AB test evaluation, etc. The registry supports both synchronous and asynchronous handlers and preserves registration order by default.\n\n2) HookPoint union (standard hooks)\n- export type HookPoint =\n    | 'beforeApiRequest'\n    | 'afterApiResponse'\n    | 'onLogin'\n    | 'onLogout'\n    | 'onRouteChange'\n    | 'onAppMount'\n    | 'onABTestEvaluate'\n    | 'onBeforeCheckout'\n    | 'onAfterCheckout'\n    | 'onVoidAnimationReady';\n\n3) Hook contexts / payloads\n- export interface BeforeApiRequestContext { readonly url: string; readonly method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'; readonly headers: Record<string, string>; readonly body?: unknown; readonly meta?: Record<string, unknown>; mutable?: boolean; }\n\n- export interface AfterApiResponseContext { readonly url: string; readonly method: string; readonly status: number; readonly response: unknown; readonly elapsedMs?: number; readonly meta?: Record<string, unknown>; }\n\n- export interface AuthContext { readonly user?: User; readonly source?: string; readonly timestamp: string; }\n\n- export interface RouteChangeContext { readonly from?: string; readonly to: string; readonly params?: Record<string, string | number>; }\n\n- export interface ABTestEvaluateContext { readonly testKey: string; readonly userId?: string; readonly assignedVariant?: string | null; }\n\n- export interface VoidAnimationContext { readonly sceneId?: string; readonly readyAt?: string; readonly props?: Record<string, unknown>; }\n\n- export type HookContext = BeforeApiRequestContext | AfterApiResponseContext | AuthContext | RouteChangeContext | ABTestEvaluateContext | VoidAnimationContext;\n\n4) Hook handler signature\n- export type HookHandler<C = HookContext> = (ctx: C) => void | Promise<void>;\n\n5) HookRegistry API\n- class HookRegistry {\n    // register a handler for a named hook point\n    register<T extends HookPoint>(hook: T, handler: HookHandler<any>, options?: { once?: boolean; priority?: number; id?: string }): { id: string; unregister: () => void };\n\n    // run all handlers for a hook point; returns Promise<void> that resolves when all handlers settled\n    run<T extends HookPoint>(hook: T, ctx: Extract<HookContext, any>): Promise<void>;\n\n    // utility to clear handlers for a hook or globally\n    clear(hook?: HookPoint): void;\n  }\n\n- Implementation details (spec-level): registry stores handlers in arrays per hook, ordered by priority desc, then registration order. run should catch handler errors and emit them to globalEventBus as 'error.report' (import '@/core/events'). run returns Promise<void> and will wait for all handlers.\n\n6) Singleton & creation helper\n- export const defaultHooks = new HookRegistry();\n- export function createHookRegistry(): HookRegistry; // for isolated registries\n\n7) Standard hook usage patterns\n- API client behavior: before each network request call defaultHooks.run('beforeApiRequest', { url, method, headers, body }) to allow hooks to modify headers or attach auth tokens; after response call 'afterApiResponse'.\n- AuthProvider calls defaultHooks.run('onLogin', { user, timestamp }) and on logout runs 'onLogout'.\n- Router provider calls defaultHooks.run('onRouteChange', { from, to, params }) on navigation.\n- ABTest provider calls defaultHooks.run('onABTestEvaluate', { testKey, userId, assignedVariant }) to allow experiment listeners to observe assignments.\n\n8) Example code (consumer)\n- Registering a hook: defaultHooks.register('onLogin', async (ctx: AuthContext) => { await analytics.send({ event: 'auth.login', userId: ctx.user?.id, timestamp: ctx.timestamp }); }, { priority: 10 });\n- Running hooks inside apiClient: await defaultHooks.run('beforeApiRequest', { url, method, headers, body });\n\n9) Integration notes\n- The HookRegistry intentionally references core/events for error forwarding but remains independent otherwise. Services, providers, and features must import defaultHooks from '@/core/hooks'.\n"
    },
    {
      "file_path": "src/core/di.ts",
      "purpose": "A small, type-safe dependency injection container used to register and resolve cross-cutting services (ApiClient, AuthService, StorageService, WebSocketService, AnalyticsService, VoidAnimationService, PricingService). It supports singleton and transient lifetimes and typed tokens for compile-time safety.",
      "exports": [
        "Token<T> type alias and createToken helper",
        "ServiceToken constants: API_CLIENT_TOKEN, AUTH_SERVICE_TOKEN, STORAGE_SERVICE_TOKEN, WEBSOCKET_SERVICE_TOKEN, ANALYTICS_SERVICE_TOKEN, VOID_ANIMATION_SERVICE_TOKEN, PRICING_SERVICE_TOKEN",
        "Container class (registerSingleton, registerFactory, resolve, has)",
        "defaultContainer instance"
      ],
      "content": "Specification (core/di.ts)\n\n1) Goals & design\n- Provide a lightweight DI container that uses Symbols as opaque tokens. The container supports typed registration and resolution so callers get correct TypeScript types. Avoid complex features: no circular resolution protection beyond basic checks, no auto-mocking. Providers and app bootstrap register concrete implementations into the defaultContainer.\n\n2) Token type & helper\n- export type Token<T> = { readonly key: symbol; readonly __type?: T }; // opaque\n- export function createToken<T>(description: string): Token<T> { return { key: Symbol(description) } as Token<T>; }\n\n3) Predefined service tokens\n- export const API_CLIENT_TOKEN = createToken<ApiClient>('API_CLIENT');\n- export const AUTH_SERVICE_TOKEN = createToken<AuthService>('AUTH_SERVICE');\n- export const STORAGE_SERVICE_TOKEN = createToken<StorageService>('STORAGE_SERVICE');\n- export const WEBSOCKET_SERVICE_TOKEN = createToken<WebSocketService>('WEBSOCKET_SERVICE');\n- export const ANALYTICS_SERVICE_TOKEN = createToken<AnalyticsService>('ANALYTICS_SERVICE');\n- export const VOID_ANIMATION_SERVICE_TOKEN = createToken<VoidAnimationService>('VOID_ANIMATION_SERVICE');\n- export const PRICING_SERVICE_TOKEN = createToken<PricingService>('PRICING_SERVICE');\n\n// Note: ApiClient/AuthService/StorageService etc. are interface shapes described below - they're not runtime classes. Define interfaces in this file to ensure type safety across modules.\n\n4) Service interface shapes (minimal, concrete signatures)\n- export interface ApiClient { get<T>(url: string, opts?: Record<string, unknown>): Promise<ApiResult<T>>; post<T>(url: string, body?: unknown, opts?: Record<string, unknown>): Promise<ApiResult<T>>; put<T>(url: string, body?: unknown, opts?: Record<string, unknown>): Promise<ApiResult<T>>; del<T>(url: string, opts?: Record<string, unknown>): Promise<ApiResult<T>>; }\n\n- export interface AuthService { getCurrentUser(): Promise<User | null>; login(email: string, password: string): Promise<ApiResult<User>>; logout(): Promise<ApiResult<null>>; onAuthChange(handler: (user: User | null) => void): () => void; }\n\n- export interface StorageService { get<T>(key: string): Promise<T | null>; set<T>(key: string, value: T): Promise<void>; remove(key: string): Promise<void>; }\n\n- export interface WebSocketService { connect(url: string): Promise<void>; disconnect(): Promise<void>; send<T>(payload: WebSocketPayload<T>): Promise<void>; on<T>(event: WebSocketEventType, handler: (payload: WebSocketPayload<T>) => void): () => void; isConnected(): boolean; }\n\n- export interface AnalyticsService { sendEvent(event: AnalyticsPayload): Promise<void>; flush(): Promise<void>; }\n\n- export interface VoidAnimationService { start(sceneId?: string): Promise<void>; stop(sceneId?: string): Promise<void>; reset(sceneId?: string): Promise<void>; tweak(params: Record<string, unknown>): Promise<void>; onReady(handler: (ctx: VoidAnimationContext) => void): () => void; }\n\n- export interface PricingService { getTiers(): Promise<PricingTier[]>; calculateSavings(tierId: string): number; }\n\n5) Container API\n- class Container {\n    registerSingleton<T>(token: Token<T>, instance: T): void;\n    registerFactory<T>(token: Token<T>, factory: (c: Container) => T): void; // factory invoked once lazily\n    resolve<T>(token: Token<T>): T; // throws if not registered\n    tryResolve<T>(token: Token<T>): T | undefined; // returns undefined instead of throwing\n    has(token: Token<any>): boolean;\n    clear(): void; // remove all registrations\n  }\n\n- Behavior: registerSingleton stores instance; registerFactory stores factory and invokes it on first resolve; resolve caches factory result. register* throws if token already registered.\n\n6) defaultContainer singleton\n- export const defaultContainer = new Container();\n- Bootstrap Example: defaultContainer.registerSingleton(API_CLIENT_TOKEN, apiClientImplementation);\n\n7) Example usage\n- Registering services in main bootstrap:\n  import { defaultContainer, API_CLIENT_TOKEN, AUTH_SERVICE_TOKEN } from '@/core/di';\n  defaultContainer.registerSingleton(API_CLIENT_TOKEN, apiClientInstance);\n  defaultContainer.registerFactory(AUTH_SERVICE_TOKEN, (c) => new AuthServiceImpl(c.resolve(API_CLIENT_TOKEN)) );\n\n- Resolving in a feature or provider:\n  const auth = defaultContainer.resolve(AuthServiceToken) // typed AuthService\n\n8) Integration notes\n- core/events.ts-based modules can be registered with DI tokens (e.g., analyticsService can be resolved and will subscribe to globalEventBus during its constructor or factory invocation).\n- This DI is intentionally minimal to remain framework-agnostic. React providers may also wrap container.resolve to expose service instances via Contexts.\n\n9) Concurrency / safety\n- Container does not attempt to manage asynchronous resolution or circular dependency graphs. For complex setups, register envelopes or factories that accept the container to lazily resolve dependencies.\n"
    },
    {
      "file_path": "src/core/utils.ts",
      "purpose": "Common utilities and helpers used across the application: formatters, safe JSON helpers, fetch wrapper with timeout and consistent ApiResult shape, classNames helper, debounce/throttle/clamp, feature gating helpers, debug logger. Export small, focused functions with minimal runtime footprint.",
      "exports": [
        "formatDate, formatRelativeDate",
        "clamp, debounce, throttle",
        "safeJsonParse, safeJsonStringify",
        "safeFetch wrapper returning ApiResult<T>",
        "cn (classNames helper)",
        "debugLog helper",
        "isBrowser, nowISO helpers",
        "isFeatureEnabled (wrapper that proxies to '@/app/config')"
      ],
      "content": "Specification (core/utils.ts)\n\n1) Environment helpers\n- export const isBrowser: boolean; // true when typeof window !== 'undefined'\n- export function nowISO(): string; // new Date().toISOString()\n\n2) Date formatting helpers\n- export function formatDate(iso: string, options?: { locale?: string; dateStyle?: 'short' | 'medium' | 'long' | 'full'; timeStyle?: 'short' | 'medium' | 'long' }): string;\n  // Use Intl.DateTimeFormat under the hood. If Intl not available, fallback to substring operations.\n\n- export function formatRelativeDate(iso: string, locale?: string): string; // e.g., '3 hours ago', 'in 2 days' - reasonable deterministic implementation using difference of now vs date.\n\n3) Math / util small helpers\n- export function clamp(value: number, min: number, max: number): number;\n- export function debounce<T extends (...args: any[]) => any>(fn: T, waitMs?: number, immediate?: boolean): T & { cancel(): void };\n- export function throttle<T extends (...args: any[]) => any>(fn: T, limitMs?: number): T & { cancel(): void };\n\n4) Safe JSON helpers\n- export function safeJsonParse<T = any>(text: string, fallback?: T): T; // returns fallback on parse error\n- export function safeJsonStringify(value: unknown, fallback?: string): string; // returns fallback if circular or other error\n\n5) Classnames helper\n- export function cn(...args: Array<string | false | null | undefined | Record<string, boolean | undefined>>): string;\n  // Accept strings, falsy values, and object maps like: cn('a', { 'b': true, 'c': false }) => 'a b'\n\n6) Debug logging\n- export function debugLog(namespace: string, ...args: any[]): void;\n  // logs only when process.env.NODE_ENV !== 'production' or when a global DEBUG flag enabled. Should include timestamp via nowISO(). Keep side effects minimal.\n\n7) safeFetch wrapper & ApiResult normalization\n- export type FetchOptions = { timeoutMs?: number; headers?: Record<string, string>; handleErrors?: boolean; parseJson?: boolean };\n\n- export async function safeFetch<T = unknown>(url: string, opts?: RequestInit & FetchOptions): Promise<ApiResult<T>>;\n  // Behavior:\n  //  - Applies timeoutMs to reject if network exceeds timeout\n  //  - Adds Accept: 'application/json' header by default when parseJson is true\n  //  - Returns ApiResult<T> consistent with core/contracts.ts\n  //  - On HTTP 4xx/5xx returns success:false and an ApiError with code like 'http_404' and message = response text (or parsed error)\n  //  - Catches network errors and returns ApiResult with error { code: 'network_error', message: e.message }\n\n- Example usage: const r = await safeFetch<PricingTier[]>('/api/pricing/nothing', { method: 'GET', timeoutMs: 5000 }); if (r.success) { /* use r.data */ }\n\n8) Feature gate helper (wraps app/config)\n- export function isFeatureEnabled(feature: NothingFeature): boolean; // re-export or proxy to '@/app/config' isFeatureEnabled. This keeps components able to import from '@/core/utils' for convenience. Implementation should import the canonical isFeatureEnabled from '@/app/config'.\n\n9) Small helpers for class and string transformations\n- export function toKebabCase(s: string): string;\n- export function uid(prefix?: string): string; // small uid generator: prefix + random hex\n\n10) Example usage & integration\n- apiClient uses safeFetch to implement get/post helpers.\n- UI components use cn for conditional classNames.\n- Logging and debugging utilities used by dev tools and services.\n\n11) Performance & footprint\n- Keep implementations small and tree-shakable. Avoid pulling heavy dependencies.\n\n12) Error handling contract\n- All helpers that may throw should document behavior clearly. safeFetch should never throw for network errors (it returns ApiResult with an error). Other helpers (formatDate) may throw only if passed invalid inputs; prefer safe, non-throwing implementations when possible.\n"
    }
  ],
  "usage_guidelines": [
    "Import domain types from '@/core/contracts' \u2014 these are the canonical DTOs used across services, providers and components. Do not duplicate types elsewhere.",
    "Read runtime flags and feature toggles from '@/app/config'. Feature gating must consult isFeatureEnabled(...) before rendering heavy widgets/animations.",
    "Use globalEventBus from '@/core/events' for decoupled communication. Avoid direct references between feature modules; prefer events and DI tokens.",
    "Register cross-cutting services (ApiClient, AuthService, AnalyticsService, VoidAnimationService) in the defaultContainer from '@/core/di' during bootstrap (src/main.tsx). Resolve them in providers or features via defaultContainer.resolve(token).",
    "Hook points in '@/core/hooks' are the sanctioned extension points for lifecycle tasks (beforeApiRequest, afterApiResponse, onLogin, onLogout, onRouteChange, onAppMount). Register handlers during provider bootstrap; run hooks from apiClient, Router and providers.",
    "Use utilities from '@/core/utils' for safeFetch, classNames (cn), debounce/throttle, and feature-enabled checks. Keep UI components side-effect free; use safeFetch to wrap network calls.",
    "When adding new global events or hooks, extend EventMap or HookPoint in the respective core files. For feature-local events/hook types prefer creating a local EventBus or HookRegistry via createEventBus/createHookRegistry to keep global contracts stable.",
    "Mock data and endpoints: when APP_CONFIG.developmentMode.enableMockData is true, providers should use the exported MOCK_USERS and mock endpoints from '@/app/config' to wire MockApiProvider and AuthProvider without production side effects.",
    "Prefer typed tokens from '@/core/di' (e.g., API_CLIENT_TOKEN) rather than raw strings to avoid naming collisions and to retain compile-time safety.",
    "Keep core files stable \u2013 any change that alters contracts should be considered a breaking change and must be coordinated across features."
  ]
}