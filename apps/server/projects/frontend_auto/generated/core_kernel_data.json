{
  "overview": "The Core Kernel provides a small, well-typed foundation shared by every part of the app: a single source of truth for domain contracts (types), a materialized runtime config (import.meta.env), a typed event bus, a hook registry for extension points, a compact dependency-injection container (tokens + container), and a set of common utilities. All features, providers and UI components should import from these kernel files (e.g. import { User } from '@/core/contracts'), use the event bus for cross-cutting notifications and analytics, register extension hooks when needed, and resolve cross-cutting services through the DI container for testability.",
  "files": [
    {
      "file_path": "src/core/contracts.ts",
      "purpose": "Domain types, API request/response contracts and shared TypeScript interfaces used across the app (users, healthcare models, API result shapes, UI helpers). This file is the canonical type source for services, components and providers.",
      "exports": [
        "User",
        "Patient",
        "Doctor",
        "Nurse",
        "Role",
        "Appointment",
        "MedicalRecord",
        "Prescription",
        "LabResult",
        "ApiResult",
        "ApiError",
        "PaginatedResponse",
        "WsEvent",
        "WsPayload",
        "LoadingState",
        "FormState",
        "RouteMeta"
      ],
      "content": "Types & interfaces to define\n- Role union: 'admin' | 'doctor' | 'nurse' | 'patient' | 'staff'\n- User base interface: id, email, name, avatarUrl?, roles: Role[], createdAt, updatedAt\n- Patient: extends User with patientId, dob?, primaryPhysicianId?, demographics (address, phone)\n- Doctor: extends User with licenseNumber, specialty[], clinicIds[]\n- Nurse: extends User with licenseNumber, assignedUnit?\n\nHealthcare domain models\n- Appointment: id, patientId, providerId, startAt (ISO), endAt (ISO) | null, status: 'scheduled'|'checked_in'|'completed'|'cancelled', reason?, location?, metadata?: Record<string, unknown>\n- MedicalRecord: id, patientId, createdById, createdAt, type: 'note'|'diagnosis'|'imaging'|'lab', payload: Record<string, any>, tags?: string[]\n- Prescription: id, patientId, prescriberId, medication: { name:string; dosage:string; frequency:string }, instructions?: string, startAt?: string, endAt?: string, refills?: number\n- LabResult: id, patientId, testName, resultValue: string | number, unit?: string, referenceRange?: string, collectedAt?: string, reportedAt?: string, status: 'pending'|'final'|'amended'\n\nAPI & pagination shapes\n- ApiResult<T>: { success: boolean; data?: T; error?: ApiError }\n- ApiError: { code?: string; status?: number; message: string; details?: Record<string, any> }\n- PaginatedResponse<T>: { items: T[]; page: number; perPage: number; total: number }\n\nWebSocket event types (if websocket.enabled)\n- WsEvent generic discriminated union: 'appointment.updated' | 'appointment.created' | 'lab.result' | 'message' | 'system.notify' etc.\n- WsPayload<T> generic mapping from WsEvent to concrete payload types, e.g., appointment.updated => Appointment\n\nCommon UI types\n- LoadingState = 'idle' | 'loading' | 'success' | 'error'\n- FormState<T> = { values: T; touched: Partial<Record<keyof T, boolean>>; errors: Partial<Record<keyof T, string>> }\n- RouteMeta = { title?: string; requiresAuth?: boolean; rolesAllowed?: Role[]; layout?: 'main'|'auth' }\n\nPatterns and conventions\n- Keep domain models normalized: reference other entities by id instead of embedding large nested objects in API returns (services may provide include params to expand in fetchers).\n- Use ISO 8601 strings for dates across all models. Convert to Date objects in UI helper layers if required.\n- When adding new roles or WsEvent variants, extend the unions here so TypeScript will protect call sites across the app.\n\nExample usage\n- Component typing: import { User, Appointment } from '@/core/contracts'\n- API response: const resp: ApiResult<PaginatedResponse<Appointment>> = await apiClient.get('/appointments?page=1')\n- Hook: runHook('afterApiResponse', { url, method, response }) where response typed as ApiResult<any>\n\nIntegration points\n- services/auth.ts and services/api.ts import and use User/Auth tokens defined here.\n- state/store.ts references Role and RouteMeta.\n- WebSocket service maps incoming event.type to WsEvent and uses WsPayload typed mapping."
    },
    {
      "file_path": "src/app/config.ts",
      "purpose": "Materialized runtime configuration using import.meta.env; exposes typed config values (API base URL, feature flags, analytics key). Also computes environment flags and optionally supplies mock data for development.",
      "exports": [
        "AppConfig",
        "config"
      ],
      "content": "AppConfig interface\n- env: 'development' | 'staging' | 'production'\n- apiBaseUrl: string\n- socketUrl?: string\n- appName: string\n- analytics: { enabled: boolean; key?: string }\n- features: Record<string, boolean> (dynamic map keyed by feature name)\n- sso: { enabled: boolean; provider?: 'okta' | 'auth0' | 'oidc' }\n- development_mode: { enable_mock_data: boolean; verbose_logs: boolean }\n- defaults: { perPage: number }\n\nMaterialization and computed flags (implementation guidance)\n- Read values from import.meta.env. Example vars expected: VITE_API_BASE, VITE_SOCKET_URL, VITE_APP_NAME, VITE_ENV, VITE_FEATURES (comma separated, e.g. 'auth,analytics,websocket'), VITE_ANALYTICS_KEY, VITE_ENABLE_MOCKS (\"true\"|\"false\"), VITE_VERBOSE_LOGS\n- Provide parsing helpers for boolean and list.\n- Build features map: config.features = { auth: true, analytics: false, websocket: true, ... }\n- Computed flags: isDevelopment = config.env === 'development'; shouldUseMockData = isDevelopment && config.development_mode.enable_mock_data\n\nMock data\n- If shouldUseMockData is true, export a small set of mock objects used across the app: MOCK_USER_ADMIN (User), MOCK_PATIENTS array (Patient[]), MOCK_DOCTORS array. Keep the mock shapes typing-compliant with core/contracts.ts.\n\nExamples of how to use\n- const { apiBaseUrl } = config\n- if (config.features['analytics']) initAnalytics(config.analytics.key)\n- if (config.shouldUseMockData) seedLocalStoreWithMocks()\n\nImportant: Use import.meta.env (Vite) instead of process.env in all reads. Example\n- const rawEnv = import.meta.env\n- const apiBaseUrl = String(rawEnv.VITE_API_BASE ?? window.location.origin + '/api')\n\nIntegration points\n- services/api.ts uses config.apiBaseUrl and config.shouldUseMockData\n- services/analytics.ts uses config.analytics\n- providers/QueryProvider.tsx reads config.defaults.perPage when setting defaultQueryFn or pagination helpers\n\nPattern and conventions\n- Keep config immutable at runtime. Export a single const config: AppConfig.\n- Validate critical values with runtime checks in development (throw or log descriptive errors if required env missing)."
    },
    {
      "file_path": "src/core/events.ts",
      "purpose": "Lightweight typed event bus for app-level events (toasts, analytics events, auth changes). Allows decoupled publish/subscribe for providers and features. Supports synchronous and asynchronous handlers and handler lifetime management.",
      "exports": [
        "EventBus",
        "publishEvent",
        "subscribeEvent",
        "unsubscribeEvent",
        "AppEvents"
      ],
      "content": "Typed event map to define\n- AppEvents mapping type (eventName => payload). Provide the most common events used by app modules:\n  - 'toast:show' => { id?: string; type: 'success'|'error'|'info'|'warning'; title?: string; message: string; autoDismiss?: number }\n  - 'auth:login' => { user: import('@/core/contracts').User; tokens?: { access: string; refresh?: string } }\n  - 'auth:logout' => { reason?: string }\n  - 'api:request' => { url: string; method: 'GET'|'POST'|'PUT'|'DELETE'|'PATCH'; payload?: any }\n  - 'api:response' => { url: string; method: string; response: import('@/core/contracts').ApiResult<any> }\n  - 'analytics:event' => { name: string; payload?: Record<string, any> }\n  - 'route:change' => { from?: string; to: string }\n  - 'modal:open' => { id: string; props?: any }\n  - 'modal:close' => { id?: string }\n\nEventBus class\n- Generic typed class EventBus<E extends Record<string, any>> with methods:\n  - on<K extends keyof E>(event: K, handler: (payload: E[K]) => void | Promise<void>): () => void  // returns unsubscribe\n  - off<K extends keyof E>(event: K, handler: (payload: E[K]) => void | Promise<void>): void\n  - once<K extends keyof E>(event: K, handler: (payload: E[K]) => void | Promise<void>): void\n  - emit<K extends keyof E>(event: K, payload: E[K]): Promise<void> // awaitable; runs all handlers and resolves when done\n  - listeners<K extends keyof E>(event: K): Array<(payload: E[K]) => void | Promise<void>>\n- Implementation details:\n  - Internally store a Map<string, Set<Function>>\n  - For emit, copy handlers into an array before invoking (safe for handlers that remove themselves)\n  - Support both sync and async handlers; emit returns Promise<void> and waits for all handlers to complete (Promise.allSettled) and logs errors but does not throw to callers unless in development configured to escalate\n  - Provide lightweight once() wrapper (register that removes itself on first call)\n\nSingleton & helpers\n- Export a singleton defaultBus: EventBus<AppEvents>\n- Convenience wrappers: publishEvent<K extends keyof AppEvents>(event: K, payload: AppEvents[K]) => defaultBus.emit(event, payload)\n- subscribeEvent<K extends keyof AppEvents>(event: K, handler: (payload: AppEvents[K]) => void | Promise<void>) => defaultBus.on(event, handler)\n- unsubscribeEvent<K extends keyof AppEvents>(event: K, handler: (payload: AppEvents[K]) => void | Promise<void>) => defaultBus.off(event, handler)\n\nUsage patterns\n- ToastProvider subscribes to 'toast:show' to push UI toasts.\n- services/analytics.ts subscribes to 'route:change' and 'analytics:event' to forward events to external provider when enabled.\n- AuthProvider emits 'auth:login' and 'auth:logout' so other modules can react.\n\nIntegration points\n- core/hooks.ts may call publishEvent('api:request', {...}) before running hooks\n- services/api.ts should publish api:request/api:response events through this bus\n\nError handling and instrumentation\n- In development, EventBus logs handlers that throw or reject; errors are collected and reported to analytics if configured.\n- Keep implementation side-effect free except for calling handlers; do not store domain state here.\n\nExample use\n- import { publishEvent, subscribeEvent } from '@/core/events'\n- const unsub = subscribeEvent('route:change', payload => { publishEvent('analytics:event', { name: 'route_change', payload }) })\n- publishEvent('toast:show', { type: 'success', message: 'Saved' })"
    },
    {
      "file_path": "src/core/hooks.ts",
      "purpose": "A small registry for pluggable lifecycle hooks used by the app and optional extensions. Allows registering multiple handlers for common hook points (beforeApiRequest, afterApiResponse, onLogin, onLogout, onRouteChange). Hooks provide typed contexts and can be run serially or in parallel.",
      "exports": [
        "registerHook",
        "runHook",
        "HookRegistry"
      ],
      "content": "HookPoint union & HookContext\n- HookPoint = 'beforeApiRequest' | 'afterApiResponse' | 'onLogin' | 'onLogout' | 'onRouteChange'\n\nContext shapes\n- BeforeApiRequestCtx = { url: string; method: string; headers: Record<string,string>; body?: any; meta?: Record<string, any> }\n- AfterApiResponseCtx = { url: string; method: string; response: import('@/core/contracts').ApiResult<any>; meta?: Record<string, any> }\n- AuthHookCtx = { user?: import('@/core/contracts').User; tokens?: any }\n- RouteChangeCtx = { from?: string; to: string }\n- HookResult generic: { handled?: boolean; data?: any }\n\nHook function type\n- type HookFunc<Ctx> = (ctx: Ctx) => void | Promise<void | HookResult>\n\nHookRegistry class responsibilities\n- register<K extends HookPoint>(name: K, fn: HookFunc<...>): () => void  // returns unregister function\n- run<K extends HookPoint>(name: K, ctx: CorrespondingCtx, options?: { parallel?: boolean; stopOnHandled?: boolean }): Promise<HookResult[]>\n- getHandlers<K extends HookPoint>(name: K): HookFunc[]\n\nImplementation notes\n- Maintain a Map<HookPoint, Set<Function>>\n- register returns an unregister function for easy plugin cleanup\n- run supports two modes:\n  - parallel (default false): handlers are run serially in registration order. If stopOnHandled true and a handler returns { handled: true }, stop further handlers.\n  - when parallel is true: use Promise.allSettled to run concurrently; stopOnHandled has no effect in parallel mode.\n- run returns all HookResults for instrumentation and debugging.\n\nStandard hooks to provide out of box\n- 'beforeApiRequest' (called by services/api.ts) allows hooks to mutate headers or augment meta. Should receive a mutable ctx.headers object; return values ignored except HookResult.handled for short-circuiting requests.\n- 'afterApiResponse' (called after API completes) allows logging, error transformation, telemetry, or domain-specific handling of non-2xx responses.\n- 'onLogin' and 'onLogout' used by AuthProvider to allow cross-cutting initialization/teardown (e.g., analytics identify, websocket auth)\n- 'onRouteChange' called by Router wrapper to let plugins respond to navigation events.\n\nIntegration with EventBus\n- Hooks may dispatch events to the event bus (import '@/core/events') if they need to inform other systems. The registry itself is lightweight and intentionally unrelated to bus internals.\n\nUsage example\n- import { registerHook, runHook } from '@/core/hooks'\n- const unregister = registerHook('onLogin', async ctx => { await analytics.identify(ctx.user) })\n- await runHook('beforeApiRequest', { url, method, headers, body })\n\nGuidelines\n- Hooks are for cross-cutting extension points only \u2014 do not store app state inside hook registry.\n- Keep handlers idempotent; register only during provider/plugin init and unregister on cleanup."
    },
    {
      "file_path": "src/core/di.ts",
      "purpose": "A minimal, type-safe dependency injection container used to register and resolve cross-cutting services (api client, auth service, storage). The container supports token creation so callers can declare dependencies in a typed way and swap implementations in tests or plugin registration.",
      "exports": [
        "registerService",
        "resolveService",
        "DIContainer"
      ],
      "content": "Token definition & typing\n- Export a generic Token<T> type implemented as a unique Symbol plus a friendly description: interface Token<T> { readonly __name: string; readonly __id: symbol }\n- Helper createToken<T>(name: string): Token<T>\n\nContainer API\n- class DIContainer {\n    private registry = new Map<symbol, any>()\n    register<T>(token: Token<T>, implementation: T): void\n    has<T>(token: Token<T>): boolean\n    resolve<T>(token: Token<T>): T\n    clear(): void // test helper\n  }\n- register overwrites previous implementations by default (document this behaviour). Use re-register pattern in tests.\n- resolve throws a descriptive error in development mode if token missing (helps debugging), but in production throws as well to avoid undefined service usage.\n\nPredefined tokens\n- export const TOKENS = {\n    ApiClient: createToken<ApiClientShape>('ApiClient'),\n    AuthService: createToken<AuthServiceShape>('AuthService'),\n    StorageService: createToken<StorageServiceShape>('StorageService'),\n    WebSocketService: createToken<WebSocketServiceShape>('WebSocketService')\n  }\n\nService shape examples (interfaces)\n- ApiClientShape: { get<T>(url:string, opts?:any): Promise<import('@/core/contracts').ApiResult<T>>; post<T>(url:string, body?:any, opts?:any): Promise<ApiResult<T>>; put; delete }\n- AuthServiceShape: { login(credentials:any): Promise<{ user: User; tokens: any }>; logout(): Promise<void>; refresh(): Promise<any>; getCurrentUser(): Promise<User | null> }\n- StorageServiceShape: { get<T>(key:string): T | null; set<T>(key:string, value:T): void; remove(key:string): void }\n- WebSocketServiceShape: { connect(): Promise<void>; disconnect(): Promise<void>; send(event:string, payload:any): void; on<K extends string>(event:K, handler:(payload:any)=>void): ()=>void }\n\nSingleton container\n- Export a default global container instance: DIContainer.instance (or named container) for app-level registrations.\n- Export helper functions registerService(token, impl) and resolveService(token) that forward to the default container for convenience.\n\nIntegration patterns\n- Providers (QueryProvider, AuthProvider) register their concrete service instances into the container during app initialization.\n- Tests can create a fresh DIContainer, register mock services and pass to modules that accept container override (or use registerService to replace in global container), enabling easy mocking of network & auth flows.\n\nUsage example\n- import { TOKENS, registerService, resolveService } from '@/core/di'\n- registerService(TOKENS.ApiClient, apiClientImpl)\n- const api = resolveService(TOKENS.ApiClient)\n\nConventions\n- Keep tokens and service interfaces here. Concrete implementations live in services/ and register themselves at bootstrap.\n- Avoid tight coupling: components/hooks should prefer consuming helper hooks (e.g., useAuth) but libraries and tests can resolve tokens directly when needed."
    },
    {
      "file_path": "src/core/utils.ts",
      "purpose": "Small library of safe, well-typed utility helpers used widely across the app: fetch wrapper adapters, formatting utilities, safe JSON helpers, small encryption helper (optional), classNames utility and debug logging. This file keeps simple helpers centralized to avoid duplication.",
      "exports": [
        "fetcher",
        "classNames",
        "formatDate",
        "safeJSONParse",
        "sleep",
        "debug"
      ],
      "content": "Utilities & function signatures\n- fetcher<T>(input: RequestInfo | string, init?: RequestInit): Promise<import('@/core/contracts').ApiResult<T>>\n  - Should rely on config.apiBaseUrl when provided (import config from '@/app/config')\n  - Automatically parse JSON and normalize errors into ApiError shape from contracts.ts\n  - Attach default headers (Accept: application/json)\n  - Support injecting Authorization header via an optional getToken callback in options\n  - Return ApiResult<T> { success: boolean; data?: T; error?: ApiError }\n  - Example: const resp = await fetcher<User>('/me', { headers: { 'X-Tenant': 'foo' } })\n\n- classNames(...items: Array<string | Record<string, boolean> | undefined | null>): string\n  - Small helper to join class names conditionally. Common signature used across components.\n\n- formatDate(dateOrIso: string | Date, opts?: { dateOnly?: boolean; locale?: string; timeZone?: string }): string\n  - Friendly wrapper around Intl.DateTimeFormat with a sensible default format and safe fallback when Intl not available. Use to format appointment times and display dates across UI.\n\n- safeJSONParse<T>(raw: string | null | undefined, fallback?: T): T | undefined\n  - Try/Catch JSON.parse and return fallback on error; used when reading localStorage or unknown server payloads.\n\n- sleep(ms: number): Promise<void>\n  - Simple delay helper for tests or UI micro-interactions.\n\n- debug(namespace: string): (...args:any[]) => void\n  - Conditional debug logger that respects config.development_mode.verbose_logs and optionally a DEBUG import.meta.env flag.\n  - Implementation example: const log = debug('services:api'); log('request', url)\n\nSmall crypto helper for local storage (optional)\n- simpleBase64Encode/Decode(value: string): string\n- encryptLocal(value: string): string // wrapper around btoa with JSON structure so we can switch to real encryption in future\n- decryptLocal(value: string): string\n\nImplementation notes\n- Keep no direct side effects (no storage writes) in utility functions unless named explicitly.\n- fetcher should be resilient: if response has non-JSON body, still return ApiError with status & text.\n- fetcher must call runHook('beforeApiRequest', ctx) and runHook('afterApiResponse', ctx) from '@/core/hooks' to enable plugins and middleware to observe API calls.\n\nIntegration points\n- services/api.ts will wrap fetcher and provide higher-level helper methods get/post/put/delete.\n- hooks/useLocalStorage uses safeJSONParse, encryptLocal and decryptLocal optionally.\n- debug used across modules to enable verbose logging in development.\n\nExample usage\n- import { fetcher, classNames, formatDate, safeJSONParse } from '@/core/utils'\n- const { success, data } = await fetcher<MyType>('/some-endpoint')\n- <div className={classNames('p-2', { 'opacity-50': isDisabled })}>...</div>"
    }
  ],
  "usage_guidelines": [
    "Import domain types from @/core/contracts \u2014 this file is the canonical source of truth for types across services, state and components.",
    "Read runtime configuration only from @/app/config.ts which uses import.meta.env. Do not access import.meta.env in multiple places \u2014 centralize here.",
    "Use the EventBus (publishEvent/subscribeEvent) for decoupled cross-cutting events such as toasts, analytics events and auth lifecycle notifications; keep event payloads typed in core/events.ts.",
    "Register extension hooks using registerHook(...) exposed by @/core/hooks.ts. Use runHook in places like the API client and router to allow plugins to observe and alter behavior.",
    "Register concrete implementations of cross-cutting services (ApiClient, AuthService, StorageService, WebSocketService) into the DI container (@/core/di.ts) at app bootstrap so that tests and plugins can swap them out.",
    "Use utilities from @/core/utils.ts for safe JSON parsing, formatted dates, className merging and the fetcher helper that integrates with hooks and the event bus.",
    "Follow immutability: config is exported as a single immutable const; domain models should be treated as read-only data returned by the API unless explicitly mutated by domain services.",
    "Keep side effects inside providers/services (AuthProvider, QueryProvider, WebSocket service). The kernel files expose primitives and contracts \u2014 they should not directly perform network or DOM operations."
  ]
}