{
  "overview": "The core kernel provides the single source of truth for types, configuration, utilities, events, hooks and a minimal dependency injection container. These files are intentionally small, focused and typed so every feature and provider in the app imports contracts and utilities from `src/core/*` and the runtime configuration from `src/app/config.ts`. Events and hooks enable decoupled cross-cutting communication; DI tokens let services be swapped in tests or replaced by alternate implementations; utilities encapsulate common safe operations used everywhere.",
  "files": [
    {
      "file_path": "src/core/contracts.ts",
      "purpose": "TypeScript domain types, API request/response contracts, shared enums and interfaces used across services, components and hooks.",
      "exports": [
        "AppConfig",
        "User",
        "Patient",
        "Doctor",
        "Nurse",
        "Role",
        "Gender",
        "AuthTokens",
        "ApiResult",
        "ApiError",
        "PaginatedResponse",
        "LoginPayload",
        "Appointment",
        "MedicalRecord",
        "Prescription",
        "LabResult",
        "WebSocketEvent",
        "LoadingState",
        "FormState",
        "ApiClient",
        "StorageService",
        "AuthService",
        "RouteInfo"
      ],
      "content": "This is the canonical file for all domain and cross-cutting types used by the app. Keep it stable and extend carefully.\n\nKey types and interfaces to define (implement in TypeScript):\n\n- Enums\n  - Role: 'patient' | 'doctor' | 'nurse' | 'admin'\n  - Gender: 'male' | 'female' | 'other' | 'unknown'\n  - AppointmentStatus: 'scheduled' | 'completed' | 'cancelled' | 'no_show'\n  - LabResultType: 'blood' | 'imaging' | 'pathology' | 'other'\n\n- User models\n  - interface User { id: string; role: Role; email: string; fullName: string; avatarUrl?: string; metadata?: Record<string, any> }\n  - interface Patient extends User { medicalRecordNumber: string; dob?: string; gender?: Gender }\n  - interface Doctor extends User { specialty?: string; licenseNumber?: string }\n  - interface Nurse extends User { ward?: string }\n\n- Healthcare domain models\n  - interface Appointment { id: string; patientId: string; clinicianId?: string; start: string; end?: string; status: AppointmentStatus; location?: string; notes?: string }\n  - interface MedicalRecord { id: string; patientId: string; createdAt: string; summary?: string; diagnoses?: string[]; entries?: Array<{ id: string; type: string; data: any; createdAt: string }>; }\n  - interface Prescription { id: string; patientId: string; prescriberId: string; drug: string; dosage: string; instructions?: string; issuedAt: string; expiresAt?: string }\n  - interface LabResult { id: string; patientId: string; type: LabResultType; result: string | Record<string, any>; collectedAt: string; reportedAt?: string }\n\n- Auth and API models\n  - interface AuthTokens { accessToken: string; refreshToken?: string; expiresAt?: string }\n  - interface LoginPayload { username: string; password: string; remember?: boolean }\n  - type ApiResult<T> = { ok: true; data: T } | { ok: false; error: ApiError }\n  - interface ApiError { code?: string; status?: number; message: string; details?: any }\n  - interface PaginatedResponse<T> { items: T[]; page: number; pageSize: number; total: number }\n\n- WebSocket / Realtime types\n  - type WebSocketEvent = { type: string; payload?: any; timestamp?: string }\n  - Common event names may include: 'patient:update', 'appointment:created', 'notification:push'\n\n- UI helper types\n  - type LoadingState = 'idle' | 'loading' | 'success' | 'error'\n  - interface FormState<TValues = Record<string, any>> { values: TValues; errors?: Partial<Record<keyof TValues, string>>; touched?: Partial<Record<keyof TValues, boolean>> }\n\n- Service interface contracts (for DI tokens)\n  - interface ApiClient { get<T>(path: string, opts?: RequestInit): Promise<ApiResult<T>>; post<T>(path: string, body?: any, opts?: RequestInit): Promise<ApiResult<T>>; put<T>(path: string, body?: any, opts?: RequestInit): Promise<ApiResult<T>>; delete<T>(path: string, opts?: RequestInit): Promise<ApiResult<T>>; baseUrl: string }\n  - interface StorageService { get<T>(key: string): T | null; set<T>(key: string, value: T): void; remove(key: string): void }\n  - interface AuthService { login(payload: LoginPayload): Promise<ApiResult<{ user: User; tokens: AuthTokens }>>; logout(): Promise<void>; refreshToken(refreshToken: string): Promise<ApiResult<AuthTokens>> }\n\n- Router helper type\n  - interface RouteInfo { path: string; params?: Record<string, string>; query?: URLSearchParams }\n\nPatterns and conventions\n- Keep models small and composable. Prefer IDs rather than nested objects for service boundaries.\n- All API calls should return ApiResult<T> to normalize error handling.\n- Exported interfaces are used by DI tokens in core/di.ts and runtime services.\n\nExample usage\n- In a feature: import { User, ApiResult } from '@/core/contracts';\n- Service signature: const getCurrentUser = async (): Promise<ApiResult<User>> => { /* uses apiClient */ };\n\nIntegration points\n- app/config.ts reads the AppConfig type (exported here) and may include lists of roles/features.\n- core/di.ts uses ApiClient/AuthService/StorageService interfaces to type tokens.\n- core/events.ts and core/hooks.ts reference User, RouteInfo and WebSocketEvent types.\n\nNotes\n- If you need to add more fine-grained domain types (e.g., allergies, immunizations) add them here so all features remain type-safe."
    },
    {
      "file_path": "src/app/config.ts",
      "purpose": "Materialized runtime configuration (API base URL, environment flags, feature toggles). Typed against core/contracts AppConfig.",
      "exports": [
        "defaultConfig",
        "getConfig",
        "isFeatureEnabled",
        "mockUser"
      ],
      "content": "This file materializes JSON-like configuration into a typed runtime object. It includes computed flags, a feature toggle map and (optionally) mock data used in development. The config shape is intentionally conservative and serializable.\n\nKey shapes and fields (implement in TypeScript):\n\n- AppConfig type (re-affirm from contracts when needed):\n  - env: 'development' | 'staging' | 'production'\n  - apiBaseUrl: string\n  - wsBaseUrl?: string\n  - features: string[]\n  - analytics?: { enabled: boolean }\n  - development_mode?: { enable_mock_data?: boolean }\n  - defaultPageSize?: number\n\n- Exported runtime object defaultConfig: typed constant with values suitable for a typical dev environment. Example:\n  - env: process.env.NODE_ENV === 'production' ? 'production' : 'development'\n  - apiBaseUrl: derived from process.env.API_BASE_URL || 'http://localhost:4000/api'\n  - wsBaseUrl: process.env.WS_BASE_URL || 'ws://localhost:4000/realtime'\n  - features: [ 'dashboard', 'auth', 'notifications', 'lab-results' ]\n  - analytics: { enabled: false }\n  - development_mode: { enable_mock_data: true }\n  - defaultPageSize: 20\n\n- Computed helpers:\n  - isDevelopment: boolean (env === 'development')\n  - shouldUseMockData: boolean (isDevelopment && development_mode.enable_mock_data)\n  - featureSet: Record<string, boolean> to quickly check toggles\n\n- Mock user data (only exposed when shouldUseMockData is true). Example structure: mockUser: User\n  - Provide one representative user for each role: patient, doctor, nurse. Export `mockUser` that consumers can import if they explicitly opt into dev-mode mocks.\n  - Example patient mock: { id: 'mock-patient-1', role: 'patient', email: 'patient@example.test', fullName: 'Dev Patient', medicalRecordNumber: 'MRN-0001' }\n\n- Exposed functions:\n  - getConfig(): returns a read-only copy of the computed config (Object.freeze)\n  - isFeatureEnabled(featureName: string): boolean\n\nExample usage\n- In services: import { getConfig } from '@/app/config'; const cfg = getConfig(); fetch(cfg.apiBaseUrl + '/users');\n- In components: import { isFeatureEnabled } from '@/app/config'; if (isFeatureEnabled('dashboard')) { /* render */ }\n- In dev-only code, import { mockUser, shouldUseMockData } and guard usage by shouldUseMockData.\n\nIntegration points\n- apiClient reads apiBaseUrl and wsBaseUrl from the config.\n- QueryProvider can read defaultPageSize to set default cache sizes.\n- AuthProvider can seed its initial state with mockUser if shouldUseMockData is true.\n\nNotes\n- Keep all environment sensitive values read at module initialization time to avoid surprises in SSR.\n- Avoid embedding secrets in the repo; read them from environment variables."
    },
    {
      "file_path": "src/core/utils.ts",
      "purpose": "Common utilities used across the app (safeParseJson, sleep, formatDate, small helpers used by services/hooks/events).",
      "exports": [
        "safeParseJson",
        "sleep",
        "formatDate",
        "isoNow",
        "debugLog",
        "assertNever"
      ],
      "content": "A small collection of deterministic, side-effect-free helpers. Keep these functions lightweight and well-typed.\n\nFunctions and signatures to implement (TypeScript):\n\n- safeParseJson<T = any>(input: string | null | undefined, fallback?: T): T | undefined\n  - Attempt JSON.parse; on error return fallback or undefined. Should be generic to allow typing returned value.\n  - Example: const obj = safeParseJson<MyType>(raw, {} as MyType)\n\n- sleep(ms: number): Promise<void>\n  - Promise-based delay used in tests or simulated latencies\n\n- formatDate(isoString: string | Date, opts?: { locale?: string; dateOnly?: boolean; timeOnly?: boolean; }): string\n  - Return a short human-friendly date/time using Intl.DateTimeFormat. Fall back to toISOString on invalid input.\n\n- isoNow(): string\n  - Returns new Date().toISOString() (single source of truth for timestamps)\n\n- debugLog(namespace: string, ...args: any[]): void\n  - Conditional logging only when NODE_ENV !== 'production'. Prefix log lines with namespace and timestamp.\n\n- assertNever(x: never, message?: string): never\n  - Helper for exhaustive checks in switch statements.\n\nExample usage\n- const parsed = safeParseJson<User>(localStorage.getItem('user'))\n- await sleep(250)\n- const s = formatDate(user.dob, { dateOnly: true })\n\nIntegration points\n- core/events.ts may use isoNow for event timestamps and debugLog when handlers throw.\n- core/di.ts and apiClient use debugLog for diagnostics in non-production.\n\nQuality notes\n- All helpers should be purely functional and have deterministic outputs for same inputs (except debugLog which interacts with console)."
    },
    {
      "file_path": "src/core/events.ts",
      "purpose": "Lightweight event bus/pub-sub used for cross-cutting events (notifications, global error events), built on top of core/utils if needed.",
      "exports": [
        "EventBus",
        "eventBus",
        "subscribe",
        "publish",
        "unsubscribe"
      ],
      "content": "Event bus design and behavior:\n\n- Provide a small, well-typed pub/sub implementation.\n- Support synchronous handlers and asynchronous handlers (handlers can return void or Promise<void>).\n- Support once() subscriptions and the ability to unsubscribe by token/handler.\n- Safe: exceptions thrown in one handler should not prevent other handlers from running; collect exceptions and optionally rethrow or log.\n\nType definitions to include:\n- interface EventMap {\n    'notification': { message: string; level?: 'info' | 'warning' | 'error' };\n    'auth:login': { userId: string; user?: import('@/core/contracts').User };\n    'auth:logout': { userId?: string };\n    'api:error': { error: import('@/core/contracts').ApiError; url?: string };\n    'route:change': { from?: string; to: string };\n    // Additional keys allowed via index signature: [key: string]: any\n  }\n\n- type EventHandler<T> = (payload: T) => void | Promise<void>\n\nEventBus class contract:\n- class EventBus<EM extends Record<string, any> = EventMap> {\n    on<K extends keyof EM>(event: K, handler: EventHandler<EM[K]>): () => void // returns unsubscribe\n    once<K extends keyof EM>(event: K, handler: EventHandler<EM[K]>): () => void\n    off<K extends keyof EM>(event: K, handler?: EventHandler<EM[K]>): void\n    emit<K extends keyof EM>(event: K, payload: EM[K]): Promise<void> // returns a promise that resolves when all handlers complete; collects errors and logs\n  }\n\nExports and runtime singleton:\n- export const eventBus = new EventBus<EventMap>()\n- export helpers: subscribe = eventBus.on.bind(eventBus) ; unsubscribe = eventBus.off.bind(eventBus); publish = eventBus.emit.bind(eventBus)\n\nBehavioral details:\n- When .emit is called, call handlers in registration order.\n- If a handler throws or rejects, catch and forward to a global error handler: by default debugLog('EventBus', error), and then continue executing other handlers.\n- Return a Promise that resolves after all handlers have settled. If any handlers threw, the Promise resolves but the errors are accessible by logging. Optionally, provide an option to rethrow aggregated error (not defaulted to true).\n\nExamples\n- import { publish, subscribe } from '@/core/events'\n  const unsub = subscribe('notification', async (payload) => { showToast(payload.message) })\n  await publish('auth:login', { userId: 'u-1' })\n  unsub()\n\nIntegration points\n- App-level components (e.g., global Notifications component) subscribe to 'notification' events.\n- AuthProvider emits 'auth:login' and 'auth:logout' events using publish.\n- apiClient publishes 'api:error' when a network error occurs.\n\nNotes\n- Keep this module dependency-free except for core/utils.debugLog to avoid cycles. Use lightweight types only and keep runtime behavior deterministic."
    },
    {
      "file_path": "src/core/hooks.ts",
      "purpose": "Hook registry and extension points for plugins/extensions; small helpers to register lifecycle hooks and access global hook slots.",
      "exports": [
        "registerHook",
        "invokeHook",
        "useRegisteredHook",
        "HookPoint",
        "HookRegistry"
      ],
      "content": "A thin extension/hook system to allow features and providers to register callbacks for key lifecycle events. Designed for application-level extension points rather than component-level hooks.\n\nHook points to support (well-typed):\n- 'beforeApiRequest' : invoked before an API request is sent. Payload: { path: string; init?: RequestInit; context?: any }.\n- 'afterApiResponse' : invoked after a response is received. Payload: { path: string; response?: Response; result?: import('@/core/contracts').ApiResult<any>; context?: any }.\n- 'onLogin' : invoked after a successful login. Payload: { user: import('@/core/contracts').User; tokens?: import('@/core/contracts').AuthTokens }.\n- 'onLogout' : invoked when the user logs out. Payload: { userId?: string }.\n- 'onRouteChange' : invoked when the route changes. Payload: import('@/core/contracts').RouteInfo.\n\nType declarations and registry API:\n- type HookPoint = 'beforeApiRequest' | 'afterApiResponse' | 'onLogin' | 'onLogout' | 'onRouteChange'\n\n- interface HookContext<P = any> { payload: P; meta?: Record<string, any> }\n\n- class HookRegistry {\n    register<P = any>(point: HookPoint, handler: (ctx: HookContext<P>) => void | Promise<void>): () => void // returns an unregister function\n    invoke<P = any>(point: HookPoint, payload: P, meta?: Record<string, any>): Promise<void>\n    list(point?: HookPoint): Array<Function>\n  }\n\n- Provide a module-level singleton registry: export const hooks = new HookRegistry()\n- Provide convenience functions: registerHook(point, handler) => hooks.register(...); invokeHook(point, payload, meta) => hooks.invoke(...)\n- Provide a small React helper useRegisteredHook(point, handler, deps?) which registers the handler on mount and unregisters on unmount. (Import React in the file to type this helper.)\n\nExecution semantics:\n- Handlers run in registration order. If an async handler rejects, log via debugLog and continue executing other handlers.\n- Handlers may mutate ctx.payload but should avoid doing so in typical usage. If you need immutable payloads, clone before invoking.\n- Hooks are global and live for the app lifetime; use unregister return to remove.\n\nExamples\n- Logging before requests:\n  registerHook('beforeApiRequest', ({ payload }) => { console.debug('Outgoing request', payload.path) })\n\n- Post-process all API responses:\n  registerHook('afterApiResponse', async ({ payload }) => { if (!payload.result?.ok) publish('api:error', { error: payload.result?.error, url: payload.path }) })\n\n- Use inside a React provider to register route change hooks:\n  useRegisteredHook('onRouteChange', ({ payload }) => { analytics.page(payload.to) })\n\nIntegration points\n- apiClient should call invokeHook('beforeApiRequest', { path, init }) before issuing the network call and invokeHook('afterApiResponse', { path, response, result }) afterwards.\n- AuthProvider calls invokeHook('onLogin', { user, tokens }) and invokeHook('onLogout', { userId }).\n- RouterProvider calls invokeHook('onRouteChange', routeInfo) when location changes.\n\nNotes\n- Keep hooks minimal and fast. They are intended for small cross-cutting responsibilities: logging, metrics, minor side-effects. Avoid heavy blocking work in hooks that can delay user flows."
    },
    {
      "file_path": "src/core/di.ts",
      "purpose": "Minimal dependency-injection utilities to bind and resolve implementations (useful in tests or swapping implementations).",
      "exports": [
        "Container",
        "createToken",
        "bind",
        "resolve",
        "TOKENS"
      ],
      "content": "A small, type-safe DI container for application-level services. Designed to be used at bootstrap to register concrete implementations and in tests to swap them. Prefer composition over deep DI; this container is intentionally minimal.\n\nCore concepts and types:\n- Token<T>: a unique symbol typed with the target interface. Use createToken<T>('name') to create tokens.\n- Registration options: { lifecycle: 'singleton' | 'transient' }\n- Container API: register(token, provider, options?), resolve(token)\n\nType declarations and implementations:\n- export function createToken<T = any>(desc?: string): { id: symbol; toString(): string; } & { __type?: T }\n  - This function returns a token object that carries the generic type for compile-time safety.\n\n- class Container {\n    register<T>(token: ReturnType<typeof createToken>, provider: { useValue?: T; useFactory?: (c: Container) => T }, opts?: { lifecycle?: 'singleton' | 'transient' }): void\n    resolve<T>(token: ReturnType<typeof createToken>): T\n    has(token): boolean\n    clear(): void // remove all bindings (useful in tests)\n  }\n\n- Lifetime semantics:\n  - singleton: provider factory is called once and the value cached\n  - transient: factory is called every time resolve is called\n\nPredefined tokens (TOKENS) to export (create tokens using createToken):\n- ApiClientToken: Token<ApiClient>\n- AuthServiceToken: Token<AuthService>\n- StorageServiceToken: Token<StorageService>\n- WebSocketServiceToken: Token<{ connect(): void; disconnect(): void }>\n\nConvenience module-level container and helpers\n- Export a default global container instance: export const container = new Container()\n- Export top-level helpers:\n  - bind(token, provider, opts) => container.register(...)\n  - resolve(token) => container.resolve(...)\n\nExample registration (bootstrap):\n- import { container, createToken, bind, TOKENS } from '@/core/di'\n- container.register(TOKENS.ApiClientToken, { useFactory: () => createApiClient(cfg.apiBaseUrl) }, { lifecycle: 'singleton' })\n- container.register(TOKENS.StorageServiceToken, { useValue: new LocalStorageService() })\n\nExample usage in a service/file:\n- const apiClient = resolve(TOKENS.ApiClientToken) as ApiClient\n- type-safety: const s = resolve<typeof TOKENS.AuthServiceToken>(TOKENS.AuthServiceToken) // resolve returns typed value when token is typed\n\nIntegration points\n- App bootstrap (main.tsx) registers implementations for tokens.\n- Services may import tokens and call resolve(TOKENS.*) instead of importing concretions. This makes tests easier: test harness can register mocks into a fresh container and call components/services with those values.\n\nNotes and best practices\n- Keep DI usage shallow. Prefer passing dependencies via constructor/props for local composition and use container for truly cross-cutting global services (http client, auth, websocket).\n- Use the container mainly at the app root and tests. Avoid global side-effectful registration in random modules to keep tests predictable."
    }
  ],
  "usage_guidelines": [
    "Import domain types from '@/core/contracts' \u2014 this is the single source of truth for models and API contracts.",
    "Read runtime settings from '@/app/config' using getConfig(); guard mock data usage with shouldUseMockData.",
    "Use the singleton eventBus from '@/core/events' for cross-cutting notifications and global error events. Prefer publish/subscribe helpers.",
    "Use hooks registry '@/core/hooks' for lifecycle-like extension points. Integrate apiClient/auth/router with before/after hooks.",
    "Register core services at app bootstrap via '@/core/di' tokens. Resolve services in files that need them to allow tests to swap implementations.",
    "Keep utilities in '@/core/utils' small and pure. Use formatDate and safeParseJson consistently across the codebase.",
    "Prefer ApiResult<T> returned from API wrappers to normalize success/error handling. Use ApiError for structured error messages."
  ]
}