"""
Auto-generated Strawberry GraphQL types from domain-schema.graphql.
DO NOT EDIT MANUALLY - Generated by DiPeO codegen.
"""

from datetime import datetime
from typing import NewType, Optional, List, Union, Any

import strawberry
from strawberry.scalars import JSON

# Import domain models for Pydantic integration
from dipeo.diagram_generated.domain_models import (
    # Import all domain models that have Pydantic definitions
    Vec2, TokenUsage, NodeState, DomainHandle, DiagramMetadata,
    DomainNode, DomainArrow, PersonLLMConfig, DomainPerson,
    DomainApiKey, DomainDiagram, ExecutionState, ExecutionOptions,
    InteractivePromptData, InteractiveResponse, NodeDefinition,
    Message, ConversationMetadata, Conversation,
    # Import other types
    MemorySettings, ToolConfig, WebSearchResult,
    ImageGenerationResult, ToolOutput, ChatResult,
    LLMRequestOptions
)

# Import node data types from individual model files
from dipeo.diagram_generated.models.start_model import StartNodeData
from dipeo.diagram_generated.models.condition_model import ConditionNodeData
from dipeo.diagram_generated.models.person_job_model import PersonJobNodeData
from dipeo.diagram_generated.models.code_job_model import CodeJobNodeData
from dipeo.diagram_generated.models.api_job_model import ApiJobNodeData
from dipeo.diagram_generated.models.endpoint_model import EndpointNodeData
from dipeo.diagram_generated.models.db_model import DbNodeData
from dipeo.diagram_generated.models.user_response_model import UserResponseNodeData
from dipeo.diagram_generated.models.notion_model import NotionNodeData
from dipeo.diagram_generated.models.hook_model import HookNodeData
from dipeo.diagram_generated.models.template_job_model import TemplateJobNodeData
from dipeo.diagram_generated.models.json_schema_validator_model import JsonSchemaValidatorNodeData
from dipeo.diagram_generated.models.typescript_ast_model import TypescriptAstNodeData
from dipeo.diagram_generated.models.sub_diagram_model import SubDiagramNodeData
from dipeo.diagram_generated.models.person_batch_job_model import PersonBatchJobNodeData

# Import all enums from separate module
from dipeo.diagram_generated.enums import (
    NodeType, HandleDirection, HandleLabel, DataType, MemoryView,
    DiagramFormat, DBBlockSubType, ContentType, SupportedLanguage,
    HttpMethod, HookType, HookTriggerMode, ExecutionStatus,
    NodeExecutionStatus, EventType, LLMService, APIServiceType,
    NotionOperation, ToolType
)


# ============ Scalars ============

NodeID = strawberry.scalar(
    NewType("NodeID", str),
    description="Unique identifier for node",
    serialize=lambda v: str(v),
    parse_value=lambda v: str(v) if v else None,
)

ArrowID = strawberry.scalar(
    NewType("ArrowID", str),
    description="Unique identifier for arrow",
    serialize=lambda v: str(v),
    parse_value=lambda v: str(v) if v else None,
)

HandleID = strawberry.scalar(
    NewType("HandleID", str),
    description="Unique identifier for handle",
    serialize=lambda v: str(v),
    parse_value=lambda v: str(v) if v else None,
)

PersonID = strawberry.scalar(
    NewType("PersonID", str),
    description="Unique identifier for person",
    serialize=lambda v: str(v),
    parse_value=lambda v: str(v) if v else None,
)

ApiKeyID = strawberry.scalar(
    NewType("ApiKeyID", str),
    description="Unique identifier for apikey",
    serialize=lambda v: str(v),
    parse_value=lambda v: str(v) if v else None,
)

DiagramID = strawberry.scalar(
    NewType("DiagramID", str),
    description="Unique identifier for diagram",
    serialize=lambda v: str(v),
    parse_value=lambda v: str(v) if v else None,
)

ExecutionID = strawberry.scalar(
    NewType("ExecutionID", str),
    description="Unique identifier for execution",
    serialize=lambda v: str(v),
    parse_value=lambda v: str(v) if v else None,
)

JSONScalar = strawberry.scalar(
    NewType("JSONScalar", object),
    name="JSONScalar",
    description="Arbitrary JSON data",
    serialize=lambda v: v,
    parse_value=lambda v: v,
)


# ============ Enum Registrations ============

NodeTypeEnum = strawberry.enum(NodeType)
HandleDirectionEnum = strawberry.enum(HandleDirection)
HandleLabelEnum = strawberry.enum(HandleLabel)
DataTypeEnum = strawberry.enum(DataType)
MemoryViewEnum = strawberry.enum(MemoryView)
DiagramFormatEnum = strawberry.enum(DiagramFormat)
DBBlockSubTypeEnum = strawberry.enum(DBBlockSubType)
ContentTypeEnum = strawberry.enum(ContentType)
SupportedLanguageEnum = strawberry.enum(SupportedLanguage)
HttpMethodEnum = strawberry.enum(HttpMethod)
HookTypeEnum = strawberry.enum(HookType)
HookTriggerModeEnum = strawberry.enum(HookTriggerMode)
ExecutionStatusEnum = strawberry.enum(ExecutionStatus)
NodeExecutionStatusEnum = strawberry.enum(NodeExecutionStatus)
EventTypeEnum = strawberry.enum(EventType)
LLMServiceEnum = strawberry.enum(LLMService)
APIServiceTypeEnum = strawberry.enum(APIServiceType)
NotionOperationEnum = strawberry.enum(NotionOperation)
ToolTypeEnum = strawberry.enum(ToolType)


# ============ Pydantic-based Types ============

@strawberry.experimental.pydantic.type(
    Vec2,
    all_fields=True
)
class Vec2Type:
    pass

@strawberry.experimental.pydantic.type(
    DomainHandle,
    fields=["label", "direction", "data_type", "position"]
)
class DomainHandleType:
    @strawberry.field
    def id(self) -> HandleID:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return HandleID(str(obj.id))

    @strawberry.field
    def node_id(self) -> NodeID:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return NodeID(str(obj.node_id))


@strawberry.experimental.pydantic.type(
    DomainNode,
    fields=["type", "position"]
)
class DomainNodeType:
    @strawberry.field
    def id(self) -> NodeID:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return NodeID(str(obj.id))

    @strawberry.field
    def data(self) -> JSONScalar:
        if hasattr(self, "_pydantic_object") and self._pydantic_object:
            return self._pydantic_object.data or {}
        return getattr(self, "data", {})


@strawberry.experimental.pydantic.type(
    DomainArrow,
    fields=["content_type", "label"]
)
class DomainArrowType:
    @strawberry.field
    def id(self) -> ArrowID:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return ArrowID(str(obj.id))

    @strawberry.field
    def source(self) -> HandleID:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return HandleID(str(obj.source))

    @strawberry.field
    def target(self) -> HandleID:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return HandleID(str(obj.target))

    @strawberry.field
    def data(self) -> Optional[JSONScalar]:
        if hasattr(self, "_pydantic_object") and self._pydantic_object:
            return self._pydantic_object.data
        return getattr(self, "data", None)


@strawberry.experimental.pydantic.type(
    MemorySettings,
    all_fields=True
)
class MemorySettingsType:
    pass

@strawberry.experimental.pydantic.type(
    PersonLLMConfig,
    all_fields=True
)
class PersonLLMConfigType:
    pass

@strawberry.experimental.pydantic.type(
    DomainPerson,
    fields=["label", "llm_config"]
)
class DomainPersonType:
    @strawberry.field
    def id(self) -> PersonID:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return PersonID(str(obj.id))

    @strawberry.field
    def type(self) -> str:
        return "person"


@strawberry.experimental.pydantic.type(
    DomainApiKey,
    fields=["label", "service", "key"]
)
class DomainApiKeyType:
    @strawberry.field
    def id(self) -> ApiKeyID:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return ApiKeyID(str(obj.id))


@strawberry.experimental.pydantic.type(
    DiagramMetadata,
    all_fields=True
)
class DiagramMetadataType:
    pass

@strawberry.experimental.pydantic.type(
    DomainDiagram,
    fields=["nodes", "handles", "arrows", "persons", "metadata"]
)
class DomainDiagramType:
    @strawberry.field
    def nodeCount(self) -> int:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return len(obj.nodes) if obj and hasattr(obj, "nodes") else 0

    @strawberry.field
    def arrowCount(self) -> int:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return len(obj.arrows) if obj and hasattr(obj, "arrows") else 0

@strawberry.type
class BaseNodeData:
    label: str
    flipped: Optional[bool]

@strawberry.experimental.pydantic.type(
    TokenUsage,
    all_fields=True
)
class TokenUsageType:
    pass

@strawberry.experimental.pydantic.type(
    NodeState,
    all_fields=True
)
class NodeStateType:
    pass

@strawberry.experimental.pydantic.type(
    ExecutionState,
    fields=["id", "status", "diagram_id", "started_at", "ended_at", "token_usage", "error", "duration_seconds", "is_active", "executed_nodes"]
)
class ExecutionStateType:
    @strawberry.field
    def node_states(self) -> JSONScalar:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        if hasattr(obj, "node_states"):
            # Convert NodeState objects to dicts
            return {k: v.model_dump() if hasattr(v, "model_dump") else v for k, v in obj.node_states.items()}
        return {}

    @strawberry.field
    def node_outputs(self) -> JSONScalar:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return obj.node_outputs if hasattr(obj, "node_outputs") else {}

    @strawberry.field
    def variables(self) -> JSONScalar:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return obj.variables if hasattr(obj, "variables") else {}

    @strawberry.field
    def exec_counts(self) -> JSONScalar:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return obj.exec_counts if hasattr(obj, "exec_counts") else {}


@strawberry.experimental.pydantic.type(
    ExecutionOptions,
    fields=["timeout", "debug"]
)
class ExecutionOptionsType:
    @strawberry.field
    def mode(self) -> Optional[str]:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return obj.mode if hasattr(obj, "mode") else None

    @strawberry.field
    def variables(self) -> JSONScalar:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return obj.variables if hasattr(obj, "variables") else {}


@strawberry.experimental.pydantic.type(
    InteractivePromptData,
    all_fields=True
)
class InteractivePromptDataType:
    pass

@strawberry.experimental.pydantic.type(
    InteractiveResponse,
    all_fields=True
)
class InteractiveResponseType:
    pass

@strawberry.experimental.pydantic.type(
    NodeDefinition,
    all_fields=True
)
class NodeDefinitionType:
    pass

@strawberry.experimental.pydantic.type(
    Message,
    fields=["id", "to_person_id", "content", "timestamp", "token_count", "metadata"]
)
class MessageType:
    @strawberry.field
    def from_person_id(self) -> str:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return str(obj.from_person_id) if hasattr(obj, "from_person_id") else ""

    @strawberry.field
    def message_type(self) -> str:
        obj = self._pydantic_object if hasattr(self, "_pydantic_object") else self
        return obj.message_type if hasattr(obj, "message_type") else ""


@strawberry.experimental.pydantic.type(
    ConversationMetadata,
    all_fields=True
)
class ConversationMetadataType:
    pass

@strawberry.experimental.pydantic.type(
    Conversation,
    all_fields=True
)
class ConversationType:
    pass

@strawberry.experimental.pydantic.type(
    StartNodeData,
    all_fields=True
)
class StartNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    ConditionNodeData,
    all_fields=True
)
class ConditionNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    PersonJobNodeData,
    all_fields=True
)
class PersonJobNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    CodeJobNodeData,
    all_fields=True
)
class CodeJobNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    ApiJobNodeData,
    all_fields=True
)
class ApiJobNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    EndpointNodeData,
    all_fields=True
)
class EndpointNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    DbNodeData,
    all_fields=True
)
class DBNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    UserResponseNodeData,
    all_fields=True
)
class UserResponseNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    NotionNodeData,
    all_fields=True
)
class NotionNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    HookNodeData,
    all_fields=True
)
class HookNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    TemplateJobNodeData,
    all_fields=True
)
class TemplateJobNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    JsonSchemaValidatorNodeData,
    all_fields=True
)
class JsonSchemaValidatorNodeDataType:
    pass

@strawberry.type
class TypescriptAstNodeData:
    source: Optional[str]
    extractPatterns: List[str]
    includeJSDoc: Optional[bool]
    parseMode: Optional[str]

@strawberry.experimental.pydantic.type(
    SubDiagramNodeData,
    all_fields=True
)
class SubDiagramNodeDataType:
    pass

@strawberry.experimental.pydantic.type(
    ToolConfig,
    all_fields=True
)
class ToolConfigType:
    pass

@strawberry.experimental.pydantic.type(
    WebSearchResult,
    all_fields=True
)
class WebSearchResultType:
    pass

@strawberry.experimental.pydantic.type(
    ImageGenerationResult,
    all_fields=True
)
class ImageGenerationResultType:
    pass

@strawberry.experimental.pydantic.type(
    ToolOutput,
    all_fields=True
)
class ToolOutputType:
    pass

@strawberry.experimental.pydantic.type(
    ChatResult,
    all_fields=True
)
class ChatResultType:
    pass

@strawberry.experimental.pydantic.type(
    LLMRequestOptions,
    all_fields=True
)
class LLMRequestOptionsType:
    pass


# ============ Input Types ============

@strawberry.input
class ExecutionUpdate:
    type: EventType
    execution_id: ExecutionID
    node_id: Optional[NodeID] = None
    status: Optional[NodeExecutionStatus] = None
    result: Optional[JSONScalar] = None
    error: Optional[str] = None
    timestamp: Optional[str] = None
    total_tokens: Optional[float] = None
    node_type: Optional[str] = None
    tokens: Optional[float] = None
    data: Optional[JSONScalar] = None


# ============ Unions ============

NodeData = strawberry.union("NodeData", types=[BaseNodeData, StartNodeDataType, ConditionNodeDataType, PersonJobNodeDataType, CodeJobNodeDataType, ApiJobNodeDataType, EndpointNodeDataType, DBNodeDataType, UserResponseNodeDataType, NotionNodeDataType, HookNodeDataType, TemplateJobNodeDataType, JsonSchemaValidatorNodeDataType, TypescriptAstNodeData, SubDiagramNodeDataType])
