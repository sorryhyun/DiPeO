/**
 * GENERATED FILE - DO NOT EDIT
 * Generated by generate-zod-schemas.ts
 * 
 * This file contains Zod validation schemas generated from domain models.
 * To customize validation, use the validation functions in each node's config file.
 */

import { z } from 'zod';
import { 
  PersonID, 
  NodeID, 
  HandleID, 
  ArrowID,
  NodeType,
  SupportedLanguage,
  HttpMethod,
  DBBlockSubType,
  HookType,
  ForgettingMode,
  NotionOperation,
  HookTriggerMode,
  ContentType
} from '@dipeo/domain-models';

// Re-export enum schemas for validation
export const HandleDirectionSchema = z.enum(['input', 'output']);
export const HandleLabelSchema = z.enum(['default', 'first', 'condtrue', 'condfalse', 'success', 'error', 'results']);
export const DataTypeSchema = z.enum(['any', 'string', 'number', 'boolean', 'object', 'array']);
export const MemoryViewSchema = z.enum(['all_involved', 'sent_by_me', 'sent_to_me', 'system_and_me', 'conversation_pairs', 'all_messages']);
export const DiagramFormatSchema = z.enum(['native', 'light', 'readable']);

// Node data schemas
export const NODE_DATA_SCHEMAS = {
  'start': z.object({
    custom_data: z.record(z.string(), z.any()),
    output_data_structure: z.record(z.string(), z.string()),
    trigger_mode: z.any().optional(),
    hook_event: z.string().optional(),
    hook_filters: z.record(z.string(), z.any()).optional()
  }),
  'person_job': z.object({
    person: z.any().optional(),
    first_only_prompt: z.string(),
    default_prompt: z.string().optional(),
    max_iteration: z.number(),
    memory_config: z.any().optional().nullable(),
    memory_settings: z.any().optional().nullable(),
    tools: z.array(z.any()).optional().nullable()
  }),
  'condition': z.object({
    condition_type: z.string(),
    expression: z.string().optional(),
    node_indices: z.array(z.string()).optional()
  }),
  'endpoint': z.object({
    save_to_file: z.boolean(),
    file_name: z.string().optional()
  }),
  'db': z.object({
    file: z.string().optional(),
    collection: z.string().optional(),
    sub_type: z.any(),
    operation: z.string(),
    query: z.string().optional(),
    data: z.record(z.string(), z.any()).optional()
  }),
  'code_job': z.object({
    language: z.any(),
    filePath: z.string().optional(),
    code: z.string().optional(),
    functionName: z.string().optional(),
    timeout: z.number().optional()
  }),
  'api_job': z.object({
    url: z.string(),
    method: z.any(),
    headers: z.record(z.string(), z.string()).optional(),
    params: z.record(z.string(), z.any()).optional(),
    body: z.any().optional(),
    timeout: z.number().optional(),
    auth_type: z.any().optional(),
    auth_config: z.record(z.string(), z.string()).optional()
  }),
  'user_response': z.object({
    prompt: z.string(),
    timeout: z.number()
  }),
  'notion': z.object({
    operation: z.any(),
    page_id: z.string().optional(),
    database_id: z.string().optional()
  }),
  'hook': z.object({
    hook_type: z.any(),
    config: z.any(),
    timeout: z.number().optional(),
    retry_count: z.number().optional(),
    retry_delay: z.number().optional()
  }),
} as const;

// Type exports
export type StartNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['start']>;
export type PersonJobNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['person_job']>;
export type ConditionNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['condition']>;
export type EndpointNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['endpoint']>;
export type DBNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['db']>;
export type CodeJobNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['code_job']>;
export type ApiJobNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['api_job']>;
export type UserResponseNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['user_response']>;
export type NotionNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['notion']>;
export type HookNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['hook']>;

/**
 * Get validation schema for a node type
 */
export function getNodeDataSchema(nodeType: string) {
  return NODE_DATA_SCHEMAS[nodeType as keyof typeof NODE_DATA_SCHEMAS];
}

/**
 * Validate node data using the generated schema
 */
export function validateNodeData<T = unknown>(nodeType: string, data: T): { 
  success: boolean; 
  data?: T; 
  error?: z.ZodError;
} {
  const schema = getNodeDataSchema(nodeType);
  if (!schema) {
    return { success: false, error: new z.ZodError([]) };
  }
  
  const result = schema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data as T };
  } else {
    return { success: false, error: result.error };
  }
}

/**
 * Create a field validator function that uses Zod schema
 */
export function createZodFieldValidator(nodeType: string, fieldName: string) {
  return (value: unknown, formData: unknown) => {
    const schema = getNodeDataSchema(nodeType);
    if (!schema) {
      return { isValid: true }; // No schema, assume valid
    }
    
    // Type cast to access shape property
    const schemaShape = (schema as z.ZodObject<any>).shape;
    const fieldSchema = schemaShape?.[fieldName];
    
    if (!fieldSchema) {
      return { isValid: true }; // No field schema, assume valid
    }
    
    const result = fieldSchema.safeParse(value);
    
    if (result.success) {
      return { isValid: true };
    } else {
      const error = result.error.errors[0];
      return { 
        isValid: false, 
        error: error?.message || 'Invalid value'
      };
    }
  };
}
