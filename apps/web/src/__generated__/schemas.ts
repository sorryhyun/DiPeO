/**
 * GENERATED FILE - DO NOT EDIT
 * Generated by domain model Zod schemas generation
 * Generated at: 2025-09-14T15:18:58.131005
 *
 * This file contains Zod validation schemas generated from domain models.
 * To customize validation, use the validation functions in each node's config file.
 */

import { z } from 'zod';
import {
  PersonID,
  NodeID,
  HandleID,
  ArrowID,
  NodeType,
  SupportedLanguage,
  HttpMethod,
  DBBlockSubType,
  HookType,
  HookTriggerMode,
  ContentType,
  DiagramFormat,
  ToolSelection,
  APIServiceType
} from '@dipeo/models';

// Node validation schemas
export const ApiJobSchema = z.object({
  url: z.string(),
  method: z.enum(["GET", "POST", "PUT", "DELETE", "PATCH"]),
  headers: z.record(z.any()).optional(),
  params: z.record(z.any()).optional(),
  body: z.record(z.any()).optional(),
  timeout: z.number().optional(),
  auth_type: z.enum(["none", "bearer", "basic", "api_key"]).optional(),
  auth_config: z.record(z.any()).optional()
});

export type ApiJob = z.infer<typeof ApiJobSchema>;
export const CodeJobSchema = z.object({
  language: z.enum(["python", "typescript", "bash", "shell"]),
  filePath: z.string().optional(),
  code: z.string().optional(),
  functionName: z.string().optional(),
  timeout: z.number().optional()
});

export type CodeJob = z.infer<typeof CodeJobSchema>;
export const ConditionSchema = z.object({
  condition_type: z.enum(["detect_max_iterations", "check_nodes_executed", "custom", "llm_decision"]).optional(),
  expression: z.string().optional(),
  node_indices: z.array(z.any()).optional(),
  person: z.string().optional(),
  judge_by: z.string().optional(),
  judge_by_file: z.string().optional(),
  memorize_to: z.string().optional(),
  at_most: z.number().optional(),
  expose_index_as: z.string().optional(),
  skippable: z.boolean().optional()
});

export type Condition = z.infer<typeof ConditionSchema>;
export const DbSchema = z.object({
  file: z.any().optional(),
  collection: z.string().optional(),
  sub_type: z.enum(["fixed_prompt", "file", "code", "api_tool"]),
  operation: z.string(),
  query: z.string().optional(),
  data: z.record(z.any()).optional(),
  serialize_json: z.boolean().optional(),
  format: z.string().optional()
});

export type Db = z.infer<typeof DbSchema>;
export const EndpointSchema = z.object({
  save_to_file: z.boolean(),
  file_name: z.string().optional()
});

export type Endpoint = z.infer<typeof EndpointSchema>;
export const HookSchema = z.object({
  hook_type: z.enum(["shell", "http", "python", "file"]),
  command: z.string().optional(),
  url: z.string().regex(/^https?:\/\//).optional(),
  timeout: z.number().min(1).max(300).optional(),
  retry_count: z.number().min(0).max(5).optional()
});

export type Hook = z.infer<typeof HookSchema>;
export const IntegratedApiSchema = z.object({
  provider: z.string(),
  operation: z.string(),
  resource_id: z.string().optional(),
  config: z.record(z.any()).optional(),
  timeout: z.number().min(1).max(300).optional(),
  max_retries: z.number().min(0).max(10).optional()
});

export type IntegratedApi = z.infer<typeof IntegratedApiSchema>;
export const JsonSchemaValidatorSchema = z.object({
  schema_path: z.string().optional(),
  schema: z.record(z.any()).optional(),
  data_path: z.string().optional(),
  strict_mode: z.boolean().optional(),
  error_on_extra: z.boolean().optional()
});

export type JsonSchemaValidator = z.infer<typeof JsonSchemaValidatorSchema>;
export const PersonJobSchema = z.object({
  person: z.string().optional(),
  first_only_prompt: z.string(),
  first_prompt_file: z.string().optional(),
  default_prompt: z.string().optional(),
  prompt_file: z.string().optional(),
  max_iteration: z.number(),
  memorize_to: z.string().optional(),
  at_most: z.number().min(1).max(500).optional(),
  ignore_person: z.string().optional(),
  tools: z.string().optional(),
  text_format: z.string().optional(),
  text_format_file: z.string().optional(),
  resolved_prompt: z.string().optional(),
  resolved_first_prompt: z.string().optional(),
  batch: z.boolean().optional(),
  batch_input_key: z.string().optional(),
  batch_parallel: z.boolean().optional(),
  max_concurrent: z.number().min(1).max(100).optional()
});

export type PersonJob = z.infer<typeof PersonJobSchema>;
export const StartSchema = z.object({
  trigger_mode: z.enum(["none", "manual", "hook"]).optional(),
  custom_data: z.any().optional(),
  output_data_structure: z.record(z.any()).optional(),
  hook_event: z.string().optional(),
  hook_filters: z.record(z.any()).optional()
});

export type Start = z.infer<typeof StartSchema>;
export const SubDiagramSchema = z.object({
  diagram_name: z.string().optional(),
  diagram_data: z.record(z.any()).optional(),
  input_mapping: z.record(z.any()).optional(),
  output_mapping: z.record(z.any()).optional(),
  timeout: z.number().min(1).max(3600).optional(),
  wait_for_completion: z.boolean().optional(),
  isolate_conversation: z.boolean().optional(),
  ignoreIfSub: z.boolean().optional(),
  diagram_format: z.enum(["yaml", "json", "light"]).optional(),
  batch: z.boolean().optional(),
  batch_input_key: z.string().optional(),
  batch_parallel: z.boolean().optional()
});

export type SubDiagram = z.infer<typeof SubDiagramSchema>;
export const TemplateJobSchema = z.object({
  template_path: z.string().optional(),
  template_content: z.string().optional(),
  output_path: z.string().optional(),
  variables: z.record(z.any()).optional(),
  engine: z.enum(["internal", "jinja2"]).optional(),
  preprocessor: z.string().optional()
});

export type TemplateJob = z.infer<typeof TemplateJobSchema>;
export const TypescriptAstSchema = z.object({
  source: z.string(),
  extractPatterns: z.array(z.any()).optional(),
  includeJSDoc: z.boolean().optional(),
  parseMode: z.enum(["module", "script"]).optional(),
  transformEnums: z.boolean().optional(),
  flattenOutput: z.boolean().optional(),
  outputFormat: z.enum(["standard", "for_codegen", "for_analysis"]).optional(),
  batch: z.boolean().optional(),
  batchInputKey: z.string().optional()
});

export type TypescriptAst = z.infer<typeof TypescriptAstSchema>;
export const UserResponseSchema = z.object({
  prompt: z.string(),
  timeout: z.number().optional()
});

export type UserResponse = z.infer<typeof UserResponseSchema>;

// Export all schemas
export const nodeSchemas = {
  apijob: ApiJobSchema,
  codejob: CodeJobSchema,
  condition: ConditionSchema,
  db: DbSchema,
  endpoint: EndpointSchema,
  hook: HookSchema,
  integratedapi: IntegratedApiSchema,
  jsonschemavalidator: JsonSchemaValidatorSchema,
  personjob: PersonJobSchema,
  start: StartSchema,
  subdiagram: SubDiagramSchema,
  templatejob: TemplateJobSchema,
  typescriptast: TypescriptAstSchema,
  userresponse: UserResponseSchema
} as const;

// Export validation helper
export function validateNodeData<T extends keyof typeof nodeSchemas>(
  nodeType: T,
  data: unknown
): z.infer<typeof nodeSchemas[T]> {
  return nodeSchemas[nodeType].parse(data);
}
