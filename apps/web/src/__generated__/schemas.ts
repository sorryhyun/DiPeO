/**
 * GENERATED FILE - DO NOT EDIT
 * Generated by domain model Zod schemas generation
 * Generated at: 2025-09-12T17:36:01.784922
 *
 * This file contains Zod validation schemas generated from domain models.
 * To customize validation, use the validation functions in each node's config file.
 */

import { z } from 'zod';
import {
  PersonID,
  NodeID,
  HandleID,
  ArrowID,
  NodeType,
  SupportedLanguage,
  HttpMethod,
  DBBlockSubType,
  HookType,
  HookTriggerMode,
  ContentType,
  DiagramFormat,
  ToolSelection,
  APIServiceType
} from '@dipeo/models';

// Re-export enum schemas for validation

// Node data schemas
export const NODE_DATA_SCHEMAS = {
  'api_job': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    url: z.string(),
    method: z.enum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH']),
    headers: z.record(z.string(), z.any()).optional(),
    params: z.record(z.string(), z.any()).optional(),
    body: z.record(z.string(), z.any()).optional(),
    timeout: z.number().optional(),
    auth_type: z.enum(['none', 'bearer', 'basic', 'api_key']).optional(),
    auth_config: z.record(z.string(), z.any()).optional()
  }),
  'code_job': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    language: z.enum(['python', 'typescript', 'bash', 'shell']),
    filePath: z.string().optional(),
    code: z.string().optional(),
    functionName: z.string().optional(),
    timeout: z.number().optional()
  }),
  'condition': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    condition_type: z.enum(['detect_max_iterations', 'check_nodes_executed', 'custom', 'llm_decision']).optional(),
    expression: z.string().optional(),
    node_indices: z.array(z.any()).optional(),
    person: z.string().optional(),
    judge_by: z.string().optional(),
    judge_by_file: z.string().optional(),
    memorize_to: z.string().optional(),
    at_most: z.number().optional(),
    expose_index_as: z.string().optional(),
    skippable: z.boolean().optional()
  }),
  'db': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    file: z.string().optional(),
    collection: z.string().optional(),
    sub_type: z.enum(['fixed_prompt', 'file', 'code', 'api_tool']),
    operation: z.string(),
    query: z.string().optional(),
    data: z.record(z.string(), z.any()).optional(),
    serialize_json: z.boolean().optional(),
    format: z.string().optional()
  }),
  'endpoint': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    save_to_file: z.boolean(),
    file_name: z.string().optional()
  }),
  'hook': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    hook_type: z.enum(['shell', 'http', 'python', 'file']),
    command: z.string().optional(),
    url: z.string().optional(),
    timeout: z.number().optional(),
    retry_count: z.number().optional()
  }),
  'integrated_api': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    provider: z.string(),
    operation: z.string(),
    resource_id: z.string().optional(),
    config: z.record(z.string(), z.any()).optional(),
    timeout: z.number().optional(),
    max_retries: z.number().optional()
  }),
  'json_schema_validator': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    schema_path: z.string().optional(),
    schema: z.record(z.string(), z.any()).optional(),
    data_path: z.string().optional(),
    strict_mode: z.boolean().optional(),
    error_on_extra: z.boolean().optional()
  }),
  'person_job': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    person: z.string().optional(),
    first_only_prompt: z.string(),
    first_prompt_file: z.string().optional(),
    default_prompt: z.string().optional(),
    prompt_file: z.string().optional(),
    max_iteration: z.number(),
    memorize_to: z.string().optional(),
    at_most: z.number().optional(),
    ignore_person: z.string().optional(),
    tools: z.string().optional(),
    text_format: z.string().optional(),
    text_format_file: z.string().optional(),
    resolved_prompt: z.string().optional(),
    resolved_first_prompt: z.string().optional(),
    batch: z.boolean().optional(),
    batch_input_key: z.string().optional(),
    batch_parallel: z.boolean().optional(),
    max_concurrent: z.number().optional()
  }),
  'start': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    trigger_mode: z.enum(['none', 'manual', 'hook']).optional(),
    custom_data: z.string().optional(),
    output_data_structure: z.record(z.string(), z.any()).optional(),
    hook_event: z.string().optional(),
    hook_filters: z.record(z.string(), z.any()).optional()
  }),
  'sub_diagram': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    diagram_name: z.string().optional(),
    diagram_data: z.record(z.string(), z.any()).optional(),
    input_mapping: z.record(z.string(), z.any()).optional(),
    output_mapping: z.record(z.string(), z.any()).optional(),
    timeout: z.number().optional(),
    wait_for_completion: z.boolean().optional(),
    isolate_conversation: z.boolean().optional(),
    ignoreIfSub: z.boolean().optional(),
    diagram_format: z.enum(['yaml', 'json', 'light']).optional(),
    batch: z.boolean().optional(),
    batch_input_key: z.string().optional(),
    batch_parallel: z.boolean().optional()
  }),
  'template_job': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    template_path: z.string().optional(),
    template_content: z.string().optional(),
    output_path: z.string().optional(),
    variables: z.record(z.string(), z.any()).optional(),
    engine: z.enum(['internal', 'jinja2']).optional(),
    preprocessor: z.string().optional()
  }),
  'typescript_ast': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    source: z.string(),
    extractPatterns: z.array(z.any()).optional(),
    includeJSDoc: z.boolean().optional(),
    parseMode: z.enum(['module', 'script']).optional(),
    transformEnums: z.boolean().optional(),
    flattenOutput: z.boolean().optional(),
    outputFormat: z.enum(['standard', 'for_codegen', 'for_analysis']).optional(),
    batch: z.boolean().optional(),
    batchInputKey: z.string().optional()
  }),
  'user_response': z.object({
    label: z.string(),
    flipped: z.boolean().optional(),
    prompt: z.string(),
    timeout: z.number().optional()
  }),
} as const;

// Type exports
export type ApiJobNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['api_job']>;
export type CodeJobNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['code_job']>;
export type ConditionNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['condition']>;
export type DbNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['db']>;
export type EndpointNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['endpoint']>;
export type HookNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['hook']>;
export type IntegratedApiNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['integrated_api']>;
export type JsonSchemaValidatorNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['json_schema_validator']>;
export type PersonJobNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['person_job']>;
export type StartNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['start']>;
export type SubDiagramNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['sub_diagram']>;
export type TemplateJobNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['template_job']>;
export type TypescriptAstNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['typescript_ast']>;
export type UserResponseNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['user_response']>;

// Helper function to get schema for a node type
export function getNodeDataSchema(nodeType: string) {
  return NODE_DATA_SCHEMAS[nodeType as keyof typeof NODE_DATA_SCHEMAS];
}

// Validate node data
export function validateNodeData(nodeType: string, data: unknown) {
  const schema = getNodeDataSchema(nodeType);
  if (!schema) {
    throw new Error(`No schema found for node type: ${nodeType}`);
  }
  return schema.parse(data);
}

/**
 * Create a field validator function that uses Zod schema
 */
export function createZodFieldValidator(nodeType: string, fieldName: string) {
  return (value: unknown, formData: unknown) => {
    const schema = getNodeDataSchema(nodeType);
    if (!schema) {
      return { isValid: true }; // No schema, assume valid
    }

    // Type cast to access shape property
    const schemaShape = (schema as z.ZodObject<any>).shape;
    const fieldSchema = schemaShape?.[fieldName];

    if (!fieldSchema) {
      return { isValid: true }; // No field schema, assume valid
    }

    try {
      fieldSchema.parse(value);
      return { isValid: true };
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          isValid: false,
          error: error.errors[0]?.message || 'Invalid value'
        };
      }
      return {
        isValid: false,
        error: 'Validation failed'
      };
    }
  };
}
