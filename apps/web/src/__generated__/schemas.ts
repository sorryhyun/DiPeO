/**
 * GENERATED FILE - DO NOT EDIT
 * Generated by domain model Zod schemas generation
 * Generated at: 2025-07-29T23:40:02.484104
 * 
 * This file contains Zod validation schemas generated from domain models.
 * To customize validation, use the validation functions in each node's config file.
 */

import { z } from 'zod';
import { 
  PersonID, 
  NodeID, 
  HandleID, 
  ArrowID,
  NodeType,
  SupportedLanguage,
  HttpMethod,
  DBBlockSubType,
  HookType,
  NotionOperation,
  HookTriggerMode,
  ContentType,
  DiagramFormat,
  MemoryProfile,
  ToolSelection
} from '@dipeo/domain-models';

// Re-export enum schemas for validation

// Node data schemas
export const NODE_DATA_SCHEMAS = {
  'start': z.object({
    trigger_mode: z.nativeEnum(HookTriggerMode),
    custom_data: z.record(z.string(), z.any()).optional(),
    output_data_structure: z.record(z.string(), z.string()).optional(),
    hook_event: z.string().optional(),
    hook_filters: z.record(z.string(), z.any()).optional()
  }),
  'person_job': z.object({
    person: z.string().optional(),
    first_only_prompt: z.string(),
    default_prompt: z.string().optional(),
    max_iteration: z.number(),
    memory_profile: z.nativeEnum(MemoryProfile).optional(),
    memory_settings: z.any().optional().nullable(),
    tools: z.nativeEnum(ToolSelection).optional()
  }),
  'condition': z.object({
    condition_type: z.string(),
    expression: z.string().optional(),
    node_indices: z.array(z.string()).optional()
  }),
  'endpoint': z.object({
    save_to_file: z.boolean(),
    file_name: z.string().optional()
  }),
  'db': z.object({
    file: z.array(z.any()).optional(),
    collection: z.string().optional(),
    sub_type: z.nativeEnum(DBBlockSubType),
    operation: z.string(),
    query: z.string().optional(),
    data: z.record(z.string(), z.any()).optional()
  }),
  'code_job': z.object({
    language: z.nativeEnum(SupportedLanguage),
    filePath: z.string().optional(),
    code: z.string().optional(),
    functionName: z.string().optional(),
    timeout: z.number().optional()
  }),
  'api_job': z.object({
    url: z.string(),
    method: z.nativeEnum(HttpMethod),
    headers: z.record(z.string(), z.string()).optional(),
    params: z.record(z.string(), z.any()).optional(),
    body: z.any().optional(),
    timeout: z.number().optional(),
    auth_type: z.any().optional(),
    auth_config: z.record(z.string(), z.string()).optional()
  }),
  'user_response': z.object({
    prompt: z.string(),
    timeout: z.number()
  }),
  'notion': z.object({
    operation: z.nativeEnum(NotionOperation),
    page_id: z.string().optional(),
    database_id: z.string().optional()
  }),
  'hook': z.object({
    hook_type: z.nativeEnum(HookType),
    command: z.string().optional(),
    args: z.array(z.string()).optional(),
    env: z.record(z.string(), z.string()).optional(),
    cwd: z.string().optional(),
    url: z.string().optional(),
    method: z.nativeEnum(HttpMethod).optional(),
    headers: z.record(z.string(), z.string()).optional(),
    script: z.string().optional(),
    function_name: z.string().optional(),
    file_path: z.string().optional(),
    format: z.any().optional(),
    timeout: z.number().optional(),
    retry_count: z.number().optional(),
    retry_delay: z.number().optional()
  }),
  'template_job': z.object({
    template_path: z.string().optional(),
    template_content: z.string().optional(),
    output_path: z.string().optional(),
    variables: z.record(z.string(), z.any()).optional(),
    engine: z.any().optional()
  }),
  'json_schema_validator': z.object({
    schema_path: z.string().optional(),
    schema: z.record(z.string(), z.any()).optional(),
    data_path: z.string().optional(),
    strict_mode: z.boolean().optional(),
    error_on_extra: z.boolean().optional()
  }),
  'typescript_ast': z.object({
    source: z.string().optional(),
    extractPatterns: z.array(z.string()).optional(),
    includeJSDoc: z.boolean().optional(),
    parseMode: z.any().optional()
  }),
  'sub_diagram': z.object({
    diagram_name: z.string().optional(),
    diagram_format: z.nativeEnum(DiagramFormat).optional(),
    diagram_data: z.record(z.string(), z.any()).optional(),
    batch: z.boolean().optional(),
    batch_input_key: z.string().optional(),
    batch_parallel: z.boolean().optional(),
    ignoreIfSub: z.boolean().optional()
  }),
} as const;

// Type exports
export type StartNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['start']>;
export type PersonJobNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['person_job']>;
export type ConditionNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['condition']>;
export type EndpointNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['endpoint']>;
export type DBNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['db']>;
export type CodeJobNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['code_job']>;
export type ApiJobNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['api_job']>;
export type UserResponseNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['user_response']>;
export type NotionNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['notion']>;
export type HookNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['hook']>;
export type TemplateJobNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['template_job']>;
export type JsonSchemaValidatorNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['json_schema_validator']>;
export type TypescriptAstNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['typescript_ast']>;
export type SubDiagramNodeDataSchema = z.infer<typeof NODE_DATA_SCHEMAS['sub_diagram']>;

// Helper function to get schema for a node type
export function getNodeDataSchema(nodeType: string) {
  return NODE_DATA_SCHEMAS[nodeType as keyof typeof NODE_DATA_SCHEMAS];
}

// Validate node data
export function validateNodeData(nodeType: string, data: unknown) {
  const schema = getNodeDataSchema(nodeType);
  if (!schema) {
    throw new Error(`No schema found for node type: ${nodeType}`);
  }
  return schema.parse(data);
}

/**
 * Create a field validator function that uses Zod schema
 */
export function createZodFieldValidator(nodeType: string, fieldName: string) {
  return (value: unknown, formData: unknown) => {
    const schema = getNodeDataSchema(nodeType);
    if (!schema) {
      return { isValid: true }; // No schema, assume valid
    }
    
    // Type cast to access shape property
    const schemaShape = (schema as z.ZodObject<any>).shape;
    const fieldSchema = schemaShape?.[fieldName];
    
    if (!fieldSchema) {
      return { isValid: true }; // No field schema, assume valid
    }
    
    try {
      fieldSchema.parse(value);
      return { isValid: true };
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          isValid: false,
          error: error.errors[0]?.message || 'Invalid value'
        };
      }
      return {
        isValid: false,
        error: 'Validation failed'
      };
    }
  };
}